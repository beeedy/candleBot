; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\ipc_mbx.o --asm_dir=.\ --list_dir=.\ --depend=.\ipc_mbx.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I. -I..\..\common -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 -DCORE_M0 -DIPC_SLAVE -DPIXY --omf_browse=.\ipc_mbx.crf ipc_mbx.c]
                          THUMB

                          AREA ||i.IPC_downloadSlaveImage||, CODE, READONLY, ALIGN=2

                  IPC_downloadSlaveImage PROC
;;;241    /* download a processor image to the SLAVE CPU */
;;;242    void IPC_downloadSlaveImage(uint32_t slaveRomStart, const unsigned char slaveImage[], uint32_t imageSize)
000000  b5f8              PUSH     {r3-r7,lr}
;;;243    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  4617              MOV      r7,r2
;;;244      	uint32_t i;
;;;245    	volatile uint8_t *pu8SRAM;
;;;246    
;;;247    	IPC_haltSlave();
000008  f7fffffe          BL       IPC_haltSlave
;;;248    
;;;249        //Copy application into Slave ROM 
;;;250    	pu8SRAM = (uint8_t *) slaveRomStart;
00000c  9500              STR      r5,[sp,#0]
;;;251    	for (i = 0; i < imageSize; i++)
00000e  2400              MOVS     r4,#0
000010  e003              B        |L1.26|
                  |L1.18|
;;;252    	{
;;;253    		pu8SRAM[i] = slaveImage[i];
000012  5d31              LDRB     r1,[r6,r4]
000014  9800              LDR      r0,[sp,#0]
000016  5501              STRB     r1,[r0,r4]
000018  1c64              ADDS     r4,r4,#1              ;251
                  |L1.26|
00001a  42bc              CMP      r4,r7                 ;251
00001c  d3f9              BCC      |L1.18|
;;;254    	 }
;;;255    
;;;256    	// Set Slave shadow pointer to begining of rom (where application is located) 
;;;257    	*(volatile uint32_t *) SLAVE_SHADOW_REG = slaveRomStart;
00001e  4801              LDR      r0,|L1.36|
000020  6045              STR      r5,[r0,#4]
;;;258    }
000022  bdf8              POP      {r3-r7,pc}
;;;259    
                          ENDP

                  |L1.36|
                          DCD      0x40043400

                          AREA ||i.IPC_dummyCallback||, CODE, READONLY, ALIGN=1

                  IPC_dummyCallback PROC
;;;68     /* dummy callback function */
;;;69     void IPC_dummyCallback(msg_t message, msgId_t idNum, mbxParam_t parameter) {return;}
000000  4770              BX       lr
;;;70     
                          ENDP


                          AREA ||i.IPC_getMbxParameter||, CODE, READONLY, ALIGN=2

                  IPC_getMbxParameter PROC
;;;141    /* return the parameter */
;;;142    mbxParam_t IPC_getMbxParameter(mbxId_t mbxNum) {
000000  4601              MOV      r1,r0
;;;143    	
;;;144    	Mbx* lPtr = (Mbx*) (mbxLocalTablePtr);
000002  4803              LDR      r0,|L3.16|
000004  6802              LDR      r2,[r0,#0]  ; mbxLocalTablePtr
;;;145    	lPtr += mbxNum;
000006  0108              LSLS     r0,r1,#4
000008  1812              ADDS     r2,r2,r0
;;;146    	return (lPtr->mbxParam);
00000a  6890              LDR      r0,[r2,#8]
;;;147    }
00000c  4770              BX       lr
;;;148    
                          ENDP

00000e  0000              DCW      0x0000
                  |L3.16|
                          DCD      mbxLocalTablePtr

                          AREA ||i.IPC_getMsgId||, CODE, READONLY, ALIGN=2

                  IPC_getMsgId PROC
;;;133    /* return the message id */
;;;134    msgId_t IPC_getMsgId(mbxId_t mbxNum) {
000000  4601              MOV      r1,r0
;;;135    		
;;;136    	Mbx* lPtr = (Mbx*) (mbxLocalTablePtr);
000002  4803              LDR      r0,|L4.16|
000004  6802              LDR      r2,[r0,#0]  ; mbxLocalTablePtr
;;;137    	lPtr += mbxNum;
000006  0108              LSLS     r0,r1,#4
000008  1812              ADDS     r2,r2,r0
;;;138    	return (lPtr->mbxHeader.msgId);
00000a  8890              LDRH     r0,[r2,#4]
;;;139    }
00000c  4770              BX       lr
;;;140    
                          ENDP

00000e  0000              DCW      0x0000
                  |L4.16|
                          DCD      mbxLocalTablePtr

                          AREA ||i.IPC_getMsgType||, CODE, READONLY, ALIGN=2

                  IPC_getMsgType PROC
;;;125    /* return the message type */
;;;126    msg_t IPC_getMsgType(mbxId_t mbxNum)	{
000000  4601              MOV      r1,r0
;;;127    		
;;;128    	Mbx* lPtr = (Mbx*) (mbxLocalTablePtr);
000002  4803              LDR      r0,|L5.16|
000004  6802              LDR      r2,[r0,#0]  ; mbxLocalTablePtr
;;;129    	lPtr += mbxNum;
000006  0108              LSLS     r0,r1,#4
000008  1812              ADDS     r2,r2,r0
;;;130    	return (lPtr->mbxHeader.msg);
00000a  7890              LDRB     r0,[r2,#2]
;;;131    }
00000c  4770              BX       lr
;;;132    
                          ENDP

00000e  0000              DCW      0x0000
                  |L5.16|
                          DCD      mbxLocalTablePtr

                          AREA ||i.IPC_haltSlave||, CODE, READONLY, ALIGN=2

                  IPC_haltSlave PROC
;;;279    /* put the SLAVE processor back in reset */
;;;280    void IPC_haltSlave(void) {
000000  b50c              PUSH     {r2,r3,lr}
;;;281    
;;;282    	volatile uint32_t u32REG, u32Val;
;;;283    	
;;;284    	// Check if M0 is reset by reading status
;;;285    	u32REG = LPC_RGU->RESET_ACTIVE_STATUS1;
000002  480c              LDR      r0,|L6.52|
000004  6940              LDR      r0,[r0,#0x14]
000006  9001              STR      r0,[sp,#4]
;;;286    			
;;;287    	// If the M0 has reset not asserted, halt it... 
;;;288    	// in u32REG, status register, 1 = no reset
;;;289    	while ((u32REG & (1u << 24)))
000008  e00c              B        |L6.36|
                  |L6.10|
;;;290    	{
;;;291    		u32Val = ( (~u32REG) | (1 << 24));
00000a  9801              LDR      r0,[sp,#4]
00000c  43c0              MVNS     r0,r0
00000e  2101              MOVS     r1,#1
000010  0609              LSLS     r1,r1,#24
000012  4308              ORRS     r0,r0,r1
000014  9000              STR      r0,[sp,#0]
;;;292    		LPC_RGU->RESET_CTRL1 = u32Val;
000016  4907              LDR      r1,|L6.52|
000018  3940              SUBS     r1,r1,#0x40
00001a  9800              LDR      r0,[sp,#0]
00001c  6048              STR      r0,[r1,#4]
;;;293    		u32REG = LPC_RGU->RESET_ACTIVE_STATUS1;			
00001e  4805              LDR      r0,|L6.52|
000020  6940              LDR      r0,[r0,#0x14]
000022  9001              STR      r0,[sp,#4]
                  |L6.36|
000024  2101              MOVS     r1,#1                 ;289
000026  0609              LSLS     r1,r1,#24             ;289
000028  9801              LDR      r0,[sp,#4]            ;289
00002a  4008              ANDS     r0,r0,r1              ;289
00002c  2800              CMP      r0,#0                 ;289
00002e  d1ec              BNE      |L6.10|
;;;294    	}
;;;295    }
000030  bd0c              POP      {r2,r3,pc}
;;;296    
                          ENDP

000032  0000              DCW      0x0000
                  |L6.52|
                          DCD      0x40053140

                          AREA ||i.IPC_initMasterMbx||, CODE, READONLY, ALIGN=2

                  IPC_initMasterMbx PROC
;;;312    	  
;;;313    void IPC_initMasterMbx(CbackItem cbackTable[], Mbx* masterMbxPtr, Mbx* slaveMbxPtr)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;314    {
000002  460e              MOV      r6,r1
000004  4617              MOV      r7,r2
;;;315    	int i;
;;;316    	Mbx* lPtr;
;;;317    
;;;318    	// initialize the pointers
;;;319    	mbxLocalTablePtr = masterMbxPtr;
000006  4815              LDR      r0,|L7.92|
000008  6006              STR      r6,[r0,#0]  ; mbxLocalTablePtr
;;;320    	mbxRemoteTablePtr = slaveMbxPtr;
00000a  4815              LDR      r0,|L7.96|
00000c  6007              STR      r7,[r0,#0]  ; mbxRemoteTablePtr
;;;321    	
;;;322    	// clear the mailbox and the flags
;;;323    	for(i=0, lPtr = mbxLocalTablePtr; i<NUM_MASTER_MBX; i++,lPtr++) {
00000e  2500              MOVS     r5,#0
000010  4812              LDR      r0,|L7.92|
000012  6804              LDR      r4,[r0,#0]  ; mbxLocalTablePtr
000014  e00a              B        |L7.44|
                  |L7.22|
;;;324    		lPtr->mbxStatus = READY;
000016  2000              MOVS     r0,#0
000018  7020              STRB     r0,[r4,#0]
;;;325    		lPtr->mbxHeader.msg = MBX_MSG_DEFAULT;
00001a  70a0              STRB     r0,[r4,#2]
;;;326    		lPtr->mbxHeader.msgId = MBX_MSGID_DEFAULT;
00001c  2100              MOVS     r1,#0
00001e  80a1              STRH     r1,[r4,#4]
;;;327    		lPtr->mbxParam = MBX_PARAM_DEFAULT;
000020  60a0              STR      r0,[r4,#8]
;;;328    		mbxFlags[i] = NO_MSG;
000022  2002              MOVS     r0,#2
000024  490f              LDR      r1,|L7.100|
000026  5548              STRB     r0,[r1,r5]
000028  1c6d              ADDS     r5,r5,#1              ;323
00002a  3410              ADDS     r4,r4,#0x10           ;323
                  |L7.44|
00002c  2d04              CMP      r5,#4                 ;323
00002e  dbf2              BLT      |L7.22|
;;;329       }
;;;330       
;;;331       // plug the actual callbacks
;;;332       _plugCallbacks(&cbackTable[0], NUM_MASTER_MBX);
000030  2104              MOVS     r1,#4
000032  9800              LDR      r0,[sp,#0]
000034  f7fffffe          BL       _plugCallbacks
;;;333    
;;;334    	SLAVE_TXEV_QUIT();
000038  2000              MOVS     r0,#0
00003a  490b              LDR      r1,|L7.104|
00003c  6008              STR      r0,[r1,#0]
;;;335    
;;;336    	// disable IRQ
;;;337    	NVIC_DisableIRQ((IRQn_Type)SLAVE_IRQn);	
00003e  2001              MOVS     r0,#1
000040  f7fffffe          BL       NVIC_DisableIRQ
;;;338    
;;;339    	// clear any pending interrupt
;;;340    	NVIC_ClearPendingIRQ((IRQn_Type)SLAVE_IRQn);
000044  2001              MOVS     r0,#1
000046  f7fffffe          BL       NVIC_ClearPendingIRQ
;;;341    
;;;342    	// set the default priority for the mbx interrupts
;;;343    	NVIC_SetPriority((IRQn_Type)SLAVE_IRQn, MASTER_MAILBOX_PRIORITY);
00004a  2100              MOVS     r1,#0
00004c  2001              MOVS     r0,#1
00004e  f7fffffe          BL       NVIC_SetPriority
;;;344    			
;;;345    	// enable the interrupt
;;;346    	NVIC_EnableIRQ((IRQn_Type)SLAVE_IRQn);	
000052  2001              MOVS     r0,#1
000054  f7fffffe          BL       NVIC_EnableIRQ
;;;347    }
000058  bdfe              POP      {r1-r7,pc}
;;;348    
                          ENDP

00005a  0000              DCW      0x0000
                  |L7.92|
                          DCD      mbxLocalTablePtr
                  |L7.96|
                          DCD      mbxRemoteTablePtr
                  |L7.100|
                          DCD      mbxFlags
                  |L7.104|
                          DCD      0x40043400

                          AREA ||i.IPC_initSlaveMbx||, CODE, READONLY, ALIGN=2

                  IPC_initSlaveMbx PROC
;;;184    /* initialize the slave MBX ipc framework */
;;;185    void IPC_initSlaveMbx(CbackItem cbackTable[], Mbx* masterMbxPtr, Mbx* slaveMbxPtr)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;186    {	
000002  460e              MOV      r6,r1
000004  4617              MOV      r7,r2
;;;187    	mbxId_t i;			
;;;188    	Mbx* lPtr;
;;;189    
;;;190    	// initialize the pointers
;;;191    	mbxLocalTablePtr = slaveMbxPtr;
000006  4815              LDR      r0,|L8.92|
000008  6007              STR      r7,[r0,#0]  ; mbxLocalTablePtr
;;;192    	mbxRemoteTablePtr = masterMbxPtr;
00000a  4815              LDR      r0,|L8.96|
00000c  6006              STR      r6,[r0,#0]  ; mbxRemoteTablePtr
;;;193    
;;;194    	// clear the mailbox and the flags
;;;195    	for(i=(mbxId_t)0, lPtr = mbxLocalTablePtr; i<NUM_SLAVE_MBX; i++,lPtr++) {
00000e  2500              MOVS     r5,#0
000010  4812              LDR      r0,|L8.92|
000012  6804              LDR      r4,[r0,#0]  ; mbxLocalTablePtr
000014  e00b              B        |L8.46|
                  |L8.22|
;;;196    	
;;;197    		lPtr->mbxStatus = READY;
000016  2000              MOVS     r0,#0
000018  7020              STRB     r0,[r4,#0]
;;;198    		lPtr->mbxHeader.msg = MBX_MSG_DEFAULT;
00001a  70a0              STRB     r0,[r4,#2]
;;;199    		lPtr->mbxHeader.msgId = MBX_MSGID_DEFAULT;
00001c  2100              MOVS     r1,#0
00001e  80a1              STRH     r1,[r4,#4]
;;;200    		lPtr->mbxParam = MBX_PARAM_DEFAULT;
000020  60a0              STR      r0,[r4,#8]
;;;201    		mbxFlags[i] = NO_MSG;
000022  2002              MOVS     r0,#2
000024  490f              LDR      r1,|L8.100|
000026  5548              STRB     r0,[r1,r5]
000028  1c68              ADDS     r0,r5,#1              ;195
00002a  b2c5              UXTB     r5,r0                 ;195
00002c  3410              ADDS     r4,r4,#0x10           ;195
                  |L8.46|
00002e  2d04              CMP      r5,#4                 ;195
000030  dbf1              BLT      |L8.22|
;;;202    	}
;;;203    
;;;204        // plug the actual callbacks functions 
;;;205    	_plugCallbacks(&cbackTable[0], NUM_SLAVE_MBX);
000032  2104              MOVS     r1,#4
000034  9800              LDR      r0,[sp,#0]
000036  f7fffffe          BL       _plugCallbacks
;;;206    
;;;207    	NVIC_DisableIRQ((IRQn_Type)MASTER_IRQn);
00003a  2001              MOVS     r0,#1
00003c  f7fffffe          BL       NVIC_DisableIRQ
;;;208    
;;;209    	MASTER_TXEV_QUIT();
000040  2000              MOVS     r0,#0
000042  4909              LDR      r1,|L8.104|
000044  6308              STR      r0,[r1,#0x30]
;;;210    
;;;211    	// clear the interrupt
;;;212    	NVIC_ClearPendingIRQ((IRQn_Type)MASTER_IRQn);
000046  2001              MOVS     r0,#1
000048  f7fffffe          BL       NVIC_ClearPendingIRQ
;;;213    			
;;;214    	// set the default priority for the interrupts
;;;215    	NVIC_SetPriority((IRQn_Type)MASTER_IRQn, SLAVE_MAILBOX_PRIORITY);
00004c  2100              MOVS     r1,#0
00004e  2001              MOVS     r0,#1
000050  f7fffffe          BL       NVIC_SetPriority
;;;216    				
;;;217    	// enable the interrupt
;;;218    	NVIC_EnableIRQ((IRQn_Type)MASTER_IRQn);
000054  2001              MOVS     r0,#1
000056  f7fffffe          BL       NVIC_EnableIRQ
;;;219    }
00005a  bdfe              POP      {r1-r7,pc}
;;;220    	
                          ENDP

                  |L8.92|
                          DCD      mbxLocalTablePtr
                  |L8.96|
                          DCD      mbxRemoteTablePtr
                  |L8.100|
                          DCD      mbxFlags
                  |L8.104|
                          DCD      0x40043100

                          AREA ||i.IPC_queryLocalMbx||, CODE, READONLY, ALIGN=2

                  IPC_queryLocalMbx PROC
;;;115    /* return the local mailbox status */
;;;116    mbxStat_t IPC_queryLocalMbx(mbxId_t mbxNum) 	{		
000000  4601              MOV      r1,r0
;;;117    
;;;118    	Mbx* lPtr;
;;;119    		
;;;120    	lPtr = (Mbx*) (mbxLocalTablePtr);
000002  4803              LDR      r0,|L9.16|
000004  6802              LDR      r2,[r0,#0]  ; mbxLocalTablePtr
;;;121    	lPtr += mbxNum;
000006  0108              LSLS     r0,r1,#4
000008  1812              ADDS     r2,r2,r0
;;;122    	return (lPtr->mbxStatus);
00000a  7810              LDRB     r0,[r2,#0]
;;;123    }
00000c  4770              BX       lr
;;;124    
                          ENDP

00000e  0000              DCW      0x0000
                  |L9.16|
                          DCD      mbxLocalTablePtr

                          AREA ||i.IPC_queryRemoteMbx||, CODE, READONLY, ALIGN=2

                  IPC_queryRemoteMbx PROC
;;;154    /* return the remote mailbox status */
;;;155    mbxStat_t IPC_queryRemoteMbx(mbxId_t mbxNum) {
000000  4601              MOV      r1,r0
;;;156    
;;;157    	Mbx* rPtr = (Mbx*)(mbxRemoteTablePtr);	
000002  4803              LDR      r0,|L10.16|
000004  6802              LDR      r2,[r0,#0]  ; mbxRemoteTablePtr
;;;158    	rPtr += mbxNum;
000006  0108              LSLS     r0,r1,#4
000008  1812              ADDS     r2,r2,r0
;;;159    	return (rPtr->mbxStatus);
00000a  7810              LDRB     r0,[r2,#0]
;;;160    }
00000c  4770              BX       lr
;;;161    	
                          ENDP

00000e  0000              DCW      0x0000
                  |L10.16|
                          DCD      mbxRemoteTablePtr

                          AREA ||i.IPC_resetMbxFlag||, CODE, READONLY, ALIGN=2

                  IPC_resetMbxFlag PROC
;;;73      ***********************************************************************/
;;;74     void IPC_resetMbxFlag(mbxId_t mbxNum) {
000000  bf00              NOP      
;;;75     
;;;76     		// on cortex M4/M3 use primask
;;;77     		// on cortex M0 disable interrupts globally
;;;78     		IRQ_LOCK_KEY
;;;79     
;;;80     		_lockInts();
000002  f3ef8210          MRS      r2,PRIMASK
000006  07d1              LSLS     r1,r2,#31
000008  0fc9              LSRS     r1,r1,#31
00000a  b672              CPSID    i
00000c  bf00              NOP      
;;;81     		mbxFlags[mbxNum] = NO_MSG;
00000e  2202              MOVS     r2,#2
000010  4b03              LDR      r3,|L11.32|
000012  541a              STRB     r2,[r3,r0]
;;;82     		_unlockInts();
000014  bf00              NOP      
000016  2900              CMP      r1,#0
000018  d100              BNE      |L11.28|
00001a  b662              CPSIE    i
                  |L11.28|
00001c  bf00              NOP      
;;;83     }
00001e  4770              BX       lr
;;;84     
                          ENDP

                  |L11.32|
                          DCD      mbxFlags

                          AREA ||i.IPC_sendMsg||, CODE, READONLY, ALIGN=2

                  IPC_sendMsg PROC
;;;161    	
;;;162    void IPC_sendMsg(mbxId_t mbxNum, msg_t msg, msgId_t msgNum, mbxParam_t param) {
000000  b530              PUSH     {r4,r5,lr}
000002  4604              MOV      r4,r0
;;;163    
;;;164    	Mbx* rPtr = (Mbx*)(mbxRemoteTablePtr);	
000004  4d06              LDR      r5,|L12.32|
000006  6828              LDR      r0,[r5,#0]  ; mbxRemoteTablePtr
;;;165    	rPtr += mbxNum;
000008  0125              LSLS     r5,r4,#4
00000a  1940              ADDS     r0,r0,r5
;;;166    		
;;;167    	// prepare the information
;;;168    	rPtr->mbxHeader.msg = msg;
00000c  7081              STRB     r1,[r0,#2]
;;;169    	rPtr->mbxHeader.msgId = msgNum;	
00000e  8082              STRH     r2,[r0,#4]
;;;170    	rPtr->mbxParam = param;
000010  6083              STR      r3,[r0,#8]
;;;171    	rPtr->mbxStatus = PROCESS;
000012  2501              MOVS     r5,#1
000014  7005              STRB     r5,[r0,#0]
;;;172    
;;;173    	// make sure all data transactions complete before next instruction is executed
;;;174    	__DSB();  	
000016  f3bf8f4f          DSB      
;;;175    							
;;;176    	// now trigger the remote processor
;;;177    	__sev();
00001a  bf40              SEV      
;;;178    }
00001c  bd30              POP      {r4,r5,pc}
;;;179    
                          ENDP

00001e  0000              DCW      0x0000
                  |L12.32|
                          DCD      mbxRemoteTablePtr

                          AREA ||i.IPC_startSlave||, CODE, READONLY, ALIGN=2

                  IPC_startSlave PROC
;;;261    /* take SLAVE processor out of reset */
;;;262    void IPC_startSlave(void)
000000  b50c              PUSH     {r2,r3,lr}
;;;263    {
;;;264    	volatile uint32_t u32REG, u32Val;
;;;265    	
;;;266    	// Release Slave from reset, first read status 
;;;267    	u32REG = LPC_RGU->RESET_ACTIVE_STATUS1;
000002  480b              LDR      r0,|L13.48|
000004  6940              LDR      r0,[r0,#0x14]
000006  9001              STR      r0,[sp,#4]
;;;268    			
;;;269    	// If the M0 is being held in reset, release it... 
;;;270    	// 1 = no reset, 0 = reset
;;;271    	while(!(u32REG & (1u << 24)))
000008  e00a              B        |L13.32|
                  |L13.10|
;;;272    	{
;;;273    		u32Val = (~(u32REG) & (~(1 << 24)));
00000a  480a              LDR      r0,|L13.52|
00000c  9901              LDR      r1,[sp,#4]
00000e  4388              BICS     r0,r0,r1
000010  9000              STR      r0,[sp,#0]
;;;274    		LPC_RGU->RESET_CTRL1 = u32Val;
000012  4907              LDR      r1,|L13.48|
000014  3940              SUBS     r1,r1,#0x40
000016  9800              LDR      r0,[sp,#0]
000018  6048              STR      r0,[r1,#4]
;;;275    		u32REG = LPC_RGU->RESET_ACTIVE_STATUS1;
00001a  4805              LDR      r0,|L13.48|
00001c  6940              LDR      r0,[r0,#0x14]
00001e  9001              STR      r0,[sp,#4]
                  |L13.32|
000020  2101              MOVS     r1,#1                 ;271
000022  0609              LSLS     r1,r1,#24             ;271
000024  9801              LDR      r0,[sp,#4]            ;271
000026  4008              ANDS     r0,r0,r1              ;271
000028  2800              CMP      r0,#0                 ;271
00002a  d0ee              BEQ      |L13.10|
;;;276    	};
;;;277    }
00002c  bd0c              POP      {r2,r3,pc}
;;;278    
                          ENDP

00002e  0000              DCW      0x0000
                  |L13.48|
                          DCD      0x40053140
                  |L13.52|
                          DCD      0xfeffffff

                          AREA ||i.M0CORE_IRQHandler||, CODE, READONLY, ALIGN=2

                  M0CORE_IRQHandler PROC
;;;350    /* interrupt to master from slave */
;;;351    void M0CORE_IRQHandler() {
000000  b510              PUSH     {r4,lr}
;;;352    
;;;353    	mbxId_t i;
;;;354    		
;;;355    	// acknowledge the interrupt
;;;356    	SLAVE_TXEV_QUIT();
000002  2000              MOVS     r0,#0
000004  4909              LDR      r1,|L14.44|
000006  6008              STR      r0,[r1,#0]
;;;357    
;;;358    	for(i=(mbxId_t)0;i<NUM_MASTER_MBX;i++) {
000008  2400              MOVS     r4,#0
00000a  e00c              B        |L14.38|
                  |L14.12|
;;;359    
;;;360    		if(PROCESS == IPC_queryLocalMbx(i)) {
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       IPC_queryLocalMbx
000012  2801              CMP      r0,#1
000014  d105              BNE      |L14.34|
;;;361    
;;;362    			_mbxProcess(i);
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       _mbxProcess
;;;363    
;;;364    			mbxFlags[i] = MSG_PENDING;			
00001c  2001              MOVS     r0,#1
00001e  4904              LDR      r1,|L14.48|
000020  5508              STRB     r0,[r1,r4]
                  |L14.34|
000022  1c60              ADDS     r0,r4,#1              ;358
000024  b2c4              UXTB     r4,r0                 ;358
                  |L14.38|
000026  2c04              CMP      r4,#4                 ;358
000028  dbf0              BLT      |L14.12|
;;;365    		}
;;;366    	};
;;;367    }
00002a  bd10              POP      {r4,pc}
;;;368    
                          ENDP

                  |L14.44|
                          DCD      0x40043400
                  |L14.48|
                          DCD      mbxFlags

                          AREA ||i.M0_M4CORE_IRQHandler||, CODE, READONLY, ALIGN=2

                  M0_M4CORE_IRQHandler PROC
;;;223    /* interrupt from Master on Slave side */
;;;224    void M0_M4CORE_IRQHandler() {		
000000  b510              PUSH     {r4,lr}
;;;225    
;;;226    	mbxId_t i;
;;;227    		
;;;228    	// quit the interrupt
;;;229    	MASTER_TXEV_QUIT();
000002  2000              MOVS     r0,#0
000004  4909              LDR      r1,|L15.44|
000006  6308              STR      r0,[r1,#0x30]
;;;230    
;;;231    	for(i=(mbxId_t)0; i<NUM_SLAVE_MBX;i++) {
000008  2400              MOVS     r4,#0
00000a  e00c              B        |L15.38|
                  |L15.12|
;;;232    	
;;;233    		if(PROCESS == IPC_queryLocalMbx(i)) {
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       IPC_queryLocalMbx
000012  2801              CMP      r0,#1
000014  d105              BNE      |L15.34|
;;;234    			_mbxProcess(i);
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       _mbxProcess
;;;235    			mbxFlags[i] = MSG_PENDING;
00001c  2001              MOVS     r0,#1
00001e  4904              LDR      r1,|L15.48|
000020  5508              STRB     r0,[r1,r4]
                  |L15.34|
000022  1c60              ADDS     r0,r4,#1              ;231
000024  b2c4              UXTB     r4,r0                 ;231
                  |L15.38|
000026  2c04              CMP      r4,#4                 ;231
000028  dbf0              BLT      |L15.12|
;;;236    		}
;;;237    	};
;;;238    }
00002a  bd10              POP      {r4,pc}
;;;239    
                          ENDP

                  |L15.44|
                          DCD      0x40043100
                  |L15.48|
                          DCD      mbxFlags

                          AREA ||i.NVIC_ClearPendingIRQ||, CODE, READONLY, ALIGN=2

                  NVIC_ClearPendingIRQ PROC
;;;568     */
;;;569    static __INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
000000  06c2              LSLS     r2,r0,#27
;;;570    {
;;;571      NVIC->ICPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
000002  0ed2              LSRS     r2,r2,#27
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  4a01              LDR      r2,|L16.16|
00000a  6011              STR      r1,[r2,#0]
;;;572    }
00000c  4770              BX       lr
;;;573    
                          ENDP

00000e  0000              DCW      0x0000
                  |L16.16|
                          DCD      0xe000e280

                          AREA ||i.NVIC_DisableIRQ||, CODE, READONLY, ALIGN=2

                  NVIC_DisableIRQ PROC
;;;527     */
;;;528    static __INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
000000  06c2              LSLS     r2,r0,#27
;;;529    {
;;;530      NVIC->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
000002  0ed2              LSRS     r2,r2,#27
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  4a01              LDR      r2,|L17.16|
00000a  6011              STR      r1,[r2,#0]
;;;531    }
00000c  4770              BX       lr
;;;532    
                          ENDP

00000e  0000              DCW      0x0000
                  |L17.16|
                          DCD      0xe000e180

                          AREA ||i.NVIC_EnableIRQ||, CODE, READONLY, ALIGN=2

                  NVIC_EnableIRQ PROC
;;;514     */
;;;515    static __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
000000  06c2              LSLS     r2,r0,#27
;;;516    {
;;;517      NVIC->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
000002  0ed2              LSRS     r2,r2,#27
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  4a01              LDR      r2,|L18.16|
00000a  6011              STR      r1,[r2,#0]
;;;518    }
00000c  4770              BX       lr
;;;519    
                          ENDP

00000e  0000              DCW      0x0000
                  |L18.16|
                          DCD      0xe000e100

                          AREA ||i.NVIC_SetPriority||, CODE, READONLY, ALIGN=2

                  NVIC_SetPriority PROC
;;;585     */
;;;586    static __INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
000000  b510              PUSH     {r4,lr}
;;;587    {
;;;588      if(IRQn < 0) {
000002  2800              CMP      r0,#0
000004  da19              BGE      |L19.58|
;;;589        SCB->SHP[_SHP_IDX(IRQn)] = (SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
000006  4a1a              LDR      r2,|L19.112|
000008  0703              LSLS     r3,r0,#28
00000a  0f1b              LSRS     r3,r3,#28
00000c  3b08              SUBS     r3,r3,#8
00000e  089b              LSRS     r3,r3,#2
000010  009b              LSLS     r3,r3,#2
000012  58d2              LDR      r2,[r2,r3]
000014  0783              LSLS     r3,r0,#30
000016  0edc              LSRS     r4,r3,#27
000018  23ff              MOVS     r3,#0xff
00001a  40a3              LSLS     r3,r3,r4
00001c  439a              BICS     r2,r2,r3
00001e  078b              LSLS     r3,r1,#30
000020  0e1b              LSRS     r3,r3,#24
000022  0784              LSLS     r4,r0,#30
000024  0ee4              LSRS     r4,r4,#27
000026  40a3              LSLS     r3,r3,r4
000028  431a              ORRS     r2,r2,r3
00002a  4b11              LDR      r3,|L19.112|
00002c  0704              LSLS     r4,r0,#28
00002e  0f24              LSRS     r4,r4,#28
000030  3c08              SUBS     r4,r4,#8
000032  08a4              LSRS     r4,r4,#2
000034  00a4              LSLS     r4,r4,#2
000036  511a              STR      r2,[r3,r4]
000038  e018              B        |L19.108|
                  |L19.58|
;;;590            (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
;;;591      else {
;;;592        NVIC->IP[_IP_IDX(IRQn)] = (NVIC->IP[_IP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
00003a  4a0e              LDR      r2,|L19.116|
00003c  2303              MOVS     r3,#3
00003e  021b              LSLS     r3,r3,#8
000040  18d2              ADDS     r2,r2,r3
000042  0883              LSRS     r3,r0,#2
000044  009b              LSLS     r3,r3,#2
000046  58d2              LDR      r2,[r2,r3]
000048  0783              LSLS     r3,r0,#30
00004a  0edc              LSRS     r4,r3,#27
00004c  23ff              MOVS     r3,#0xff
00004e  40a3              LSLS     r3,r3,r4
000050  439a              BICS     r2,r2,r3
000052  078b              LSLS     r3,r1,#30
000054  0e1b              LSRS     r3,r3,#24
000056  0784              LSLS     r4,r0,#30
000058  0ee4              LSRS     r4,r4,#27
00005a  40a3              LSLS     r3,r3,r4
00005c  431a              ORRS     r2,r2,r3
00005e  4b05              LDR      r3,|L19.116|
000060  2403              MOVS     r4,#3
000062  0224              LSLS     r4,r4,#8
000064  191b              ADDS     r3,r3,r4
000066  0884              LSRS     r4,r0,#2
000068  00a4              LSLS     r4,r4,#2
00006a  511a              STR      r2,[r3,r4]
                  |L19.108|
;;;593            (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
;;;594    }
00006c  bd10              POP      {r4,pc}
;;;595    
                          ENDP

00006e  0000              DCW      0x0000
                  |L19.112|
                          DCD      0xe000ed1c
                  |L19.116|
                          DCD      0xe000e100

                          AREA ||i._mbxProcess||, CODE, READONLY, ALIGN=2

                  _mbxProcess PROC
;;;85     /* execute a local mailbox callback */
;;;86     static void _mbxProcess(mbxId_t mbxNum)
000000  b570              PUSH     {r4-r6,lr}
;;;87     {															 
000002  4605              MOV      r5,r0
;;;88     	Mbx* lPtr = (Mbx*) (mbxLocalTablePtr);
000004  4804              LDR      r0,|L20.24|
000006  6804              LDR      r4,[r0,#0]  ; mbxLocalTablePtr
;;;89     	lPtr += mbxNum;
000008  0128              LSLS     r0,r5,#4
00000a  1824              ADDS     r4,r4,r0
;;;90     
;;;91     	// execute the function callback
;;;92     	(*(lPtr->mbxAction))(lPtr->mbxHeader.msg, lPtr->mbxHeader.msgId, lPtr->mbxParam);
00000c  88a1              LDRH     r1,[r4,#4]
00000e  78a0              LDRB     r0,[r4,#2]
000010  68e3              LDR      r3,[r4,#0xc]
000012  68a2              LDR      r2,[r4,#8]
000014  4798              BLX      r3
;;;93     }
000016  bd70              POP      {r4-r6,pc}
;;;94     
                          ENDP

                  |L20.24|
                          DCD      mbxLocalTablePtr

                          AREA ||i._plugCallbacks||, CODE, READONLY, ALIGN=2

                  _plugCallbacks PROC
;;;297    
;;;298    static void _plugCallbacks(CbackItem callBackTable[], uint32_t numMbx)
000000  b510              PUSH     {r4,lr}
;;;299    {	 
000002  4602              MOV      r2,r0
;;;300    	Mbx* lPtr;
;;;301    	mbxId_t i;
;;;302    
;;;303    	for(i=(mbxId_t)0;i<numMbx;i++) {
000004  2000              MOVS     r0,#0
000006  e00b              B        |L21.32|
                  |L21.8|
;;;304    
;;;305     		lPtr = mbxLocalTablePtr;
000008  4c07              LDR      r4,|L21.40|
00000a  6823              LDR      r3,[r4,#0]  ; mbxLocalTablePtr
;;;306    		lPtr += callBackTable[i].mbxNum;
00000c  00c4              LSLS     r4,r0,#3
00000e  5d14              LDRB     r4,[r2,r4]
000010  0124              LSLS     r4,r4,#4
000012  191b              ADDS     r3,r3,r4
;;;307    		
;;;308    		lPtr->mbxAction = (mbxCallback_t) callBackTable[i].func;
000014  00c4              LSLS     r4,r0,#3
000016  18a4              ADDS     r4,r4,r2
000018  6864              LDR      r4,[r4,#4]
00001a  60dc              STR      r4,[r3,#0xc]
00001c  1c44              ADDS     r4,r0,#1              ;303
00001e  b2e0              UXTB     r0,r4                 ;303
                  |L21.32|
000020  4288              CMP      r0,r1                 ;303
000022  d3f1              BCC      |L21.8|
;;;309    	};
;;;310    }
000024  bd10              POP      {r4,pc}
;;;311    
                          ENDP

000026  0000              DCW      0x0000
                  |L21.40|
                          DCD      mbxLocalTablePtr

                          AREA ||i._setMbxStatus||, CODE, READONLY, ALIGN=2

                  _setMbxStatus PROC
;;;96     /* change the local mailbox status */
;;;97     void _setMbxStatus(mbxId_t mbxNum, mbxStat_t status)
000000  b530              PUSH     {r4,r5,lr}
;;;98     {
;;;99     	// if cortex M4/M3 use primask, else disable interrupts globally
;;;100    	IRQ_LOCK_KEY
;;;101    
;;;102    	Mbx* lPtr = (Mbx*) (mbxLocalTablePtr);
000002  4c0d              LDR      r4,|L22.56|
000004  6823              LDR      r3,[r4,#0]  ; mbxLocalTablePtr
;;;103    	lPtr += mbxNum;
000006  0104              LSLS     r4,r0,#4
000008  191b              ADDS     r3,r3,r4
;;;104    
;;;105    	_lockInts();
00000a  bf00              NOP      
00000c  f3ef8410          MRS      r4,PRIMASK
000010  07e2              LSLS     r2,r4,#31
000012  0fd2              LSRS     r2,r2,#31
000014  b672              CPSID    i
000016  bf00              NOP      
;;;106    
;;;107    	lPtr->mbxStatus = status;
000018  7019              STRB     r1,[r3,#0]
;;;108    	if((status == READY) || (status == ERROR_OCCURRED)) mbxFlags[mbxNum] = NO_MSG;
00001a  2900              CMP      r1,#0
00001c  d001              BEQ      |L22.34|
00001e  2903              CMP      r1,#3
000020  d102              BNE      |L22.40|
                  |L22.34|
000022  2402              MOVS     r4,#2
000024  4d05              LDR      r5,|L22.60|
000026  542c              STRB     r4,[r5,r0]
                  |L22.40|
;;;109    
;;;110    	__DSB(); /* sync the data */
000028  f3bf8f4f          DSB      
;;;111    
;;;112    	_unlockInts();
00002c  bf00              NOP      
00002e  2a00              CMP      r2,#0
000030  d100              BNE      |L22.52|
000032  b662              CPSIE    i
                  |L22.52|
000034  bf00              NOP      
;;;113    }
000036  bd30              POP      {r4,r5,pc}
;;;114    	
                          ENDP

                  |L22.56|
                          DCD      mbxLocalTablePtr
                  |L22.60|
                          DCD      mbxFlags

                          AREA ||.data||, DATA, ALIGN=2

                  mbxFlags
                          DCD      0x00000000
                  mbxLocalTablePtr
                          DCD      0x00000000
                  mbxRemoteTablePtr
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "ipc_mbx.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___9_ipc_mbx_c_e30818db____REV16|
#line 130 ".\\core_cmInstr.h"
|__asm___9_ipc_mbx_c_e30818db____REV16| PROC
#line 131

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___9_ipc_mbx_c_e30818db____REVSH|
#line 144
|__asm___9_ipc_mbx_c_e30818db____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
