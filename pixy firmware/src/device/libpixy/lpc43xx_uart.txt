; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\lpc43xx_uart.o --asm_dir=.\ --list_dir=.\ --depend=.\lpc43xx_uart.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I. -I..\..\common -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 -DCORE_M0 -DIPC_SLAVE -DPIXY --omf_browse=.\lpc43xx_uart.crf lpc43xx_uart.c]
                          THUMB

                          AREA ||i.UART_ABCmd||, CODE, READONLY, ALIGN=2

                  UART_ABCmd PROC
;;;953     **********************************************************************/
;;;954    void UART_ABCmd(LPC_USARTn_Type *UARTx, UART_AB_CFG_Type *ABConfigStruct, \
000000  b530              PUSH     {r4,r5,lr}
;;;955    				FunctionalState NewState)
;;;956    {
000002  460b              MOV      r3,r1
;;;957    	uint32_t tmp;
;;;958    
;;;959    	CHECK_PARAM(PARAM_UARTx(UARTx));
;;;960    	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
;;;961    
;;;962    	tmp = 0;
000004  2100              MOVS     r1,#0
;;;963    	if (NewState == ENABLE) {
000006  2a01              CMP      r2,#1
000008  d109              BNE      |L1.30|
;;;964    		if (ABConfigStruct->ABMode == UART_AUTOBAUD_MODE1){
00000a  781c              LDRB     r4,[r3,#0]
00000c  2c01              CMP      r4,#1
00000e  d101              BNE      |L1.20|
;;;965    			tmp |= UART_ACR_MODE;
000010  2402              MOVS     r4,#2
000012  4321              ORRS     r1,r1,r4
                  |L1.20|
;;;966    		}
;;;967    		if (ABConfigStruct->AutoRestart == ENABLE){
000014  785c              LDRB     r4,[r3,#1]
000016  2c01              CMP      r4,#1
000018  d101              BNE      |L1.30|
;;;968    			tmp |= UART_ACR_AUTO_RESTART;
00001a  2404              MOVS     r4,#4
00001c  4321              ORRS     r1,r1,r4
                  |L1.30|
;;;969    		}
;;;970    	}
;;;971    
;;;972    	if (((LPC_UART1_Type *)UARTx) == LPC_UART1)
00001e  4c16              LDR      r4,|L1.120|
000020  42a0              CMP      r0,r4
000022  d114              BNE      |L1.78|
;;;973    	{
;;;974    		if (NewState == ENABLE)
000024  2a01              CMP      r2,#1
000026  d10f              BNE      |L1.72|
;;;975    		{
;;;976    			// Clear DLL and DLM value
;;;977    			((LPC_UART1_Type *)UARTx)->LCR |= UART_LCR_DLAB_EN;
000028  68c4              LDR      r4,[r0,#0xc]
00002a  2580              MOVS     r5,#0x80
00002c  432c              ORRS     r4,r4,r5
00002e  60c4              STR      r4,[r0,#0xc]
;;;978    			((LPC_UART1_Type *)UARTx)->DLL = 0;
000030  2400              MOVS     r4,#0
000032  6004              STR      r4,[r0,#0]
;;;979    			((LPC_UART1_Type *)UARTx)->DLM = 0;
000034  6044              STR      r4,[r0,#4]
;;;980    			((LPC_UART1_Type *)UARTx)->LCR &= ~UART_LCR_DLAB_EN;
000036  68c4              LDR      r4,[r0,#0xc]
000038  43ac              BICS     r4,r4,r5
00003a  60c4              STR      r4,[r0,#0xc]
;;;981    			// FDR value must be reset to default value
;;;982    			((LPC_UART1_Type *)UARTx)->FDR = 0x10;
00003c  2410              MOVS     r4,#0x10
00003e  6284              STR      r4,[r0,#0x28]
;;;983    			((LPC_UART1_Type *)UARTx)->ACR = UART_ACR_START | tmp;
000040  2401              MOVS     r4,#1
000042  430c              ORRS     r4,r4,r1
000044  6204              STR      r4,[r0,#0x20]
000046  e016              B        |L1.118|
                  |L1.72|
;;;984    		}
;;;985    		else
;;;986    		{
;;;987    			((LPC_UART1_Type *)UARTx)->ACR = 0;
000048  2400              MOVS     r4,#0
00004a  6204              STR      r4,[r0,#0x20]
00004c  e013              B        |L1.118|
                  |L1.78|
;;;988    		}
;;;989    	}
;;;990    	else
;;;991    	{
;;;992    		if (NewState == ENABLE)
00004e  2a01              CMP      r2,#1
000050  d10f              BNE      |L1.114|
;;;993    		{
;;;994    			// Clear DLL and DLM value
;;;995    			UARTx->LCR |= UART_LCR_DLAB_EN;
000052  68c4              LDR      r4,[r0,#0xc]
000054  2580              MOVS     r5,#0x80
000056  432c              ORRS     r4,r4,r5
000058  60c4              STR      r4,[r0,#0xc]
;;;996    			UARTx->DLL = 0;
00005a  2400              MOVS     r4,#0
00005c  6004              STR      r4,[r0,#0]
;;;997    			UARTx->DLM = 0;
00005e  6044              STR      r4,[r0,#4]
;;;998    			UARTx->LCR &= ~UART_LCR_DLAB_EN;
000060  68c4              LDR      r4,[r0,#0xc]
000062  43ac              BICS     r4,r4,r5
000064  60c4              STR      r4,[r0,#0xc]
;;;999    			// FDR value must be reset to default value
;;;1000   			UARTx->FDR = 0x10;
000066  2410              MOVS     r4,#0x10
000068  6284              STR      r4,[r0,#0x28]
;;;1001   			UARTx->ACR = UART_ACR_START | tmp;
00006a  2401              MOVS     r4,#1
00006c  430c              ORRS     r4,r4,r1
00006e  6204              STR      r4,[r0,#0x20]
000070  e001              B        |L1.118|
                  |L1.114|
;;;1002   		}
;;;1003   		else
;;;1004   		{
;;;1005   			UARTx->ACR = 0;
000072  2400              MOVS     r4,#0
000074  6204              STR      r4,[r0,#0x20]
                  |L1.118|
;;;1006   		}
;;;1007   	}
;;;1008   }
000076  bd30              POP      {r4,r5,pc}
;;;1009   
                          ENDP

                  |L1.120|
                          DCD      0x40082000

                          AREA ||i.UART_CheckBusy||, CODE, READONLY, ALIGN=1

                  UART_CheckBusy PROC
;;;843     **********************************************************************/
;;;844    FlagStatus UART_CheckBusy(LPC_USARTn_Type *UARTx)
000000  4601              MOV      r1,r0
;;;845    {
;;;846    	if (UARTx->LSR & UART_LSR_TEMT){
000002  6948              LDR      r0,[r1,#0x14]
000004  2240              MOVS     r2,#0x40
000006  4010              ANDS     r0,r0,r2
000008  2800              CMP      r0,#0
00000a  d001              BEQ      |L2.16|
;;;847    		return RESET;
00000c  2000              MOVS     r0,#0
                  |L2.14|
;;;848    	} else {
;;;849    		return SET;
;;;850    	}
;;;851    }
00000e  4770              BX       lr
                  |L2.16|
000010  2001              MOVS     r0,#1                 ;849
000012  e7fc              B        |L2.14|
;;;852    
                          ENDP


                          AREA ||i.UART_ConfigStructInit||, CODE, READONLY, ALIGN=1

                  UART_ConfigStructInit PROC
;;;509     *******************************************************************************/
;;;510    void UART_ConfigStructInit(UART_CFG_Type *UART_InitStruct)
000000  214b              MOVS     r1,#0x4b
;;;511    {
;;;512    	UART_InitStruct->Baud_rate = 9600;
000002  01c9              LSLS     r1,r1,#7
000004  6001              STR      r1,[r0,#0]
;;;513    	UART_InitStruct->Databits = UART_DATABIT_8;
000006  2103              MOVS     r1,#3
000008  7141              STRB     r1,[r0,#5]
;;;514    	UART_InitStruct->Parity = UART_PARITY_NONE;
00000a  2100              MOVS     r1,#0
00000c  7101              STRB     r1,[r0,#4]
;;;515    	UART_InitStruct->Stopbits = UART_STOPBIT_1;
00000e  7181              STRB     r1,[r0,#6]
;;;516    	UART_InitStruct->Clock_Speed = 0;
000010  6081              STR      r1,[r0,#8]
;;;517    }
000012  4770              BX       lr
;;;518    
                          ENDP


                          AREA ||i.UART_DeInit||, CODE, READONLY, ALIGN=1

                  UART_DeInit PROC
;;;459     **********************************************************************/
;;;460    void UART_DeInit(LPC_USARTn_Type* UARTx)
000000  b510              PUSH     {r4,lr}
;;;461    {
000002  4604              MOV      r4,r0
;;;462    	// For debug mode
;;;463    	CHECK_PARAM(PARAM_UARTx(UARTx));
;;;464    
;;;465    	UART_TxCmd(UARTx, DISABLE);
000004  2100              MOVS     r1,#0
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       UART_TxCmd
;;;466    
;;;467    #ifdef _UART0
;;;468    	if (UARTx == LPC_USART0)
;;;469    	{
;;;470    		/* Set up peripheral clock for UART0 module */
;;;471    		//LPC_CGU->BASE_UART0_CLK = (SRC_PL160M_1<<24) | (1<<11);	// base SRC_PL160M_1 is not configured, so no clk out
;;;472    	}
;;;473    #endif
;;;474    
;;;475    #ifdef _UART1
;;;476    	if (((LPC_UART1_Type *)UARTx) == LPC_UART1)
;;;477    	{
;;;478    		/* Set up peripheral clock for UART1 module */
;;;479    		//LPC_CGU->BASE_UART1_CLK = (SRC_PL160M_1<<24) | (1<<11);	// base SRC_PL160M_1 is not configured, so no clk out
;;;480    	}
;;;481    #endif
;;;482    
;;;483    #ifdef _UART2
;;;484    	if (UARTx == LPC_USART2)
;;;485    	{
;;;486    		/* Set up peripheral clock for UART2 module */
;;;487    		//LPC_CGU->BASE_UART2_CLK = (SRC_PL160M_1<<24) | (1<<11);	// base SRC_PL160M_1 is not configured, so no clk out
;;;488    	}
;;;489    #endif
;;;490    
;;;491    #ifdef _UART3
;;;492    	if (UARTx == LPC_USART3)
;;;493    	{
;;;494    		/* Set up peripheral clock for UART3 module */
;;;495    		//LPC_CGU->BASE_UART3_CLK = (SRC_PL160M_1<<24) | (1<<11);	// base SRC_PL160M_1 is not configured, so no clk out
;;;496    	}
;;;497    #endif
;;;498    }
00000c  bd10              POP      {r4,pc}
;;;499    
                          ENDP


                          AREA ||i.UART_FIFOConfig||, CODE, READONLY, ALIGN=2

                  UART_FIFOConfig PROC
;;;864     **********************************************************************/
;;;865    void UART_FIFOConfig(LPC_USARTn_Type *UARTx, UART_FIFO_CFG_Type *FIFOCfg)
000000  4602              MOV      r2,r0
;;;866    {
;;;867    	uint8_t tmp = 0;
000002  2000              MOVS     r0,#0
;;;868    
;;;869    	CHECK_PARAM(PARAM_UARTx(UARTx));
;;;870    	CHECK_PARAM(PARAM_UART_FIFO_LEVEL(FIFOCfg->FIFO_Level));
;;;871    	CHECK_PARAM(PARAM_FUNCTIONALSTATE(FIFOCfg->FIFO_DMAMode));
;;;872    	CHECK_PARAM(PARAM_FUNCTIONALSTATE(FIFOCfg->FIFO_ResetRxBuf));
;;;873    	CHECK_PARAM(PARAM_FUNCTIONALSTATE(FIFOCfg->FIFO_ResetTxBuf));
;;;874    
;;;875    	tmp |= UART_FCR_FIFO_EN;
000004  2301              MOVS     r3,#1
000006  4318              ORRS     r0,r0,r3
;;;876    	switch (FIFOCfg->FIFO_Level){
000008  78cb              LDRB     r3,[r1,#3]
00000a  2b00              CMP      r3,#0
00000c  d006              BEQ      |L5.28|
00000e  2b01              CMP      r3,#1
000010  d006              BEQ      |L5.32|
000012  2b02              CMP      r3,#2
000014  d007              BEQ      |L5.38|
000016  2b03              CMP      r3,#3
000018  d108              BNE      |L5.44|
00001a  e008              B        |L5.46|
                  |L5.28|
;;;877    	case UART_FIFO_TRGLEV0:
;;;878    		tmp |= UART_FCR_TRG_LEV0;
00001c  bf00              NOP      
;;;879    		break;
00001e  e009              B        |L5.52|
                  |L5.32|
;;;880    	case UART_FIFO_TRGLEV1:
;;;881    		tmp |= UART_FCR_TRG_LEV1;
000020  2340              MOVS     r3,#0x40
000022  4318              ORRS     r0,r0,r3
;;;882    		break;
000024  e006              B        |L5.52|
                  |L5.38|
;;;883    	case UART_FIFO_TRGLEV2:
;;;884    		tmp |= UART_FCR_TRG_LEV2;
000026  2380              MOVS     r3,#0x80
000028  4318              ORRS     r0,r0,r3
;;;885    		break;
00002a  e003              B        |L5.52|
                  |L5.44|
;;;886    	case UART_FIFO_TRGLEV3:
00002c  bf00              NOP      
                  |L5.46|
;;;887    	default:
;;;888    		tmp |= UART_FCR_TRG_LEV3;
00002e  23c0              MOVS     r3,#0xc0
000030  4318              ORRS     r0,r0,r3
;;;889    		break;
000032  bf00              NOP      
                  |L5.52|
000034  bf00              NOP                            ;879
;;;890    	}
;;;891    
;;;892    	if (FIFOCfg->FIFO_ResetTxBuf == ENABLE)
000036  784b              LDRB     r3,[r1,#1]
000038  2b01              CMP      r3,#1
00003a  d101              BNE      |L5.64|
;;;893    	{
;;;894    		tmp |= UART_FCR_TX_RS;
00003c  2304              MOVS     r3,#4
00003e  4318              ORRS     r0,r0,r3
                  |L5.64|
;;;895    	}
;;;896    	if (FIFOCfg->FIFO_ResetRxBuf == ENABLE)
000040  780b              LDRB     r3,[r1,#0]
000042  2b01              CMP      r3,#1
000044  d101              BNE      |L5.74|
;;;897    	{
;;;898    		tmp |= UART_FCR_RX_RS;
000046  2302              MOVS     r3,#2
000048  4318              ORRS     r0,r0,r3
                  |L5.74|
;;;899    	}
;;;900    	if (FIFOCfg->FIFO_DMAMode == ENABLE)
00004a  788b              LDRB     r3,[r1,#2]
00004c  2b01              CMP      r3,#1
00004e  d101              BNE      |L5.84|
;;;901    	{
;;;902    		tmp |= UART_FCR_DMAMODE_SEL;
000050  2308              MOVS     r3,#8
000052  4318              ORRS     r0,r0,r3
                  |L5.84|
;;;903    	}
;;;904    
;;;905    
;;;906    	//write to FIFO control register
;;;907    	if (((LPC_UART1_Type *)UARTx) == LPC_UART1)
000054  4b05              LDR      r3,|L5.108|
000056  429a              CMP      r2,r3
000058  d103              BNE      |L5.98|
;;;908    	{
;;;909    		((LPC_UART1_Type *)UARTx)->/*IIFCR.*/FCR = tmp & UART_FCR_BITMASK;
00005a  23cf              MOVS     r3,#0xcf
00005c  4003              ANDS     r3,r3,r0
00005e  6093              STR      r3,[r2,#8]
000060  e002              B        |L5.104|
                  |L5.98|
;;;910    	}
;;;911    	else
;;;912    	{
;;;913    		UARTx->/*IIFCR.*/FCR = tmp & UART_FCR_BITMASK;
000062  23cf              MOVS     r3,#0xcf
000064  4003              ANDS     r3,r3,r0
000066  6093              STR      r3,[r2,#8]
                  |L5.104|
;;;914    	}
;;;915    }
000068  4770              BX       lr
;;;916    
                          ENDP

00006a  0000              DCW      0x0000
                  |L5.108|
                          DCD      0x40082000

                          AREA ||i.UART_FIFOConfigStructInit||, CODE, READONLY, ALIGN=1

                  UART_FIFOConfigStructInit PROC
;;;928     *******************************************************************************/
;;;929    void UART_FIFOConfigStructInit(UART_FIFO_CFG_Type *UART_FIFOInitStruct)
000000  2100              MOVS     r1,#0
;;;930    {
;;;931    	UART_FIFOInitStruct->FIFO_DMAMode = DISABLE;
000002  7081              STRB     r1,[r0,#2]
;;;932    	UART_FIFOInitStruct->FIFO_Level = UART_FIFO_TRGLEV0;
000004  70c1              STRB     r1,[r0,#3]
;;;933    	UART_FIFOInitStruct->FIFO_ResetRxBuf = ENABLE;
000006  2101              MOVS     r1,#1
000008  7001              STRB     r1,[r0,#0]
;;;934    	UART_FIFOInitStruct->FIFO_ResetTxBuf = ENABLE;
00000a  7041              STRB     r1,[r0,#1]
;;;935    }
00000c  4770              BX       lr
;;;936    
                          ENDP


                          AREA ||i.UART_ForceBreak||, CODE, READONLY, ALIGN=2

                  UART_ForceBreak PROC
;;;702     **********************************************************************/
;;;703    void UART_ForceBreak(LPC_USARTn_Type* UARTx)
000000  4906              LDR      r1,|L7.28|
;;;704    {
;;;705    	CHECK_PARAM(PARAM_UARTx(UARTx));
;;;706    
;;;707    	if (((LPC_UART1_Type *)UARTx) == LPC_UART1)
000002  4288              CMP      r0,r1
000004  d104              BNE      |L7.16|
;;;708    	{
;;;709    		((LPC_UART1_Type *)UARTx)->LCR |= UART_LCR_BREAK_EN;
000006  68c1              LDR      r1,[r0,#0xc]
000008  2240              MOVS     r2,#0x40
00000a  4311              ORRS     r1,r1,r2
00000c  60c1              STR      r1,[r0,#0xc]
00000e  e003              B        |L7.24|
                  |L7.16|
;;;710    	}
;;;711    	else
;;;712    	{
;;;713    		UARTx->LCR |= UART_LCR_BREAK_EN;
000010  68c1              LDR      r1,[r0,#0xc]
000012  2240              MOVS     r2,#0x40
000014  4311              ORRS     r1,r1,r2
000016  60c1              STR      r1,[r0,#0xc]
                  |L7.24|
;;;714    	}
;;;715    }
000018  4770              BX       lr
;;;716    
                          ENDP

00001a  0000              DCW      0x0000
                  |L7.28|
                          DCD      0x40082000

                          AREA ||i.UART_FullModemConfigMode||, CODE, READONLY, ALIGN=1

                  UART_FullModemConfigMode PROC
;;;1189    **********************************************************************/
;;;1190   void UART_FullModemConfigMode(LPC_UART1_Type *UARTx, UART_MODEM_MODE_Type Mode, \
000000  b530              PUSH     {r4,r5,lr}
;;;1191   							FunctionalState NewState)
;;;1192   {
;;;1193   	uint8_t tmp = 0;
000002  2300              MOVS     r3,#0
;;;1194   
;;;1195   	CHECK_PARAM(PARAM_UART1_MODEM(UARTx));
;;;1196   	CHECK_PARAM(PARAM_UART1_MODEM_MODE(Mode));
;;;1197   	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
;;;1198   
;;;1199   	switch(Mode){
000004  2900              CMP      r1,#0
000006  d004              BEQ      |L8.18|
000008  2901              CMP      r1,#1
00000a  d004              BEQ      |L8.22|
00000c  2902              CMP      r1,#2
00000e  d106              BNE      |L8.30|
000010  e003              B        |L8.26|
                  |L8.18|
;;;1200   	case UART1_MODEM_MODE_LOOPBACK:
;;;1201   		tmp = UART1_MCR_LOOPB_EN;
000012  2310              MOVS     r3,#0x10
;;;1202   		break;
000014  e004              B        |L8.32|
                  |L8.22|
;;;1203   	case UART1_MODEM_MODE_AUTO_RTS:
;;;1204   		tmp = UART1_MCR_AUTO_RTS_EN;
000016  2340              MOVS     r3,#0x40
;;;1205   		break;
000018  e002              B        |L8.32|
                  |L8.26|
;;;1206   	case UART1_MODEM_MODE_AUTO_CTS:
;;;1207   		tmp = UART1_MCR_AUTO_CTS_EN;
00001a  2380              MOVS     r3,#0x80
;;;1208   		break;
00001c  e000              B        |L8.32|
                  |L8.30|
;;;1209   	default:
;;;1210   		break;
00001e  bf00              NOP      
                  |L8.32|
000020  bf00              NOP                            ;1202
;;;1211   	}
;;;1212   
;;;1213   	if (NewState == ENABLE)
000022  2a01              CMP      r2,#1
000024  d103              BNE      |L8.46|
;;;1214   	{
;;;1215   		UARTx->MCR |= tmp;
000026  6904              LDR      r4,[r0,#0x10]
000028  431c              ORRS     r4,r4,r3
00002a  6104              STR      r4,[r0,#0x10]
00002c  e004              B        |L8.56|
                  |L8.46|
;;;1216   	}
;;;1217   	else
;;;1218   	{
;;;1219   		UARTx->MCR &= (~tmp) & UART1_MCR_BITMASK;
00002e  6904              LDR      r4,[r0,#0x10]
000030  25f3              MOVS     r5,#0xf3
000032  439d              BICS     r5,r5,r3
000034  402c              ANDS     r4,r4,r5
000036  6104              STR      r4,[r0,#0x10]
                  |L8.56|
;;;1220   	}
;;;1221   }
000038  bd30              POP      {r4,r5,pc}
;;;1222   
                          ENDP


                          AREA ||i.UART_FullModemForcePinState||, CODE, READONLY, ALIGN=1

                  UART_FullModemForcePinState PROC
;;;1149    **********************************************************************/
;;;1150   void UART_FullModemForcePinState(LPC_UART1_Type *UARTx, UART_MODEM_PIN_Type Pin, \
000000  b530              PUSH     {r4,r5,lr}
;;;1151   							UART1_SignalState NewState)
;;;1152   {
;;;1153   	uint8_t tmp = 0;
000002  2300              MOVS     r3,#0
;;;1154   
;;;1155   	CHECK_PARAM(PARAM_UART1_MODEM(UARTx));
;;;1156   	CHECK_PARAM(PARAM_UART1_MODEM_PIN(Pin));
;;;1157   	CHECK_PARAM(PARAM_UART1_SIGNALSTATE(NewState));
;;;1158   
;;;1159   	switch (Pin){
000004  2900              CMP      r1,#0
000006  d002              BEQ      |L9.14|
000008  2901              CMP      r1,#1
00000a  d104              BNE      |L9.22|
00000c  e001              B        |L9.18|
                  |L9.14|
;;;1160   	case UART1_MODEM_PIN_DTR:
;;;1161   		tmp = UART1_MCR_DTR_CTRL;
00000e  2301              MOVS     r3,#1
;;;1162   		break;
000010  e002              B        |L9.24|
                  |L9.18|
;;;1163   	case UART1_MODEM_PIN_RTS:
;;;1164   		tmp = UART1_MCR_RTS_CTRL;
000012  2302              MOVS     r3,#2
;;;1165   		break;
000014  e000              B        |L9.24|
                  |L9.22|
;;;1166   	default:
;;;1167   		break;
000016  bf00              NOP      
                  |L9.24|
000018  bf00              NOP                            ;1162
;;;1168   	}
;;;1169   
;;;1170   	if (NewState == ACTIVE){
00001a  2a01              CMP      r2,#1
00001c  d103              BNE      |L9.38|
;;;1171   		UARTx->MCR |= tmp;
00001e  6904              LDR      r4,[r0,#0x10]
000020  431c              ORRS     r4,r4,r3
000022  6104              STR      r4,[r0,#0x10]
000024  e004              B        |L9.48|
                  |L9.38|
;;;1172   	} else {
;;;1173   		UARTx->MCR &= (~tmp) & UART1_MCR_BITMASK;
000026  6904              LDR      r4,[r0,#0x10]
000028  25f3              MOVS     r5,#0xf3
00002a  439d              BICS     r5,r5,r3
00002c  402c              ANDS     r4,r4,r5
00002e  6104              STR      r4,[r0,#0x10]
                  |L9.48|
;;;1174   	}
;;;1175   }
000030  bd30              POP      {r4,r5,pc}
;;;1176   
                          ENDP


                          AREA ||i.UART_FullModemGetStatus||, CODE, READONLY, ALIGN=1

                  UART_FullModemGetStatus PROC
;;;1235    **********************************************************************/
;;;1236   uint8_t UART_FullModemGetStatus(LPC_UART1_Type *UARTx)
000000  4601              MOV      r1,r0
;;;1237   {
;;;1238   	CHECK_PARAM(PARAM_UART1_MODEM(UARTx));
;;;1239   	return ((UARTx->MSR) & UART1_MSR_BITMASK);
000002  6988              LDR      r0,[r1,#0x18]
000004  b2c0              UXTB     r0,r0
;;;1240   }
000006  4770              BX       lr
;;;1241   
                          ENDP


                          AREA ||i.UART_GetLineStatus||, CODE, READONLY, ALIGN=2

                  UART_GetLineStatus PROC
;;;820     *********************************************************************/
;;;821    uint8_t UART_GetLineStatus(LPC_USARTn_Type* UARTx)
000000  4601              MOV      r1,r0
;;;822    {
;;;823    	CHECK_PARAM(PARAM_UARTx(UARTx));
;;;824    
;;;825    	if (((LPC_UART1_Type *)UARTx) == LPC_UART1)
000002  4804              LDR      r0,|L11.20|
000004  4281              CMP      r1,r0
000006  d102              BNE      |L11.14|
;;;826    	{
;;;827    		return ((((LPC_UART1_Type *)LPC_UART1)->LSR) & UART_LSR_BITMASK);
000008  6940              LDR      r0,[r0,#0x14]
00000a  b2c0              UXTB     r0,r0
                  |L11.12|
;;;828    	}
;;;829    	else
;;;830    	{
;;;831    		return ((UARTx->LSR) & UART_LSR_BITMASK);
;;;832    	}
;;;833    }
00000c  4770              BX       lr
                  |L11.14|
00000e  6948              LDR      r0,[r1,#0x14]         ;831
000010  b2c0              UXTB     r0,r0                 ;831
000012  e7fb              B        |L11.12|
;;;834    
                          ENDP

                  |L11.20|
                          DCD      0x40082000

                          AREA ||i.UART_Init||, CODE, READONLY, ALIGN=1

                  UART_Init PROC
;;;234     *********************************************************************/
;;;235    void UART_Init(LPC_USARTn_Type *UARTx, UART_CFG_Type *UART_ConfigStruct)
000000  4770              BX       lr
;;;236    {
;;;237    #ifndef CORE_M0 // rich: let's assume M0 doesn't do any initialization   
;;;238    	uint32_t tmp;
;;;239    
;;;240    	// For debug mode
;;;241    	CHECK_PARAM(PARAM_UARTx(UARTx));
;;;242    	CHECK_PARAM(PARAM_UART_DATABIT(UART_ConfigStruct->Databits));
;;;243    	CHECK_PARAM(PARAM_UART_STOPBIT(UART_ConfigStruct->Stopbits));
;;;244    	CHECK_PARAM(PARAM_UART_PARITY(UART_ConfigStruct->Parity));
;;;245    
;;;246    #ifdef _UART0
;;;247    	if(UARTx == LPC_USART0)
;;;248    	{
;;;249    		/* Set up peripheral clock for UART0 module */
;;;250    		//LPC_CGU->BASE_UART0_CLK = (SRC_PL160M_0<<24) | (1<<11);	// Use PLL1 and auto block
;;;251    		//CGU_EntityConnect(CGU_CLKSRC_XTAL_OSC, CGU_BASE_UART0);
;;;252    		CGU_EntityConnect(CGU_CLKSRC_PLL1, CGU_BASE_UART0);
;;;253    	}
;;;254    #endif
;;;255    
;;;256    #ifdef _UART1
;;;257    	if(((LPC_UART1_Type *)UARTx) == LPC_UART1)
;;;258    	{
;;;259    		/* Set up peripheral clock for UART1 module */
;;;260    		//LPC_CGU->BASE_UART1_CLK = (SRC_PL160M_0<<24) | (1<<11);	// Use PLL1 and auto block
;;;261    		CGU_EntityConnect(CGU_CLKSRC_PLL1, CGU_BASE_UART1);
;;;262    	}
;;;263    #endif
;;;264    
;;;265    #ifdef _UART2
;;;266    	if(UARTx == LPC_USART2)
;;;267    	{
;;;268    		/* Set up peripheral clock for UART2 module */
;;;269    		//LPC_CGU->BASE_UART2_CLK = (SRC_PL160M_0<<24) | (1<<11);	// Use PLL1 and auto block
;;;270    		CGU_EntityConnect(CGU_CLKSRC_XTAL_OSC, CGU_BASE_UART2);
;;;271    	}
;;;272    #endif
;;;273    
;;;274    #ifdef _UART3
;;;275    	if(UARTx == LPC_USART3)
;;;276    	{
;;;277    		/* Set up peripheral clock for UART3 module */
;;;278    		//LPC_CGU->BASE_UART3_CLK = (SRC_PL160M_0<<24) | (1<<11);	// Use PLL1 and auto block
;;;279    		CGU_EntityConnect(CGU_CLKSRC_XTAL_OSC, CGU_BASE_UART3);
;;;280    	}
;;;281    #endif
;;;282    
;;;283    	if (((LPC_UART1_Type *)UARTx) == LPC_UART1)
;;;284    	{
;;;285    		/* FIFOs are empty */
;;;286    		((LPC_UART1_Type *)UARTx)->/*IIFCR.*/FCR = ( UART_FCR_FIFO_EN \
;;;287    				| UART_FCR_RX_RS | UART_FCR_TX_RS);
;;;288    		// Disable FIFO
;;;289    		((LPC_UART1_Type *)UARTx)->/*IIFCR.*/FCR = 0;
;;;290    
;;;291    		// Dummy reading
;;;292    		while (((LPC_UART1_Type *)UARTx)->LSR & UART_LSR_RDR)
;;;293    		{
;;;294    			tmp = ((LPC_UART1_Type *)UARTx)->/*RBTHDLR.*/RBR;
;;;295    		}
;;;296    
;;;297    		((LPC_UART1_Type *)UARTx)->TER = UART1_TER_TXEN;
;;;298    		// Wait for current transmit complete
;;;299    		while (!(((LPC_UART1_Type *)UARTx)->LSR & UART_LSR_THRE));
;;;300    		// Disable Tx
;;;301    		((LPC_UART1_Type *)UARTx)->TER = 0;
;;;302    
;;;303    		// Disable interrupt
;;;304    		((LPC_UART1_Type *)UARTx)->/*DLIER.*/IER = 0;
;;;305    		// Set LCR to default state
;;;306    		((LPC_UART1_Type *)UARTx)->LCR = 0;
;;;307    		// Set ACR to default state
;;;308    		((LPC_UART1_Type *)UARTx)->ACR = 0;
;;;309    		// Set Modem Control to default state
;;;310    		((LPC_UART1_Type *)UARTx)->MCR = 0;
;;;311    		// Set RS485 control to default state
;;;312    		((LPC_UART1_Type *)UARTx)->RS485CTRL = 0;
;;;313    		// Set RS485 delay timer to default state
;;;314    		((LPC_UART1_Type *)UARTx)->RS485DLY = 0;
;;;315    		// Set RS485 addr match to default state
;;;316    		((LPC_UART1_Type *)UARTx)->RS485ADRMATCH = 0;
;;;317    		//Dummy Reading to Clear Status
;;;318    		tmp = ((LPC_UART1_Type *)UARTx)->MSR;
;;;319    		tmp = ((LPC_UART1_Type *)UARTx)->LSR;
;;;320    	}
;;;321    	else
;;;322    	{
;;;323    		/* FIFOs are empty */
;;;324    		UARTx->/*IIFCR.*/FCR = ( UART_FCR_FIFO_EN | UART_FCR_RX_RS | UART_FCR_TX_RS);
;;;325    		// Disable FIFO
;;;326    		UARTx->/*IIFCR.*/FCR = 0;
;;;327    
;;;328    		// Dummy reading
;;;329    		while (UARTx->LSR & UART_LSR_RDR)
;;;330    		{
;;;331    			tmp = UARTx->/*RBTHDLR.*/RBR;
;;;332    		}
;;;333    
;;;334    		UARTx->TER = UART0_2_3_TER_TXEN;
;;;335    		// Wait for current transmit complete
;;;336    		while (!(UARTx->LSR & UART_LSR_THRE));
;;;337    		// Disable Tx
;;;338    		UARTx->TER = 0;
;;;339    
;;;340    		// Disable interrupt
;;;341    		UARTx->/*DLIER.*/IER = 0;
;;;342    		// Set LCR to default state
;;;343    		UARTx->LCR = 0;
;;;344    		// Set ACR to default state
;;;345    		UARTx->ACR = 0;
;;;346    		// set HDEN to default state
;;;347    		UARTx->HDEN = 0;
;;;348    		// set SCICTRL to default state
;;;349    		UARTx->SCICTRL = 0;
;;;350    		// set SYNCCTRL to default state
;;;351    		UARTx->SYNCCTRL =0;
;;;352    		// Set RS485 control to default state
;;;353    		UARTx->RS485CTRL = 0;
;;;354    		// Set RS485 delay timer to default state
;;;355    		UARTx->RS485DLY = 0;
;;;356    		// Set RS485 addr match to default state
;;;357    		UARTx->RS485ADRMATCH = 0;
;;;358    		// Dummy reading
;;;359    		tmp = UARTx->LSR;
;;;360    	}
;;;361    
;;;362    	if (UARTx == LPC_USART3)
;;;363    	{
;;;364    		// Set IrDA to default state
;;;365    		UARTx->ICR = 0;
;;;366    	}
;;;367    
;;;368    	// Set Line Control register ----------------------------
;;;369    
;;;370    	UART_setBaudRate(UARTx, (UART_ConfigStruct->Baud_rate), UART_ConfigStruct->Clock_Speed);
;;;371    
;;;372    	if (((LPC_UART1_Type *)UARTx) == LPC_UART1)
;;;373    	{
;;;374    		tmp = (((LPC_UART1_Type *)UARTx)->LCR & (UART_LCR_DLAB_EN | UART_LCR_BREAK_EN)) \
;;;375    				& UART_LCR_BITMASK;
;;;376    	}
;;;377    	else
;;;378    	{
;;;379    		tmp = (UARTx->LCR & (UART_LCR_DLAB_EN | UART_LCR_BREAK_EN)) & UART_LCR_BITMASK;
;;;380    	}
;;;381    
;;;382    	switch (UART_ConfigStruct->Databits){
;;;383    	case UART_DATABIT_5:
;;;384    		tmp |= UART_LCR_WLEN5;
;;;385    		break;
;;;386    	case UART_DATABIT_6:
;;;387    		tmp |= UART_LCR_WLEN6;
;;;388    		break;
;;;389    	case UART_DATABIT_7:
;;;390    		tmp |= UART_LCR_WLEN7;
;;;391    		break;
;;;392    	case UART_DATABIT_8:
;;;393    	default:
;;;394    		tmp |= UART_LCR_WLEN8;
;;;395    		break;
;;;396    	}
;;;397    
;;;398    	if (UART_ConfigStruct->Parity == UART_PARITY_NONE)
;;;399    	{
;;;400    		// Do nothing...
;;;401    	}
;;;402    	else
;;;403    	{
;;;404    		tmp |= UART_LCR_PARITY_EN;
;;;405    		switch (UART_ConfigStruct->Parity)
;;;406    		{
;;;407    		case UART_PARITY_ODD:
;;;408    			tmp |= UART_LCR_PARITY_ODD;
;;;409    			break;
;;;410    
;;;411    		case UART_PARITY_EVEN:
;;;412    			tmp |= UART_LCR_PARITY_EVEN;
;;;413    			break;
;;;414    
;;;415    		case UART_PARITY_SP_1:
;;;416    			tmp |= UART_LCR_PARITY_F_1;
;;;417    			break;
;;;418    
;;;419    		case UART_PARITY_SP_0:
;;;420    			tmp |= UART_LCR_PARITY_F_0;
;;;421    			break;
;;;422    		default:
;;;423    			break;
;;;424    		}
;;;425    	}
;;;426    
;;;427    	switch (UART_ConfigStruct->Stopbits){
;;;428    	case UART_STOPBIT_2:
;;;429    		tmp |= UART_LCR_STOPBIT_SEL;
;;;430    		break;
;;;431    	case UART_STOPBIT_1:
;;;432    	default:
;;;433    		// Do no thing
;;;434    		break;
;;;435    	}
;;;436    
;;;437    
;;;438    	// Write back to LCR, configure FIFO and Disable Tx
;;;439    	if (((LPC_UART1_Type *)UARTx) ==  LPC_UART1)
;;;440    	{
;;;441    		((LPC_UART1_Type *)UARTx)->LCR = (uint8_t)(tmp & UART_LCR_BITMASK);
;;;442    	}
;;;443    	else
;;;444    	{
;;;445    		UARTx->LCR = (uint8_t)(tmp & UART_LCR_BITMASK);
;;;446    	}
;;;447    #endif
;;;448    }
;;;449    
                          ENDP


                          AREA ||i.UART_IntConfig||, CODE, READONLY, ALIGN=2

                  UART_IntConfig PROC
;;;739     *********************************************************************/
;;;740    void UART_IntConfig(LPC_USARTn_Type *UARTx, UART_INT_Type UARTIntCfg, FunctionalState NewState)
000000  b530              PUSH     {r4,r5,lr}
;;;741    {
000002  460c              MOV      r4,r1
;;;742    	uint32_t tmp = 0;
000004  2100              MOVS     r1,#0
;;;743    
;;;744    	CHECK_PARAM(PARAM_UARTx(UARTx));
;;;745    	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
;;;746    
;;;747    	switch(UARTIntCfg){
000006  0023              MOVS     r3,r4
000008  f7fffffe          BL       __ARM_common_switch8
00000c  07050709          DCB      0x07,0x05,0x07,0x09
000010  0b0d0f12          DCB      0x0b,0x0d,0x0f,0x12
000014  1500              DCB      0x15,0x00
;;;748    		case UART_INTCFG_RBR:
;;;749    			tmp = UART_IER_RBRINT_EN;
000016  2101              MOVS     r1,#1
;;;750    			break;
000018  e00d              B        |L13.54|
;;;751    		case UART_INTCFG_THRE:
;;;752    			tmp = UART_IER_THREINT_EN;
00001a  2102              MOVS     r1,#2
;;;753    			break;
00001c  e00b              B        |L13.54|
;;;754    		case UART_INTCFG_RLS:
;;;755    			tmp = UART_IER_RLSINT_EN;
00001e  2104              MOVS     r1,#4
;;;756    			break;
000020  e009              B        |L13.54|
;;;757    		case UART1_INTCFG_MS:
;;;758    			tmp = UART1_IER_MSINT_EN;
000022  2108              MOVS     r1,#8
;;;759    			break;
000024  e007              B        |L13.54|
;;;760    		case UART1_INTCFG_CTS:
;;;761    			tmp = UART1_IER_CTSINT_EN;
000026  2180              MOVS     r1,#0x80
;;;762    			break;
000028  e005              B        |L13.54|
;;;763    		case UART_INTCFG_ABEO:
;;;764    			tmp = UART_IER_ABEOINT_EN;
00002a  21ff              MOVS     r1,#0xff
00002c  3101              ADDS     r1,#1
;;;765    			break;
00002e  e002              B        |L13.54|
;;;766    		case UART_INTCFG_ABTO:
;;;767    			tmp = UART_IER_ABTOINT_EN;
000030  2101              MOVS     r1,#1
000032  0249              LSLS     r1,r1,#9
;;;768    			break;
000034  bf00              NOP      
                  |L13.54|
000036  bf00              NOP                            ;750
;;;769    	}
;;;770    
;;;771    	if ((LPC_UART1_Type *) UARTx == LPC_UART1)
;;;772    	{
;;;773    		CHECK_PARAM((PARAM_UART_INTCFG(UARTIntCfg)) || (PARAM_UART1_INTCFG(UARTIntCfg)));
;;;774    	}
;;;775    	else
;;;776    	{
;;;777    		CHECK_PARAM(PARAM_UART_INTCFG(UARTIntCfg));
;;;778    	}
;;;779    
;;;780    	if (NewState == ENABLE)
000038  2a01              CMP      r2,#1
00003a  d10a              BNE      |L13.82|
;;;781    	{
;;;782    		if ((LPC_UART1_Type *) UARTx == LPC_UART1)
00003c  4b0d              LDR      r3,|L13.116|
00003e  4298              CMP      r0,r3
000040  d103              BNE      |L13.74|
;;;783    		{
;;;784    			((LPC_UART1_Type *)UARTx)->/*DLIER.*/IER |= tmp;
000042  6843              LDR      r3,[r0,#4]
000044  430b              ORRS     r3,r3,r1
000046  6043              STR      r3,[r0,#4]
000048  e012              B        |L13.112|
                  |L13.74|
;;;785    		}
;;;786    		else
;;;787    		{
;;;788    			UARTx->/*DLIER.*/IER |= tmp;
00004a  6843              LDR      r3,[r0,#4]
00004c  430b              ORRS     r3,r3,r1
00004e  6043              STR      r3,[r0,#4]
000050  e00e              B        |L13.112|
                  |L13.82|
;;;789    		}
;;;790    	}
;;;791    	else
;;;792    	{
;;;793    		if ((LPC_UART1_Type *) UARTx == LPC_UART1)
000052  4b08              LDR      r3,|L13.116|
000054  4298              CMP      r0,r3
000056  d105              BNE      |L13.100|
;;;794    		{
;;;795    			((LPC_UART1_Type *)UARTx)->/*DLIER.*/IER &= (~tmp) & UART1_IER_BITMASK;
000058  6843              LDR      r3,[r0,#4]
00005a  4d07              LDR      r5,|L13.120|
00005c  438d              BICS     r5,r5,r1
00005e  402b              ANDS     r3,r3,r5
000060  6043              STR      r3,[r0,#4]
000062  e005              B        |L13.112|
                  |L13.100|
;;;796    		}
;;;797    		else
;;;798    		{
;;;799    			UARTx->/*DLIER.*/IER &= (~tmp) & UART_IER_BITMASK;
000064  6843              LDR      r3,[r0,#4]
000066  4d04              LDR      r5,|L13.120|
000068  3d88              SUBS     r5,r5,#0x88
00006a  438d              BICS     r5,r5,r1
00006c  402b              ANDS     r3,r3,r5
00006e  6043              STR      r3,[r0,#4]
                  |L13.112|
;;;800    		}
;;;801    	}
;;;802    }
000070  bd30              POP      {r4,r5,pc}
;;;803    
                          ENDP

000072  0000              DCW      0x0000
                  |L13.116|
                          DCD      0x40082000
                  |L13.120|
                          DCD      0x0000038f

                          AREA ||i.UART_RS485Config||, CODE, READONLY, ALIGN=2

                  UART_RS485Config PROC
;;;1257    **********************************************************************/
;;;1258   void UART_RS485Config(LPC_USARTn_Type *UARTx, UART_RS485_CTRLCFG_Type *RS485ConfigStruct)
000000  b510              PUSH     {r4,lr}
;;;1259   {
;;;1260   	uint32_t tmp;
;;;1261   
;;;1262   	CHECK_PARAM(PARAM_FUNCTIONALSTATE(RS485ConfigStruct->AutoAddrDetect_State));
;;;1263   	CHECK_PARAM(PARAM_FUNCTIONALSTATE(RS485ConfigStruct->AutoDirCtrl_State));
;;;1264   	CHECK_PARAM(PARAM_UART_RS485_CFG_DELAYVALUE(RS485ConfigStruct->DelayValue));
;;;1265   	CHECK_PARAM(PARAM_SETSTATE(RS485ConfigStruct->DirCtrlPol_Level));
;;;1266   	CHECK_PARAM(PARAM_UART_RS485_DIRCTRL_PIN(RS485ConfigStruct->DirCtrlPin));
;;;1267   	CHECK_PARAM(PARAM_UART_RS485_CFG_MATCHADDRVALUE(RS485ConfigStruct->MatchAddrValue));
;;;1268   	CHECK_PARAM(PARAM_FUNCTIONALSTATE(RS485ConfigStruct->NormalMultiDropMode_State));
;;;1269   	CHECK_PARAM(PARAM_FUNCTIONALSTATE(RS485ConfigStruct->Rx_State));
;;;1270   
;;;1271   	tmp = 0;
000002  2200              MOVS     r2,#0
;;;1272   	// If Auto Direction Control is enabled -  This function is used in Master mode
;;;1273   	if (RS485ConfigStruct->AutoDirCtrl_State == ENABLE)
000004  78cb              LDRB     r3,[r1,#3]
000006  2b01              CMP      r3,#1
000008  d113              BNE      |L14.50|
;;;1274   	{
;;;1275   		tmp |= UART_RS485CTRL_DCTRL_EN;
00000a  2310              MOVS     r3,#0x10
00000c  431a              ORRS     r2,r2,r3
;;;1276   
;;;1277   		// Set polar
;;;1278   		if (RS485ConfigStruct->DirCtrlPol_Level == SET)
00000e  794b              LDRB     r3,[r1,#5]
000010  2b01              CMP      r3,#1
000012  d101              BNE      |L14.24|
;;;1279   		{
;;;1280   			tmp |= UART_RS485CTRL_OINV_1;
000014  2320              MOVS     r3,#0x20
000016  431a              ORRS     r2,r2,r3
                  |L14.24|
;;;1281   		}
;;;1282   
;;;1283   		// Set pin according to
;;;1284   		if (RS485ConfigStruct->DirCtrlPin == UART_RS485_DIRCTRL_DTR)
000018  790b              LDRB     r3,[r1,#4]
00001a  2b01              CMP      r3,#1
00001c  d101              BNE      |L14.34|
;;;1285   		{
;;;1286   			tmp |= UART_RS485CTRL_SEL_DTR;
00001e  2308              MOVS     r3,#8
000020  431a              ORRS     r2,r2,r3
                  |L14.34|
;;;1287   		}
;;;1288   
;;;1289   		// Fill delay time
;;;1290   		if (((LPC_UART1_Type *)UARTx) == LPC_UART1)
000022  4b1a              LDR      r3,|L14.140|
000024  4298              CMP      r0,r3
000026  d102              BNE      |L14.46|
;;;1291   		{
;;;1292   			((LPC_UART1_Type *)UARTx)->RS485DLY = RS485ConfigStruct->DelayValue & UART_RS485DLY_BITMASK;
000028  79cb              LDRB     r3,[r1,#7]
00002a  6543              STR      r3,[r0,#0x54]
00002c  e001              B        |L14.50|
                  |L14.46|
;;;1293   		}
;;;1294   		else
;;;1295   		{
;;;1296   			UARTx->RS485DLY = RS485ConfigStruct->DelayValue & UART_RS485DLY_BITMASK;
00002e  79cb              LDRB     r3,[r1,#7]
000030  6543              STR      r3,[r0,#0x54]
                  |L14.50|
;;;1297   		}
;;;1298   	}
;;;1299   
;;;1300   	// MultiDrop mode is enable
;;;1301   	if (RS485ConfigStruct->NormalMultiDropMode_State == ENABLE)
000032  780b              LDRB     r3,[r1,#0]
000034  2b01              CMP      r3,#1
000036  d100              BNE      |L14.58|
;;;1302   	{
;;;1303   		tmp |= UART_RS485CTRL_NMM_EN;
000038  431a              ORRS     r2,r2,r3
                  |L14.58|
;;;1304   	}
;;;1305   
;;;1306   	// Auto Address Detect function
;;;1307   	if (RS485ConfigStruct->AutoAddrDetect_State == ENABLE)
00003a  788b              LDRB     r3,[r1,#2]
00003c  2b01              CMP      r3,#1
00003e  d109              BNE      |L14.84|
;;;1308   	{
;;;1309   		tmp |= UART_RS485CTRL_AADEN;
000040  2304              MOVS     r3,#4
000042  431a              ORRS     r2,r2,r3
;;;1310   		// Fill Match Address
;;;1311   		if (((LPC_UART1_Type *)UARTx) == LPC_UART1)
000044  4b11              LDR      r3,|L14.140|
000046  4298              CMP      r0,r3
000048  d102              BNE      |L14.80|
;;;1312   		{
;;;1313   			((LPC_UART1_Type *)UARTx)->RS485ADRMATCH = RS485ConfigStruct->MatchAddrValue & UART_RS485ADRMATCH_BITMASK;
00004a  798b              LDRB     r3,[r1,#6]
00004c  6503              STR      r3,[r0,#0x50]
00004e  e001              B        |L14.84|
                  |L14.80|
;;;1314   		}
;;;1315   		else
;;;1316   		{
;;;1317   			UARTx->RS485ADRMATCH = RS485ConfigStruct->MatchAddrValue & UART_RS485ADRMATCH_BITMASK;
000050  798b              LDRB     r3,[r1,#6]
000052  6503              STR      r3,[r0,#0x50]
                  |L14.84|
;;;1318   		}
;;;1319   	}
;;;1320   
;;;1321   
;;;1322   	// Receiver is disable
;;;1323   	if (RS485ConfigStruct->Rx_State == DISABLE)
000054  784b              LDRB     r3,[r1,#1]
000056  2b00              CMP      r3,#0
000058  d101              BNE      |L14.94|
;;;1324   	{
;;;1325   		tmp |= UART_RS485CTRL_RX_DIS;
00005a  2302              MOVS     r3,#2
00005c  431a              ORRS     r2,r2,r3
                  |L14.94|
;;;1326   	}
;;;1327   
;;;1328   	// write back to RS485 control register
;;;1329   	if (((LPC_UART1_Type *)UARTx) == LPC_UART1)
00005e  4b0b              LDR      r3,|L14.140|
000060  4298              CMP      r0,r3
000062  d103              BNE      |L14.108|
;;;1330   	{
;;;1331   		((LPC_UART1_Type *)UARTx)->RS485CTRL = tmp & UART_RS485CTRL_BITMASK;
000064  0693              LSLS     r3,r2,#26
000066  0e9b              LSRS     r3,r3,#26
000068  64c3              STR      r3,[r0,#0x4c]
00006a  e002              B        |L14.114|
                  |L14.108|
;;;1332   	}
;;;1333   	else
;;;1334   	{
;;;1335   		UARTx->RS485CTRL = tmp & UART_RS485CTRL_BITMASK;
00006c  0693              LSLS     r3,r2,#26
00006e  0e9b              LSRS     r3,r3,#26
000070  64c3              STR      r3,[r0,#0x4c]
                  |L14.114|
;;;1336   	}
;;;1337   
;;;1338   	// Enable Parity function and leave parity in stick '0' parity as default
;;;1339   	if (((LPC_UART1_Type *)UARTx) == LPC_UART1)
000072  4b06              LDR      r3,|L14.140|
000074  4298              CMP      r0,r3
000076  d104              BNE      |L14.130|
;;;1340   	{
;;;1341   		((LPC_UART1_Type *)UARTx)->LCR |= (UART_LCR_PARITY_F_0 | UART_LCR_PARITY_EN);
000078  68c3              LDR      r3,[r0,#0xc]
00007a  2438              MOVS     r4,#0x38
00007c  4323              ORRS     r3,r3,r4
00007e  60c3              STR      r3,[r0,#0xc]
000080  e003              B        |L14.138|
                  |L14.130|
;;;1342   	}
;;;1343   	else
;;;1344   	{
;;;1345   		UARTx->LCR |= (UART_LCR_PARITY_F_0 | UART_LCR_PARITY_EN);
000082  68c3              LDR      r3,[r0,#0xc]
000084  2438              MOVS     r4,#0x38
000086  4323              ORRS     r3,r3,r4
000088  60c3              STR      r3,[r0,#0xc]
                  |L14.138|
;;;1346   	}
;;;1347   }
00008a  bd10              POP      {r4,pc}
;;;1348   
                          ENDP

                  |L14.140|
                          DCD      0x40082000

                          AREA ||i.UART_RS485ReceiverCmd||, CODE, READONLY, ALIGN=2

                  UART_RS485ReceiverCmd PROC
;;;1360    **********************************************************************/
;;;1361   void UART_RS485ReceiverCmd(LPC_USARTn_Type *UARTx, FunctionalState NewState)
000000  4a0d              LDR      r2,|L15.56|
;;;1362   {
;;;1363   	if (((LPC_UART1_Type *)UARTx) == LPC_UART1)
000002  4290              CMP      r0,r2
000004  d10b              BNE      |L15.30|
;;;1364   	{
;;;1365   		if (NewState == ENABLE){
000006  2901              CMP      r1,#1
000008  d104              BNE      |L15.20|
;;;1366   			((LPC_UART1_Type *)UARTx)->RS485CTRL &= ~UART_RS485CTRL_RX_DIS;
00000a  6cc2              LDR      r2,[r0,#0x4c]
00000c  2302              MOVS     r3,#2
00000e  439a              BICS     r2,r2,r3
000010  64c2              STR      r2,[r0,#0x4c]
000012  e00f              B        |L15.52|
                  |L15.20|
;;;1367   		} else {
;;;1368   			((LPC_UART1_Type *)UARTx)->RS485CTRL |= UART_RS485CTRL_RX_DIS;
000014  6cc2              LDR      r2,[r0,#0x4c]
000016  2302              MOVS     r3,#2
000018  431a              ORRS     r2,r2,r3
00001a  64c2              STR      r2,[r0,#0x4c]
00001c  e00a              B        |L15.52|
                  |L15.30|
;;;1369   		}
;;;1370   	}
;;;1371   	else
;;;1372   	{
;;;1373   		if (NewState == ENABLE){
00001e  2901              CMP      r1,#1
000020  d104              BNE      |L15.44|
;;;1374   			UARTx->RS485CTRL &= ~UART_RS485CTRL_RX_DIS;
000022  6cc2              LDR      r2,[r0,#0x4c]
000024  2302              MOVS     r3,#2
000026  439a              BICS     r2,r2,r3
000028  64c2              STR      r2,[r0,#0x4c]
00002a  e003              B        |L15.52|
                  |L15.44|
;;;1375   		} else {
;;;1376   			UARTx->RS485CTRL |= UART_RS485CTRL_RX_DIS;
00002c  6cc2              LDR      r2,[r0,#0x4c]
00002e  2302              MOVS     r3,#2
000030  431a              ORRS     r2,r2,r3
000032  64c2              STR      r2,[r0,#0x4c]
                  |L15.52|
;;;1377   		}
;;;1378   	}
;;;1379   }
000034  4770              BX       lr
;;;1380   
                          ENDP

000036  0000              DCW      0x0000
                  |L15.56|
                          DCD      0x40082000

                          AREA ||i.UART_RS485Send||, CODE, READONLY, ALIGN=2

                  UART_RS485Send PROC
;;;1392    **********************************************************************/
;;;1393   uint32_t UART_RS485Send(LPC_USARTn_Type *UARTx, uint8_t *pDatFrm, \
000000  b5ff              PUSH     {r0-r7,lr}
;;;1394   					uint32_t size, uint8_t ParityStick)
;;;1395   {
000002  4604              MOV      r4,r0
;;;1396   	uint8_t tmp, save;
;;;1397   	uint32_t cnt;
;;;1398   	if (((LPC_UART1_Type *)UARTx) == LPC_UART1)
000004  482a              LDR      r0,|L16.176|
000006  4284              CMP      r4,r0
000008  d127              BNE      |L16.90|
;;;1399   	{
;;;1400   		if (ParityStick){
00000a  9803              LDR      r0,[sp,#0xc]
00000c  2800              CMP      r0,#0
00000e  d016              BEQ      |L16.62|
;;;1401   			save = tmp = ((LPC_UART1_Type *)UARTx)->LCR & UART_LCR_BITMASK;
000010  68e0              LDR      r0,[r4,#0xc]
000012  b2c5              UXTB     r5,r0
000014  462f              MOV      r7,r5
;;;1402   			tmp &= ~(UART_LCR_PARITY_EVEN);
000016  2110              MOVS     r1,#0x10
000018  4638              MOV      r0,r7
00001a  4388              BICS     r0,r0,r1
00001c  4607              MOV      r7,r0
;;;1403   			((LPC_UART1_Type *)UARTx)->LCR = tmp;
00001e  60e7              STR      r7,[r4,#0xc]
;;;1404   			cnt = UART_Send((LPC_USARTn_Type *)UARTx, pDatFrm, size, BLOCKING);
000020  2301              MOVS     r3,#1
000022  4620              MOV      r0,r4
000024  9a02              LDR      r2,[sp,#8]
000026  9901              LDR      r1,[sp,#4]
000028  f7fffffe          BL       UART_Send
00002c  4606              MOV      r6,r0
;;;1405   			while (!(((LPC_UART1_Type *)UARTx)->LSR & UART_LSR_TEMT));
00002e  bf00              NOP      
                  |L16.48|
000030  6960              LDR      r0,[r4,#0x14]
000032  2140              MOVS     r1,#0x40
000034  4008              ANDS     r0,r0,r1
000036  2800              CMP      r0,#0
000038  d0fa              BEQ      |L16.48|
;;;1406   			((LPC_UART1_Type *)UARTx)->LCR = save;
00003a  60e5              STR      r5,[r4,#0xc]
00003c  e034              B        |L16.168|
                  |L16.62|
;;;1407   		} else {
;;;1408   			cnt = UART_Send((LPC_USARTn_Type *)UARTx, pDatFrm, size, BLOCKING);
00003e  2301              MOVS     r3,#1
000040  4620              MOV      r0,r4
000042  9a02              LDR      r2,[sp,#8]
000044  9901              LDR      r1,[sp,#4]
000046  f7fffffe          BL       UART_Send
00004a  4606              MOV      r6,r0
;;;1409   			while (!(((LPC_UART1_Type *)UARTx)->LSR & UART_LSR_TEMT));
00004c  bf00              NOP      
                  |L16.78|
00004e  6960              LDR      r0,[r4,#0x14]
000050  2140              MOVS     r1,#0x40
000052  4008              ANDS     r0,r0,r1
000054  2800              CMP      r0,#0
000056  d0fa              BEQ      |L16.78|
000058  e026              B        |L16.168|
                  |L16.90|
;;;1410   		}
;;;1411   	}
;;;1412   	else
;;;1413   	{
;;;1414   		if (ParityStick){
00005a  9803              LDR      r0,[sp,#0xc]
00005c  2800              CMP      r0,#0
00005e  d016              BEQ      |L16.142|
;;;1415   			save = tmp = UARTx->LCR & UART_LCR_BITMASK;
000060  68e0              LDR      r0,[r4,#0xc]
000062  b2c5              UXTB     r5,r0
000064  462f              MOV      r7,r5
;;;1416   			tmp &= ~(UART_LCR_PARITY_EVEN);
000066  2110              MOVS     r1,#0x10
000068  4638              MOV      r0,r7
00006a  4388              BICS     r0,r0,r1
00006c  4607              MOV      r7,r0
;;;1417   			UARTx->LCR = tmp;
00006e  60e7              STR      r7,[r4,#0xc]
;;;1418   			cnt = UART_Send((LPC_USARTn_Type *)UARTx, pDatFrm, size, BLOCKING);
000070  2301              MOVS     r3,#1
000072  4620              MOV      r0,r4
000074  9a02              LDR      r2,[sp,#8]
000076  9901              LDR      r1,[sp,#4]
000078  f7fffffe          BL       UART_Send
00007c  4606              MOV      r6,r0
;;;1419   			while (!(UARTx->LSR & UART_LSR_TEMT));
00007e  bf00              NOP      
                  |L16.128|
000080  6960              LDR      r0,[r4,#0x14]
000082  2140              MOVS     r1,#0x40
000084  4008              ANDS     r0,r0,r1
000086  2800              CMP      r0,#0
000088  d0fa              BEQ      |L16.128|
;;;1420   			UARTx->LCR = save;
00008a  60e5              STR      r5,[r4,#0xc]
00008c  e00c              B        |L16.168|
                  |L16.142|
;;;1421   		} else {
;;;1422   			cnt = UART_Send((LPC_USARTn_Type *)UARTx, pDatFrm, size, BLOCKING);
00008e  2301              MOVS     r3,#1
000090  4620              MOV      r0,r4
000092  9a02              LDR      r2,[sp,#8]
000094  9901              LDR      r1,[sp,#4]
000096  f7fffffe          BL       UART_Send
00009a  4606              MOV      r6,r0
;;;1423   			while (!(UARTx->LSR & UART_LSR_TEMT));
00009c  bf00              NOP      
                  |L16.158|
00009e  6960              LDR      r0,[r4,#0x14]
0000a0  2140              MOVS     r1,#0x40
0000a2  4008              ANDS     r0,r0,r1
0000a4  2800              CMP      r0,#0
0000a6  d0fa              BEQ      |L16.158|
                  |L16.168|
;;;1424   		}
;;;1425   	}
;;;1426   	return cnt;
0000a8  4630              MOV      r0,r6
;;;1427   }
0000aa  b004              ADD      sp,sp,#0x10
0000ac  bdf0              POP      {r4-r7,pc}
;;;1428   
                          ENDP

0000ae  0000              DCW      0x0000
                  |L16.176|
                          DCD      0x40082000

                          AREA ||i.UART_RS485SendData||, CODE, READONLY, ALIGN=1

                  UART_RS485SendData PROC
;;;1454    **********************************************************************/
;;;1455   uint32_t UART_RS485SendData(LPC_USARTn_Type *UARTx, uint8_t *pData, uint32_t size)
000000  b570              PUSH     {r4-r6,lr}
;;;1456   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;1457   	return (UART_RS485Send(UARTx, pData, size, 0));
000008  2300              MOVS     r3,#0
00000a  4632              MOV      r2,r6
00000c  4629              MOV      r1,r5
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       UART_RS485Send
;;;1458   }
000014  bd70              POP      {r4-r6,pc}
;;;1459   
                          ENDP


                          AREA ||i.UART_RS485SendSlvAddr||, CODE, READONLY, ALIGN=1

                  UART_RS485SendSlvAddr PROC
;;;1438    **********************************************************************/
;;;1439   void UART_RS485SendSlvAddr(LPC_USARTn_Type *UARTx, uint8_t SlvAddr)
000000  b513              PUSH     {r0,r1,r4,lr}
;;;1440   {
000002  4604              MOV      r4,r0
;;;1441   	UART_RS485Send(UARTx, &SlvAddr, 1, 1);
000004  2301              MOVS     r3,#1
000006  461a              MOV      r2,r3
000008  a901              ADD      r1,sp,#4
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       UART_RS485Send
;;;1442   }
000010  bd1c              POP      {r2-r4,pc}
;;;1443   
                          ENDP


                          AREA ||i.UART_Receive||, CODE, READONLY, ALIGN=1

                  UART_Receive PROC
;;;651     **********************************************************************/
;;;652    uint32_t UART_Receive(LPC_USARTn_Type *UARTx, uint8_t *rxbuf, \
000000  b5ff              PUSH     {r0-r7,lr}
;;;653    		uint32_t buflen, TRANSFER_BLOCK_Type flag)
;;;654    {
000002  4605              MOV      r5,r0
000004  4616              MOV      r6,r2
;;;655    	uint32_t bToRecv, bRecv, timeOut;
;;;656    	uint8_t *pChar = rxbuf;
000006  9c01              LDR      r4,[sp,#4]
;;;657    
;;;658    	bToRecv = buflen;
000008  4633              MOV      r3,r6
;;;659    
;;;660    	// Blocking mode
;;;661    	if (flag == BLOCKING) {
00000a  9803              LDR      r0,[sp,#0xc]
00000c  2801              CMP      r0,#1
00000e  d11b              BNE      |L19.72|
;;;662    		bRecv = 0;
000010  2200              MOVS     r2,#0
;;;663    		while (bToRecv){
000012  e016              B        |L19.66|
                  |L19.20|
;;;664    			timeOut = UART_BLOCKING_TIMEOUT;
000014  2700              MOVS     r7,#0
000016  43ff              MVNS     r7,r7
;;;665    			while (!(UARTx->LSR & UART_LSR_RDR)){
000018  e003              B        |L19.34|
                  |L19.26|
;;;666    				if (timeOut == 0) break;
00001a  2f00              CMP      r7,#0
00001c  d100              BNE      |L19.32|
00001e  e005              B        |L19.44|
                  |L19.32|
;;;667    				timeOut--;
000020  1e7f              SUBS     r7,r7,#1
                  |L19.34|
000022  6968              LDR      r0,[r5,#0x14]         ;665
000024  07c0              LSLS     r0,r0,#31             ;665
000026  0fc0              LSRS     r0,r0,#31             ;665
000028  2800              CMP      r0,#0                 ;665
00002a  d0f6              BEQ      |L19.26|
                  |L19.44|
00002c  bf00              NOP                            ;666
;;;668    			}
;;;669    			// Time out!
;;;670    			if(timeOut == 0) break;
00002e  2f00              CMP      r7,#0
000030  d100              BNE      |L19.52|
000032  e008              B        |L19.70|
                  |L19.52|
;;;671    			// Get data from the buffer
;;;672    			(*pChar++) = UART_ReceiveByte(UARTx);
000034  4628              MOV      r0,r5
000036  f7fffffe          BL       UART_ReceiveByte
00003a  7020              STRB     r0,[r4,#0]
00003c  1c64              ADDS     r4,r4,#1
;;;673    			bToRecv--;
00003e  1e5b              SUBS     r3,r3,#1
;;;674    			bRecv++;
000040  1c52              ADDS     r2,r2,#1
                  |L19.66|
000042  2b00              CMP      r3,#0                 ;663
000044  d1e6              BNE      |L19.20|
                  |L19.70|
000046  e011              B        |L19.108|
                  |L19.72|
;;;675    		}
;;;676    	}
;;;677    	// None blocking mode
;;;678    	else {
;;;679    		bRecv = 0;
000048  2200              MOVS     r2,#0
;;;680    		while (bToRecv) {
00004a  e00c              B        |L19.102|
                  |L19.76|
;;;681    			if (!(UARTx->LSR & UART_LSR_RDR)) {
00004c  6968              LDR      r0,[r5,#0x14]
00004e  07c0              LSLS     r0,r0,#31
000050  0fc0              LSRS     r0,r0,#31
000052  2800              CMP      r0,#0
000054  d100              BNE      |L19.88|
;;;682    				break;
000056  e008              B        |L19.106|
                  |L19.88|
;;;683    			} else {
;;;684    				(*pChar++) = UART_ReceiveByte(UARTx);
000058  4628              MOV      r0,r5
00005a  f7fffffe          BL       UART_ReceiveByte
00005e  7020              STRB     r0,[r4,#0]
000060  1c64              ADDS     r4,r4,#1
;;;685    				bRecv++;
000062  1c52              ADDS     r2,r2,#1
;;;686    				bToRecv--;
000064  1e5b              SUBS     r3,r3,#1
                  |L19.102|
000066  2b00              CMP      r3,#0                 ;680
000068  d1f0              BNE      |L19.76|
                  |L19.106|
00006a  bf00              NOP                            ;682
                  |L19.108|
;;;687    			}
;;;688    		}
;;;689    	}
;;;690    	return bRecv;
00006c  4610              MOV      r0,r2
;;;691    }
00006e  b004              ADD      sp,sp,#0x10
000070  bdf0              POP      {r4-r7,pc}
;;;692    
                          ENDP


                          AREA ||i.UART_ReceiveByte||, CODE, READONLY, ALIGN=2

                  UART_ReceiveByte PROC
;;;554     **********************************************************************/
;;;555    uint8_t UART_ReceiveByte(LPC_USARTn_Type* UARTx)
000000  4601              MOV      r1,r0
;;;556    {
;;;557    	CHECK_PARAM(PARAM_UARTx(UARTx));
;;;558    
;;;559    	if (((LPC_UART1_Type *)UARTx) == LPC_UART1)
000002  4804              LDR      r0,|L20.20|
000004  4281              CMP      r1,r0
000006  d102              BNE      |L20.14|
;;;560    	{
;;;561    		return (((LPC_UART1_Type *)UARTx)->/*RBTHDLR.*/RBR & UART_RBR_MASKBIT);
000008  6808              LDR      r0,[r1,#0]
00000a  b2c0              UXTB     r0,r0
                  |L20.12|
;;;562    	}
;;;563    	else
;;;564    	{
;;;565    		return (UARTx->/*RBTHDLR.*/RBR & UART_RBR_MASKBIT);
;;;566    	}
;;;567    }
00000c  4770              BX       lr
                  |L20.14|
00000e  6808              LDR      r0,[r1,#0]            ;565
000010  b2c0              UXTB     r0,r0                 ;565
000012  e7fb              B        |L20.12|
;;;568    
                          ENDP

                  |L20.20|
                          DCD      0x40082000

                          AREA ||i.UART_Send||, CODE, READONLY, ALIGN=1

                  UART_Send PROC
;;;585     **********************************************************************/
;;;586    uint32_t UART_Send(LPC_USARTn_Type *UARTx, uint8_t *txbuf,
000000  b5ff              PUSH     {r0-r7,lr}
;;;587    		uint32_t buflen, TRANSFER_BLOCK_Type flag)
;;;588    {
;;;589    	uint32_t bToSend, bSent, timeOut, fifo_cnt;
;;;590    	uint8_t *pChar = txbuf;
000002  9e01              LDR      r6,[sp,#4]
;;;591    
;;;592    	bToSend = buflen;
000004  9b02              LDR      r3,[sp,#8]
;;;593    
;;;594    	// blocking mode
;;;595    	if (flag == BLOCKING) {
000006  9803              LDR      r0,[sp,#0xc]
000008  2801              CMP      r0,#1
00000a  d123              BNE      |L21.84|
;;;596    		bSent = 0;
00000c  2400              MOVS     r4,#0
;;;597    		while (bToSend){
00000e  e01e              B        |L21.78|
                  |L21.16|
;;;598    			timeOut = UART_BLOCKING_TIMEOUT;
000010  2700              MOVS     r7,#0
000012  43ff              MVNS     r7,r7
;;;599    			// Wait for THR empty with timeout
;;;600    			while (!(UARTx->LSR & UART_LSR_THRE)) {
000014  e003              B        |L21.30|
                  |L21.22|
;;;601    				if (timeOut == 0) break;
000016  2f00              CMP      r7,#0
000018  d100              BNE      |L21.28|
00001a  e006              B        |L21.42|
                  |L21.28|
;;;602    				timeOut--;
00001c  1e7f              SUBS     r7,r7,#1
                  |L21.30|
00001e  9800              LDR      r0,[sp,#0]            ;600
000020  6940              LDR      r0,[r0,#0x14]         ;600
000022  2120              MOVS     r1,#0x20              ;600
000024  4008              ANDS     r0,r0,r1              ;600
000026  2800              CMP      r0,#0                 ;600
000028  d0f5              BEQ      |L21.22|
                  |L21.42|
00002a  bf00              NOP                            ;601
;;;603    			}
;;;604    			// Time out!
;;;605    			if(timeOut == 0) break;
00002c  2f00              CMP      r7,#0
00002e  d100              BNE      |L21.50|
000030  e00f              B        |L21.82|
                  |L21.50|
;;;606    			fifo_cnt = UART_TX_FIFO_SIZE;
000032  2510              MOVS     r5,#0x10
;;;607    			while (fifo_cnt && bToSend){
000034  e007              B        |L21.70|
                  |L21.54|
;;;608    				UART_SendByte(UARTx, (*pChar++));
000036  7831              LDRB     r1,[r6,#0]
000038  1c76              ADDS     r6,r6,#1
00003a  9800              LDR      r0,[sp,#0]
00003c  f7fffffe          BL       UART_SendByte
;;;609    				fifo_cnt--;
000040  1e6d              SUBS     r5,r5,#1
;;;610    				bToSend--;
000042  1e5b              SUBS     r3,r3,#1
;;;611    				bSent++;
000044  1c64              ADDS     r4,r4,#1
                  |L21.70|
000046  2d00              CMP      r5,#0                 ;607
000048  d001              BEQ      |L21.78|
00004a  2b00              CMP      r3,#0                 ;607
00004c  d1f3              BNE      |L21.54|
                  |L21.78|
00004e  2b00              CMP      r3,#0                 ;597
000050  d1de              BNE      |L21.16|
                  |L21.82|
000052  e019              B        |L21.136|
                  |L21.84|
;;;612    			}
;;;613    		}
;;;614    	}
;;;615    	// None blocking mode
;;;616    	else {
;;;617    		bSent = 0;
000054  2400              MOVS     r4,#0
;;;618    		while (bToSend) {
000056  e014              B        |L21.130|
                  |L21.88|
;;;619    			if (!(UARTx->LSR & UART_LSR_THRE)){
000058  9800              LDR      r0,[sp,#0]
00005a  6940              LDR      r0,[r0,#0x14]
00005c  2120              MOVS     r1,#0x20
00005e  4008              ANDS     r0,r0,r1
000060  2800              CMP      r0,#0
000062  d100              BNE      |L21.102|
;;;620    				break;
000064  e00f              B        |L21.134|
                  |L21.102|
;;;621    			}
;;;622    			fifo_cnt = UART_TX_FIFO_SIZE;
000066  2510              MOVS     r5,#0x10
;;;623    			while (fifo_cnt && bToSend) {
000068  e007              B        |L21.122|
                  |L21.106|
;;;624    				UART_SendByte(UARTx, (*pChar++));
00006a  7831              LDRB     r1,[r6,#0]
00006c  1c76              ADDS     r6,r6,#1
00006e  9800              LDR      r0,[sp,#0]
000070  f7fffffe          BL       UART_SendByte
;;;625    				bToSend--;
000074  1e5b              SUBS     r3,r3,#1
;;;626    				fifo_cnt--;
000076  1e6d              SUBS     r5,r5,#1
;;;627    				bSent++;
000078  1c64              ADDS     r4,r4,#1
                  |L21.122|
00007a  2d00              CMP      r5,#0                 ;623
00007c  d001              BEQ      |L21.130|
00007e  2b00              CMP      r3,#0                 ;623
000080  d1f3              BNE      |L21.106|
                  |L21.130|
000082  2b00              CMP      r3,#0                 ;618
000084  d1e8              BNE      |L21.88|
                  |L21.134|
000086  bf00              NOP                            ;620
                  |L21.136|
;;;628    			}
;;;629    		}
;;;630    	}
;;;631    	return bSent;
000088  4620              MOV      r0,r4
;;;632    }
00008a  b004              ADD      sp,sp,#0x10
00008c  bdf0              POP      {r4-r7,pc}
;;;633    
                          ENDP


                          AREA ||i.UART_SendByte||, CODE, READONLY, ALIGN=2

                  UART_SendByte PROC
;;;529     **********************************************************************/
;;;530    void UART_SendByte(LPC_USARTn_Type* UARTx, uint8_t Data)
000000  4a04              LDR      r2,|L22.20|
;;;531    {
;;;532    	CHECK_PARAM(PARAM_UARTx(UARTx));
;;;533    
;;;534    	if (((LPC_UART1_Type *)UARTx) == LPC_UART1)
000002  4290              CMP      r0,r2
000004  d102              BNE      |L22.12|
;;;535    	{
;;;536    		((LPC_UART1_Type *)UARTx)->/*RBTHDLR.*/THR = Data & UART_THR_MASKBIT;
000006  b2ca              UXTB     r2,r1
000008  6002              STR      r2,[r0,#0]
00000a  e001              B        |L22.16|
                  |L22.12|
;;;537    	}
;;;538    	else
;;;539    	{
;;;540    		UARTx->/*RBTHDLR.*/THR = Data & UART_THR_MASKBIT;
00000c  b2ca              UXTB     r2,r1
00000e  6002              STR      r2,[r0,#0]
                  |L22.16|
;;;541    	}
;;;542    
;;;543    }
000010  4770              BX       lr
;;;544    
                          ENDP

000012  0000              DCW      0x0000
                  |L22.20|
                          DCD      0x40082000

                          AREA ||i.UART_TxCmd||, CODE, READONLY, ALIGN=2

                  UART_TxCmd PROC
;;;1022    **********************************************************************/
;;;1023   void UART_TxCmd(LPC_USARTn_Type *UARTx, FunctionalState NewState)
000000  2901              CMP      r1,#1
;;;1024   {
;;;1025   	CHECK_PARAM(PARAM_UARTx(UARTx));
;;;1026   	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
;;;1027   
;;;1028   	if (NewState == ENABLE)
000002  d10c              BNE      |L23.30|
;;;1029   	{
;;;1030   		if (((LPC_UART1_Type *)UARTx) == LPC_UART1)
000004  4a0b              LDR      r2,|L23.52|
000006  4290              CMP      r0,r2
000008  d104              BNE      |L23.20|
;;;1031   		{
;;;1032   			((LPC_UART1_Type *)UARTx)->TER |= UART1_TER_TXEN;
00000a  6b02              LDR      r2,[r0,#0x30]
00000c  2380              MOVS     r3,#0x80
00000e  431a              ORRS     r2,r2,r3
000010  6302              STR      r2,[r0,#0x30]
000012  e00e              B        |L23.50|
                  |L23.20|
;;;1033   		}
;;;1034   		else
;;;1035   		{
;;;1036   			UARTx->TER |= UART0_2_3_TER_TXEN;
000014  6dc2              LDR      r2,[r0,#0x5c]
000016  2301              MOVS     r3,#1
000018  431a              ORRS     r2,r2,r3
00001a  65c2              STR      r2,[r0,#0x5c]
00001c  e009              B        |L23.50|
                  |L23.30|
;;;1037   		}
;;;1038   	}
;;;1039   	else
;;;1040   	{
;;;1041   		if (((LPC_UART1_Type *)UARTx) == LPC_UART1)
00001e  4a05              LDR      r2,|L23.52|
000020  4290              CMP      r0,r2
000022  d103              BNE      |L23.44|
;;;1042   		{
;;;1043   			((LPC_UART1_Type *)UARTx)->TER &= (~UART1_TER_TXEN) & UART1_TER_BITMASK;
000024  6b02              LDR      r2,[r0,#0x30]
000026  2200              MOVS     r2,#0
000028  6302              STR      r2,[r0,#0x30]
00002a  e002              B        |L23.50|
                  |L23.44|
;;;1044   		}
;;;1045   		else
;;;1046   		{
;;;1047   			UARTx->TER &= (~UART0_2_3_TER_TXEN) & UART0_2_3_TER_BITMASK;
00002c  6dc2              LDR      r2,[r0,#0x5c]
00002e  2200              MOVS     r2,#0
000030  65c2              STR      r2,[r0,#0x5c]
                  |L23.50|
;;;1048   		}
;;;1049   	}
;;;1050   }
000032  4770              BX       lr
;;;1051   
                          ENDP

                  |L23.52|
                          DCD      0x40082000

                          AREA ||i.UART_setBaudRate||, CODE, READONLY, ALIGN=1

                  UART_setBaudRate PROC
;;;76      **********************************************************************/
;;;77     Status UART_setBaudRate(LPC_USARTn_Type *UARTx, uint32_t baudrate, uint32_t clockspeed)
000000  4603              MOV      r3,r0
;;;78     {
;;;79     #ifndef CORE_M0 // rich: let's assume M0 doesn't do any initialization 
;;;80     
;;;81     	Status errorStatus = ERROR;
;;;82     
;;;83     	uint32_t uClk = clockspeed;
;;;84     	uint32_t d, m, bestd, bestm, tmp;
;;;85     	uint64_t best_divisor, divisor;
;;;86     	uint32_t current_error, best_error;
;;;87     	uint32_t recalcbaud;
;;;88     
;;;89     	/* get UART block clock */
;;;90     	//to be defined uClk = CGU_GetCLK(CGU_CLKTYPE_PER);
;;;91     #ifdef _UART0
;;;92     	if(UARTx == LPC_USART0)
;;;93     	{
;;;94     		if(clockspeed)
;;;95     			uClk = clockspeed;
;;;96     		else
;;;97     			uClk = CGU_GetPCLKFrequency(CGU_PERIPHERAL_UART0);
;;;98     	}
;;;99     #endif
;;;100    
;;;101    #ifdef _UART1
;;;102    	if(((LPC_UART1_Type *)UARTx) == LPC_UART1)
;;;103    	{
;;;104    		if(clockspeed)
;;;105    			uClk = clockspeed;
;;;106    		else
;;;107    			uClk = CGU_GetPCLKFrequency(CGU_PERIPHERAL_UART1);
;;;108    	}
;;;109    #endif
;;;110    
;;;111    #ifdef _UART2
;;;112    	if(UARTx == LPC_USART2)
;;;113    	{
;;;114    		if(clockspeed)
;;;115    			uClk = clockspeed;
;;;116    		else
;;;117    			uClk = CGU_GetPCLKFrequency(CGU_PERIPHERAL_UART2);
;;;118    	}
;;;119    #endif
;;;120    
;;;121    #ifdef _UART3
;;;122    	if(UARTx == LPC_USART3)
;;;123    	{
;;;124    		if(clockspeed)
;;;125    			uClk = clockspeed;
;;;126    		else
;;;127    			uClk = CGU_GetPCLKFrequency(CGU_PERIPHERAL_UART3);
;;;128    	}
;;;129    #endif
;;;130    
;;;131    	/* In the Uart IP block, baud rate is calculated using FDR and DLL-DLM registers
;;;132    	* The formula is :
;;;133    	* BaudRate= uClk * (mulFracDiv/(mulFracDiv+dividerAddFracDiv) / (16 * (DLL)
;;;134    	* It involves floating point calculations. That's the reason the formulae are adjusted with
;;;135    	* Multiply and divide method.*/
;;;136    	/* The value of mulFracDiv and dividerAddFracDiv should comply to the following expressions:
;;;137    	* 0 < mulFracDiv <= 15, 0 <= dividerAddFracDiv <= 15 */
;;;138    	best_error = 0xFFFFFFFF; /* Worst case */
;;;139    	bestd = 0;
;;;140    	bestm = 0;
;;;141    	best_divisor = 0;
;;;142    	for (m = 1 ; m <= 15 ;m++)
;;;143    	{
;;;144    		for (d = 0 ; d < m ; d++)
;;;145    		{
;;;146    		  divisor = ((uint64_t)uClk<<28)*m/(baudrate*(m+d));
;;;147    		  current_error = divisor & 0xFFFFFFFF;
;;;148    
;;;149    		  tmp = divisor>>32;
;;;150    
;;;151    		  /* Adjust error */
;;;152    		  if(current_error > ((uint32_t)1<<31)){
;;;153    		  	current_error = -current_error;
;;;154    			tmp++;
;;;155    			}
;;;156    
;;;157    		  if(tmp<1 || tmp>65536) /* Out of range */
;;;158    		  continue;
;;;159    
;;;160    		  if( current_error < best_error){
;;;161    		  	best_error = current_error;
;;;162    			best_divisor = tmp;
;;;163    			bestd = d;
;;;164    			bestm = m;
;;;165    			if(best_error == 0) break;
;;;166    			}
;;;167    		} /* end of inner for loop */
;;;168    
;;;169    		if (best_error == 0)
;;;170    		  break;
;;;171    	} /* end of outer for loop  */
;;;172    
;;;173    	if(best_divisor == 0) return ERROR; /* can not find best match */
;;;174    
;;;175    	recalcbaud = (uClk>>4) * bestm/(best_divisor * (bestm + bestd));
;;;176    
;;;177    	/* reuse best_error to evaluate baud error*/
;;;178    	if(baudrate>recalcbaud) best_error = baudrate - recalcbaud;
;;;179    	else best_error = recalcbaud -baudrate;
;;;180    
;;;181    	best_error = best_error * 100 / baudrate;
;;;182    
;;;183    	if (best_error < UART_ACCEPTED_BAUDRATE_ERROR)
;;;184    	{
;;;185    		if (((LPC_UART1_Type *)UARTx) == LPC_UART1)
;;;186    		{
;;;187    			((LPC_UART1_Type *)UARTx)->LCR |= UART_LCR_DLAB_EN;
;;;188    			((LPC_UART1_Type *)UARTx)->/*DLIER.*/DLM = UART_LOAD_DLM(best_divisor);
;;;189    			((LPC_UART1_Type *)UARTx)->/*RBTHDLR.*/DLL = UART_LOAD_DLL(best_divisor);
;;;190    			/* Then reset DLAB bit */
;;;191    			((LPC_UART1_Type *)UARTx)->LCR &= (~UART_LCR_DLAB_EN) & UART_LCR_BITMASK;
;;;192    			((LPC_UART1_Type *)UARTx)->FDR = (UART_FDR_MULVAL(bestm) \
;;;193    					| UART_FDR_DIVADDVAL(bestd)) & UART_FDR_BITMASK;
;;;194    		}
;;;195    		else
;;;196    		{
;;;197    			UARTx->LCR |= UART_LCR_DLAB_EN;
;;;198    			UARTx->/*DLIER.*/DLM = UART_LOAD_DLM(best_divisor);
;;;199    			UARTx->/*RBTHDLR.*/DLL = UART_LOAD_DLL(best_divisor);
;;;200    			/* Then reset DLAB bit */
;;;201    			UARTx->LCR &= (~UART_LCR_DLAB_EN) & UART_LCR_BITMASK;
;;;202    			UARTx->FDR = (UART_FDR_MULVAL(bestm) \
;;;203    					| UART_FDR_DIVADDVAL(bestd)) & UART_FDR_BITMASK;
;;;204    		}
;;;205    		errorStatus = SUCCESS;
;;;206    	}
;;;207    
;;;208    	return errorStatus;
;;;209    #else
;;;210    	return SUCCESS;
000002  2001              MOVS     r0,#1
;;;211    #endif
;;;212    }
000004  4770              BX       lr
;;;213    
                          ENDP


                          AREA ||i.__ARM_common_switch8||, COMGROUP=__ARM_common_switch8, CODE, READONLY, ALIGN=1

                  __ARM_common_switch8 PROC
000000  b430              PUSH     {r4,r5}
000002  4674              MOV      r4,lr
000004  1e64              SUBS     r4,r4,#1
000006  7825              LDRB     r5,[r4,#0]
000008  1c64              ADDS     r4,r4,#1
00000a  42ab              CMP      r3,r5
00000c  d304              BCC      |L151.24|
                  |L151.14|
00000e  5d63              LDRB     r3,[r4,r5]
000010  005b              LSLS     r3,r3,#1
000012  18e3              ADDS     r3,r4,r3
000014  bc30              POP      {r4,r5}
000016  4718              BX       r3
                  |L151.24|
000018  461d              MOV      r5,r3
00001a  e7f8              B        |L151.14|
                          ENDP


;*** Start embedded assembler ***

#line 1 "lpc43xx_uart.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___14_lpc43xx_uart_c_befd8022____REV16|
#line 130 ".\\core_cmInstr.h"
|__asm___14_lpc43xx_uart_c_befd8022____REV16| PROC
#line 131

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___14_lpc43xx_uart_c_befd8022____REVSH|
#line 144
|__asm___14_lpc43xx_uart_c_befd8022____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
