; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\usbuser.o --asm_dir=.\ --list_dir=.\ --depend=.\usbuser.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I. -I..\..\common -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=514 -DCORE_M4 -DIPC_MASTER -DPIXY --omf_browse=.\usbuser.crf usbuser.c]
                          THUMB

                          AREA ||i.USB_Configure_Event||, CODE, READONLY, ALIGN=1

                  USB_Configure_Event PROC
;;;135    #if USB_CONFIGURE_EVENT
;;;136    void USB_Configure_Event (void) {
000000  4770              BX       lr
;;;137    
;;;138      if (USB_Configuration) {                  /* Check if USB is configured */
;;;139        /* add your code here */
;;;140      }
;;;141    }
;;;142    #endif
                          ENDP


                          AREA ||i.USB_EndPoint1||, CODE, READONLY, ALIGN=1

                  USB_EndPoint1 PROC
;;;185    
;;;186    void USB_EndPoint1 (uint32_t event) {
000000  2803              CMP      r0,#3
;;;187      switch (event) {
000002  d100              BNE      |L2.6|
;;;188        case USB_EVT_IN:
;;;189          break;
000004  bf00              NOP      
                  |L2.6|
000006  bf00              NOP      
;;;190      }
;;;191    }
000008  4770              BX       lr
;;;192    
                          ENDP


                          AREA ||i.USB_EndPoint2||, CODE, READONLY, ALIGN=1

                  USB_EndPoint2 PROC
;;;215    
;;;216    void USB_EndPoint2 (uint32_t event) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;217    
;;;218      switch (event) {
000004  2c02              CMP      r4,#2
000006  d002              BEQ      |L3.14|
000008  2c03              CMP      r4,#3
00000a  d106              BNE      |L3.26|
00000c  e002              B        |L3.20|
                  |L3.14|
;;;219    #if 0
;;;220         case USB_EVT_OUT_NAK:
;;;221          //bulkOutNak();
;;;222          break;
;;;223    	case USB_EVT_IN_NAK:
;;;224    	  break;		
;;;225    #endif
;;;226        case USB_EVT_OUT:
;;;227    	  recvChunk();
00000e  f7fffffe          BL       recvChunk
;;;228          break;
000012  e002              B        |L3.26|
                  |L3.20|
;;;229        case USB_EVT_IN:  // this gets called upon completion
;;;230    	  sendChunk();
000014  f7fffffe          BL       sendChunk
;;;231          break;
000018  bf00              NOP      
                  |L3.26|
00001a  bf00              NOP                            ;228
;;;232    #if 0
;;;233    	default:
;;;234    	  printf("* %d\n", event);
;;;235    	  USB_ClrStallEP(USB_BULK_OUT_EP);
;;;236    	  USB_ResetEP(USB_BULK_OUT_EP);
;;;237    	  USB_ClrStallEP(USB_BULK_IN_EP);
;;;238    	  USB_ResetEP(USB_BULK_IN_EP);
;;;239    	  break;		
;;;240    #endif
;;;241      }
;;;242    }
00001c  bd10              POP      {r4,pc}
;;;243    
                          ENDP


                          AREA ||i.USB_EndPoint3||, CODE, READONLY, ALIGN=1

                  USB_EndPoint3 PROC
;;;250    
;;;251    void USB_EndPoint3 (uint32_t event) {
000000  4770              BX       lr
;;;252    }
;;;253    
                          ENDP


                          AREA ||i.USB_EndPoint4||, CODE, READONLY, ALIGN=1

                  USB_EndPoint4 PROC
;;;260    
;;;261    void USB_EndPoint4 (uint32_t event) {
000000  4770              BX       lr
;;;262    }
;;;263    
                          ENDP


                          AREA ||i.USB_EndPoint5||, CODE, READONLY, ALIGN=1

                  USB_EndPoint5 PROC
;;;270    
;;;271    void USB_EndPoint5 (uint32_t event) {
000000  bf00              NOP      
;;;272      event = event;
;;;273    }
000002  4770              BX       lr
;;;274    
                          ENDP


                          AREA ||i.USB_Recv||, CODE, READONLY, ALIGN=2

                  USB_Recv PROC
;;;395    
;;;396    void USB_Recv(uint8_t *data, uint32_t len)
000000  b570              PUSH     {r4-r6,lr}
;;;397    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;398    	if ((uint32_t)data&0x03)
000006  f0040003          AND      r0,r4,#3
00000a  b100              CBZ      r0,|L7.14|
                  |L7.12|
;;;399    		return;
;;;400    
;;;401    	g_recvData = data;
;;;402    	g_recvLen = len;
;;;403    	g_recvOffset = 0;
;;;404    	g_recvComplete = 0;
;;;405    
;;;406    	recvChunk();
;;;407    }  
00000c  bd70              POP      {r4-r6,pc}
                  |L7.14|
00000e  4806              LDR      r0,|L7.40|
000010  6004              STR      r4,[r0,#0]            ;401  ; g_recvData
000012  4806              LDR      r0,|L7.44|
000014  6005              STR      r5,[r0,#0]            ;402  ; g_recvLen
000016  2000              MOVS     r0,#0                 ;403
000018  4905              LDR      r1,|L7.48|
00001a  6008              STR      r0,[r1,#0]            ;403  ; g_recvOffset
00001c  4905              LDR      r1,|L7.52|
00001e  7008              STRB     r0,[r1,#0]            ;404
000020  f7fffffe          BL       recvChunk
000024  bf00              NOP      
000026  e7f1              B        |L7.12|
;;;408    
                          ENDP

                  |L7.40|
                          DCD      g_recvData
                  |L7.44|
                          DCD      g_recvLen
                  |L7.48|
                          DCD      g_recvOffset
                  |L7.52|
                          DCD      g_recvComplete

                          AREA ||i.USB_RecvReset||, CODE, READONLY, ALIGN=1

                  USB_RecvReset PROC
;;;408    
;;;409    void USB_RecvReset(void)
000000  b510              PUSH     {r4,lr}
;;;410    {
;;;411    	USB_ResetEP(USB_BULK_OUT_EP);
000002  2002              MOVS     r0,#2
000004  f7fffffe          BL       USB_ResetEP
;;;412    }
000008  bd10              POP      {r4,pc}
;;;413    
                          ENDP


                          AREA ||i.USB_Reset_Event||, CODE, READONLY, ALIGN=1

                  USB_Reset_Event PROC
;;;67     #if USB_RESET_EVENT
;;;68     void USB_Reset_Event (void) {
000000  b510              PUSH     {r4,lr}
;;;69       USB_ResetCore();
000002  f7fffffe          BL       USB_ResetCore
;;;70     }
000006  bd10              POP      {r4,pc}
;;;71     #endif
                          ENDP


                          AREA ||i.USB_Resume_Event||, CODE, READONLY, ALIGN=1

                  USB_Resume_Event PROC
;;;90     #if USB_RESUME_EVENT
;;;91     void USB_Resume_Event (void) {
000000  4770              BX       lr
;;;92     }
;;;93     #endif
                          ENDP


                          AREA ||i.USB_Send||, CODE, READONLY, ALIGN=2

                  USB_Send PROC
;;;381    
;;;382    void USB_Send(const uint8_t *data, uint32_t len)
000000  b570              PUSH     {r4-r6,lr}
;;;383    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;384    	if ((uint32_t)data&0x3)
000006  f0040003          AND      r0,r4,#3
00000a  b100              CBZ      r0,|L11.14|
                  |L11.12|
;;;385    		return;
;;;386    
;;;387    	g_sendData = data;
;;;388    	g_sendLen = len;
;;;389    	g_sendOffset = 0;
;;;390    	g_sendComplete = 0;
;;;391    
;;;392    	sendChunk();
;;;393    }
00000c  bd70              POP      {r4-r6,pc}
                  |L11.14|
00000e  4806              LDR      r0,|L11.40|
000010  6004              STR      r4,[r0,#0]            ;387  ; g_sendData
000012  4806              LDR      r0,|L11.44|
000014  6005              STR      r5,[r0,#0]            ;388  ; g_sendLen
000016  2000              MOVS     r0,#0                 ;389
000018  4905              LDR      r1,|L11.48|
00001a  6008              STR      r0,[r1,#0]            ;389  ; g_sendOffset
00001c  4905              LDR      r1,|L11.52|
00001e  7008              STRB     r0,[r1,#0]            ;390
000020  f7fffffe          BL       sendChunk
000024  bf00              NOP      
000026  e7f1              B        |L11.12|
;;;394    
                          ENDP

                  |L11.40|
                          DCD      g_sendData
                  |L11.44|
                          DCD      g_sendLen
                  |L11.48|
                          DCD      g_sendOffset
                  |L11.52|
                          DCD      g_sendComplete

                          AREA ||i.USB_SendReset||, CODE, READONLY, ALIGN=1

                  USB_SendReset PROC
;;;413    
;;;414    void USB_SendReset(void)
000000  b510              PUSH     {r4,lr}
;;;415    {
;;;416    	USB_ResetEP(USB_BULK_IN_EP);
000002  2082              MOVS     r0,#0x82
000004  f7fffffe          BL       USB_ResetEP
;;;417    }
000008  bd10              POP      {r4,pc}
                          ENDP


                          AREA ||i.USB_Suspend_Event||, CODE, READONLY, ALIGN=1

                  USB_Suspend_Event PROC
;;;79     #if USB_SUSPEND_EVENT
;;;80     void USB_Suspend_Event (void) {
000000  4770              BX       lr
;;;81     }
;;;82     #endif
                          ENDP


                          AREA ||i.USB_UserInit||, CODE, READONLY, ALIGN=2

                  USB_UserInit PROC
;;;274    
;;;275    void USB_UserInit(void)
000000  b500              PUSH     {lr}
;;;276    {
000002  b08f              SUB      sp,sp,#0x3c
;;;277    	LPC_USBDRV_INIT_T usb_cb;
;;;278    
;;;279    	/* initilize call back structures */
;;;280    	memset((void*)&usb_cb, 0, sizeof(LPC_USBDRV_INIT_T));
000004  213c              MOVS     r1,#0x3c
000006  4668              MOV      r0,sp
000008  f7fffffe          BL       __aeabi_memclr4
;;;281    	usb_cb.USB_Reset_Event = USB_Reset_Event;
00000c  4808              LDR      r0,|L14.48|
00000e  9002              STR      r0,[sp,#8]
;;;282    	usb_cb.USB_P_EP[0] = USB_EndPoint0;
000010  4808              LDR      r0,|L14.52|
000012  900b              STR      r0,[sp,#0x2c]
;;;283    	usb_cb.USB_P_EP[1] = USB_EndPoint1;
000014  4908              LDR      r1,|L14.56|
000016  910c              STR      r1,[sp,#0x30]
;;;284    	usb_cb.USB_P_EP[2] = USB_EndPoint2;
000018  4908              LDR      r1,|L14.60|
00001a  910d              STR      r1,[sp,#0x34]
;;;285    	usb_cb.ep0_maxp = USB_MAX_PACKET0;
00001c  2040              MOVS     r0,#0x40
00001e  9000              STR      r0,[sp,#0]
;;;286    
;;;287      USB_Init(&usb_cb);                               // USB Initialization
000020  4668              MOV      r0,sp
000022  f7fffffe          BL       USB_Init
;;;288      // delay?
;;;289      //for(i=0; i<10000000; i++);
;;;290      USB_Connect(TRUE);                        // USB Connect
000026  2001              MOVS     r0,#1
000028  f7fffffe          BL       USB_Connect
;;;291      //for(i=0; i<100000000; i++);
;;;292      //while (!USB_Configuration);
;;;293    }
00002c  b00f              ADD      sp,sp,#0x3c
00002e  bd00              POP      {pc}
;;;294    
                          ENDP

                  |L14.48|
                          DCD      USB_Reset_Event
                  |L14.52|
                          DCD      USB_EndPoint0
                  |L14.56|
                          DCD      USB_EndPoint1
                  |L14.60|
                          DCD      USB_EndPoint2

                          AREA ||i.USB_handleState||, CODE, READONLY, ALIGN=2

                  USB_handleState PROC
;;;295    // monitor usb connector plug/unplugs
;;;296    uint32_t USB_handleState(void)
000000  b510              PUSH     {r4,lr}
;;;297    {
;;;298    	uint32_t susp;
;;;299    
;;;300    	if (USB_Configuration)
000002  480b              LDR      r0,|L15.48|
000004  7800              LDRB     r0,[r0,#0]  ; USB_Configuration
000006  b180              CBZ      r0,|L15.42|
;;;301    	{
;;;302    		susp = LPC_USB->PORTSC1_D&(1<<7); 
000008  480a              LDR      r0,|L15.52|
00000a  6800              LDR      r0,[r0,#0]
00000c  f0000480          AND      r4,r0,#0x80
;;;303    		if (susp)
000010  b15c              CBZ      r4,|L15.42|
;;;304    		{
;;;305    			USB_ResetEP(USB_BULK_OUT_EP);
000012  2002              MOVS     r0,#2
000014  f7fffffe          BL       USB_ResetEP
;;;306    			USB_ResetEP(USB_BULK_IN_EP);
000018  2082              MOVS     r0,#0x82
00001a  f7fffffe          BL       USB_ResetEP
;;;307    			USB_Configuration = 0;
00001e  2000              MOVS     r0,#0
000020  4903              LDR      r1,|L15.48|
000022  7008              STRB     r0,[r1,#0]
;;;308    			printf("reset configuration\n");
000024  a004              ADR      r0,|L15.56|
000026  f7fffffe          BL       lpc_printf
                  |L15.42|
;;;309    		}
;;;310    	}
;;;311    
;;;312    	return USB_Configuration;
00002a  4801              LDR      r0,|L15.48|
00002c  7800              LDRB     r0,[r0,#0]  ; USB_Configuration
;;;313    }
00002e  bd10              POP      {r4,pc}
;;;314    
                          ENDP

                  |L15.48|
                          DCD      USB_Configuration
                  |L15.52|
                          DCD      0x40006184
                  |L15.56|
000038  72657365          DCB      "reset configuration\n",0
00003c  7420636f
000040  6e666967
000044  75726174
000048  696f6e0a
00004c  00      
00004d  00                DCB      0
00004e  00                DCB      0
00004f  00                DCB      0

                          AREA ||i.bulkOutNak||, CODE, READONLY, ALIGN=1

                  bulkOutNak PROC
;;;314    
;;;315    void bulkOutNak(void){
000000  4770              BX       lr
;;;316        //USB_ReadReqEP(USB_BULK_OUT_EP, (uint8_t *)buf, len);
;;;317    }
;;;318    
                          ENDP


                          AREA ||i.recvChunk||, CODE, READONLY, ALIGN=2

                  recvChunk PROC
;;;357    
;;;358    void recvChunk(void)
000000  b510              PUSH     {r4,lr}
;;;359    {
;;;360    	uint32_t chunk;
;;;361    
;;;362    	// reset timer
;;;363    	g_recvTimerStart = LPC_TIMER1->TC;
000002  4817              LDR      r0,|L17.96|
000004  6880              LDR      r0,[r0,#8]
000006  4917              LDR      r1,|L17.100|
000008  6008              STR      r0,[r1,#0]  ; g_recvTimerStart
;;;364    
;;;365    	if (g_recvOffset>=g_recvLen)
00000a  4817              LDR      r0,|L17.104|
00000c  6800              LDR      r0,[r0,#0]  ; g_recvOffset
00000e  4917              LDR      r1,|L17.108|
000010  6809              LDR      r1,[r1,#0]  ; g_recvLen
000012  4288              CMP      r0,r1
000014  d303              BCC      |L17.30|
;;;366    	{
;;;367    		g_recvComplete = 1;
000016  2001              MOVS     r0,#1
000018  4915              LDR      r1,|L17.112|
00001a  7008              STRB     r0,[r1,#0]
                  |L17.28|
;;;368    		return;
;;;369    	}
;;;370    
;;;371    	if (g_recvLen-g_recvOffset>=USB_MAX_CHUNK)
;;;372    		chunk = USB_MAX_CHUNK;
;;;373    	else
;;;374    		chunk = g_recvLen-g_recvOffset;
;;;375    	
;;;376    	
;;;377    	USB_ReadReqEP(USB_BULK_OUT_EP, (uint8_t *)g_recvData + g_recvOffset, chunk);
;;;378    
;;;379    	g_recvOffset += chunk;
;;;380    }								 
00001c  bd10              POP      {r4,pc}
                  |L17.30|
00001e  4813              LDR      r0,|L17.108|
000020  6800              LDR      r0,[r0,#0]            ;371  ; g_recvLen
000022  4911              LDR      r1,|L17.104|
000024  6809              LDR      r1,[r1,#0]            ;371  ; g_recvOffset
000026  1a40              SUBS     r0,r0,r1              ;371
000028  f5b04f80          CMP      r0,#0x4000            ;371
00002c  d302              BCC      |L17.52|
00002e  f44f4480          MOV      r4,#0x4000            ;372
000032  e004              B        |L17.62|
                  |L17.52|
000034  480d              LDR      r0,|L17.108|
000036  6800              LDR      r0,[r0,#0]            ;374  ; g_recvLen
000038  490b              LDR      r1,|L17.104|
00003a  6809              LDR      r1,[r1,#0]            ;374  ; g_recvOffset
00003c  1a44              SUBS     r4,r0,r1              ;374
                  |L17.62|
00003e  480d              LDR      r0,|L17.116|
000040  6800              LDR      r0,[r0,#0]            ;377  ; g_recvData
000042  4a09              LDR      r2,|L17.104|
000044  6812              LDR      r2,[r2,#0]            ;377  ; g_recvOffset
000046  1881              ADDS     r1,r0,r2              ;377
000048  4622              MOV      r2,r4                 ;377
00004a  2002              MOVS     r0,#2                 ;377
00004c  f7fffffe          BL       USB_ReadReqEP
000050  4805              LDR      r0,|L17.104|
000052  6800              LDR      r0,[r0,#0]            ;379  ; g_recvOffset
000054  4420              ADD      r0,r0,r4              ;379
000056  4904              LDR      r1,|L17.104|
000058  6008              STR      r0,[r1,#0]            ;379  ; g_recvOffset
00005a  bf00              NOP      
00005c  e7de              B        |L17.28|
;;;381    
                          ENDP

00005e  0000              DCW      0x0000
                  |L17.96|
                          DCD      0x40085000
                  |L17.100|
                          DCD      g_recvTimerStart
                  |L17.104|
                          DCD      g_recvOffset
                  |L17.108|
                          DCD      g_recvLen
                  |L17.112|
                          DCD      g_recvComplete
                  |L17.116|
                          DCD      g_recvData

                          AREA ||i.sendChunk||, CODE, READONLY, ALIGN=2

                  sendChunk PROC
;;;334    
;;;335    void sendChunk(void)
000000  b510              PUSH     {r4,lr}
;;;336    {
;;;337    	uint32_t chunk;
;;;338    
;;;339    	// reset timer
;;;340    	g_sendTimerStart = LPC_TIMER1->TC;
000002  4817              LDR      r0,|L18.96|
000004  6880              LDR      r0,[r0,#8]
000006  4917              LDR      r1,|L18.100|
000008  6008              STR      r0,[r1,#0]  ; g_sendTimerStart
;;;341    
;;;342    	if (g_sendOffset>=g_sendLen)
00000a  4817              LDR      r0,|L18.104|
00000c  6800              LDR      r0,[r0,#0]  ; g_sendOffset
00000e  4917              LDR      r1,|L18.108|
000010  6809              LDR      r1,[r1,#0]  ; g_sendLen
000012  4288              CMP      r0,r1
000014  d303              BCC      |L18.30|
;;;343    	{
;;;344    		g_sendComplete = 1;
000016  2001              MOVS     r0,#1
000018  4915              LDR      r1,|L18.112|
00001a  7008              STRB     r0,[r1,#0]
                  |L18.28|
;;;345    		return;
;;;346    	}
;;;347    
;;;348    	if (g_sendLen-g_sendOffset>=USB_MAX_CHUNK)
;;;349    		chunk = USB_MAX_CHUNK;
;;;350    	else
;;;351    		chunk = g_sendLen-g_sendOffset;
;;;352    	
;;;353    	USB_WriteEP(USB_BULK_IN_EP, (uint8_t *)g_sendData + g_sendOffset, chunk);
;;;354    
;;;355    	g_sendOffset += chunk;
;;;356    }
00001c  bd10              POP      {r4,pc}
                  |L18.30|
00001e  4813              LDR      r0,|L18.108|
000020  6800              LDR      r0,[r0,#0]            ;348  ; g_sendLen
000022  4911              LDR      r1,|L18.104|
000024  6809              LDR      r1,[r1,#0]            ;348  ; g_sendOffset
000026  1a40              SUBS     r0,r0,r1              ;348
000028  f5b04f80          CMP      r0,#0x4000            ;348
00002c  d302              BCC      |L18.52|
00002e  f44f4480          MOV      r4,#0x4000            ;349
000032  e004              B        |L18.62|
                  |L18.52|
000034  480d              LDR      r0,|L18.108|
000036  6800              LDR      r0,[r0,#0]            ;351  ; g_sendLen
000038  490b              LDR      r1,|L18.104|
00003a  6809              LDR      r1,[r1,#0]            ;351  ; g_sendOffset
00003c  1a44              SUBS     r4,r0,r1              ;351
                  |L18.62|
00003e  480d              LDR      r0,|L18.116|
000040  6800              LDR      r0,[r0,#0]            ;353  ; g_sendData
000042  4a09              LDR      r2,|L18.104|
000044  6812              LDR      r2,[r2,#0]            ;353  ; g_sendOffset
000046  1881              ADDS     r1,r0,r2              ;353
000048  4622              MOV      r2,r4                 ;353
00004a  2082              MOVS     r0,#0x82              ;353
00004c  f7fffffe          BL       USB_WriteEP
000050  4805              LDR      r0,|L18.104|
000052  6800              LDR      r0,[r0,#0]            ;355  ; g_sendOffset
000054  4420              ADD      r0,r0,r4              ;355
000056  4904              LDR      r1,|L18.104|
000058  6008              STR      r0,[r1,#0]            ;355  ; g_sendOffset
00005a  bf00              NOP      
00005c  e7de              B        |L18.28|
;;;357    
                          ENDP

00005e  0000              DCW      0x0000
                  |L18.96|
                          DCD      0x40085000
                  |L18.100|
                          DCD      g_sendTimerStart
                  |L18.104|
                          DCD      g_sendOffset
                  |L18.108|
                          DCD      g_sendLen
                  |L18.112|
                          DCD      g_sendComplete
                  |L18.116|
                          DCD      g_sendData

                          AREA ||i.testWrite||, CODE, READONLY, ALIGN=2

                  testWrite PROC
;;;199    
;;;200    void testWrite()
000000  b570              PUSH     {r4-r6,lr}
;;;201    {
;;;202    	static int flag = 0;
;;;203       	unsigned int *memory = (unsigned int *)0x10000000;
000002  f04f5580          MOV      r5,#0x10000000
;;;204    	int i;
;;;205    
;;;206    	if (!flag)
000006  480b              LDR      r0,|L19.52|
000008  6800              LDR      r0,[r0,#0]  ; flag
00000a  b960              CBNZ     r0,|L19.38|
;;;207    	{
;;;208    		for (i=0; i<0x2000; i++)
00000c  2400              MOVS     r4,#0
00000e  e004              B        |L19.26|
                  |L19.16|
;;;209    			memory[i] = (unsigned int)&memory[i];
000010  eb050084          ADD      r0,r5,r4,LSL #2
000014  f8450024          STR      r0,[r5,r4,LSL #2]
000018  1c64              ADDS     r4,r4,#1              ;208
                  |L19.26|
00001a  f5b45f00          CMP      r4,#0x2000            ;208
00001e  dbf7              BLT      |L19.16|
;;;210    		flag = 1;		
000020  2001              MOVS     r0,#1
000022  4904              LDR      r1,|L19.52|
000024  6008              STR      r0,[r1,#0]  ; flag
                  |L19.38|
;;;211    	}
;;;212    
;;;213    	USB_WriteEP(USB_BULK_IN_EP, (uint8_t *)memory, 0x4000);
000026  f44f4280          MOV      r2,#0x4000
00002a  4629              MOV      r1,r5
00002c  2082              MOVS     r0,#0x82
00002e  f7fffffe          BL       USB_WriteEP
;;;214    }
000032  bd70              POP      {r4-r6,pc}
;;;215    
                          ENDP

                  |L19.52|
                          DCD      flag

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  USB_P_EP
                          DCD      USB_EndPoint0
                          DCD      USB_EndPoint1
                          DCD      USB_EndPoint2
                          DCD      0x00000000

                          AREA ||.data||, DATA, ALIGN=2

                  g_recvData
                          DCD      0x00000000
                  g_recvLen
                          DCD      0x00000000
                  g_recvOffset
                          DCD      0x00000000
                  g_recvComplete
00000c  00000000          DCB      0x00,0x00,0x00,0x00
                  g_recvTimerStart
                          DCD      0x00000000
                  g_sendData
                          DCD      0x00000000
                  g_sendLen
                          DCD      0x00000000
                  g_sendOffset
                          DCD      0x00000000
                  g_sendComplete
000020  00000000          DCB      0x00,0x00,0x00,0x00
                  g_sendTimerStart
                          DCD      0x00000000
                  flag
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "usbuser.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___9_usbuser_c_3d12303f____REV16|
#line 130 ".\\core_cmInstr.h"
|__asm___9_usbuser_c_3d12303f____REV16| PROC
#line 131

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___9_usbuser_c_3d12303f____REVSH|
#line 144
|__asm___9_usbuser_c_3d12303f____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
