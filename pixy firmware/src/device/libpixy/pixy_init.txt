; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--cpp --list --split_sections --debug -c --asm --interleave -o.\pixy_init.o --asm_dir=.\ --list_dir=.\ --depend=.\pixy_init.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I. -I..\..\common -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=514 -DCORE_M4 -DIPC_MASTER -DPIXY --omf_browse=.\pixy_init.crf pixy_init.cpp]
                          THUMB

                          AREA ||i._Z10CameraInitv||, CODE, READONLY, ALIGN=2

                  _Z10CameraInitv PROC ; CameraInit()
;;;84     
;;;85     void CameraInit(void)
000000  b508              PUSH     {r3,lr}
;;;86     {
;;;87     	volatile uint32_t d;
;;;88     
;;;89     	LPC_GPIO_PORT->MASK[0] = 0;
000002  2000              MOVS     r0,#0
000004  4916              LDR      r1,|L1.96|
000006  6008              STR      r0,[r1,#0]
;;;90     	LPC_GPIO_PORT->MASK[1] = 0;
000008  2100              MOVS     r1,#0
00000a  4815              LDR      r0,|L1.96|
00000c  6041              STR      r1,[r0,#4]
;;;91     	LPC_GPIO_PORT->DIR[0] = 0x0007;
00000e  2007              MOVS     r0,#7
000010  4913              LDR      r1,|L1.96|
000012  3980              SUBS     r1,r1,#0x80
000014  6008              STR      r0,[r1,#0]
;;;92     	LPC_GPIO_PORT->DIR[1] = 0x0000;
000016  2100              MOVS     r1,#0
000018  4811              LDR      r0,|L1.96|
00001a  3880              SUBS     r0,r0,#0x80
00001c  6041              STR      r1,[r0,#4]
;;;93     
;;;94     	// deal with pwdn
;;;95     	LPC_GPIO_PORT->PIN[0] = 0;
00001e  2000              MOVS     r0,#0
000020  490f              LDR      r1,|L1.96|
000022  3980              SUBS     r1,r1,#0x80
000024  f8c10100          STR      r0,[r1,#0x100]
;;;96     	LPC_GPIO_PORT->PIN[0] |= 0x0004;
000028  4608              MOV      r0,r1
00002a  f8d00100          LDR      r0,[r0,#0x100]
00002e  f0400004          ORR      r0,r0,#4
000032  f8c10100          STR      r0,[r1,#0x100]
;;;97     	for (d=0; d<10000000; d++);
000036  2000              MOVS     r0,#0
000038  9000              STR      r0,[sp,#0]
00003a  e002              B        |L1.66|
                  |L1.60|
00003c  9800              LDR      r0,[sp,#0]
00003e  1c40              ADDS     r0,r0,#1
000040  9000              STR      r0,[sp,#0]
                  |L1.66|
000042  4908              LDR      r1,|L1.100|
000044  9800              LDR      r0,[sp,#0]
000046  4288              CMP      r0,r1
000048  d3f8              BCC      |L1.60|
;;;98     	LPC_GPIO_PORT->PIN[0] &= ~(0x0004);
00004a  4805              LDR      r0,|L1.96|
00004c  3080              ADDS     r0,r0,#0x80
00004e  6800              LDR      r0,[r0,#0]
000050  f0200004          BIC      r0,r0,#4
000054  4902              LDR      r1,|L1.96|
000056  3980              SUBS     r1,r1,#0x80
000058  f8c10100          STR      r0,[r1,#0x100]
;;;99     
;;;100    }
00005c  bd08              POP      {r3,pc}
;;;101    
                          ENDP

00005e  0000              DCW      0x0000
                  |L1.96|
                          DCD      0x400f6080
                  |L1.100|
                          DCD      0x00989680

                          AREA ||i._Z10commonInitv||, CODE, READONLY, ALIGN=2

                  _Z10commonInitv PROC ; commonInit()
;;;126    
;;;127    void commonInit(void)
000000  b510              PUSH     {r4,lr}
;;;128    {
;;;129    	platformInit();
000002  f7fffffe          BL       platformInit
;;;130    	timerInit();
000006  f7fffffe          BL       _Z9timerInitv ; timerInit()
;;;131    	GPIOInit();
00000a  f7fffffe          BL       _Z8GPIOInitv ; GPIOInit()
;;;132    	USB_UserInit();
00000e  f7fffffe          BL       USB_UserInit
;;;133    
;;;134      	debug_frmwrk_init_clk(CLKFREQ);
000012  4803              LDR      r0,|L2.32|
000014  f7fffffe          BL       debug_frmwrk_init_clk
;;;135    	lpc_printf("M4 start\n");
000018  a002              ADR      r0,|L2.36|
00001a  f7fffffe          BL       lpc_printf
;;;136    }
00001e  bd10              POP      {r4,pc}
;;;137    
                          ENDP

                  |L2.32|
                          DCD      0x0c28cb00
                  |L2.36|
000024  4d342073          DCB      "M4 start\n",0
000028  74617274
00002c  0a00    
00002e  00                DCB      0
00002f  00                DCB      0

                          AREA ||i._Z14pixySimpleInitv||, CODE, READONLY, ALIGN=2

                  _Z14pixySimpleInitv PROC ; pixySimpleInit()
;;;218    
;;;219    void pixySimpleInit(void)
000000  b570              PUSH     {r4-r6,lr}
;;;220    {
;;;221    	commonInit();
000002  f7fffffe          BL       _Z10commonInitv ; commonInit()
;;;222    
;;;223    	USBLink *usbLink = new USBLink;
000006  2010              MOVS     r0,#0x10
000008  f7fffffe          BL       _Znwj ; operator new(unsigned)
00000c  4604              MOV      r4,r0
00000e  f7fffffe          BL       _ZN7USBLinkC1Ev ; USBLink::USBLink()
000012  4604              MOV      r4,r0
000014  4626              MOV      r6,r4
;;;224    	g_chirpUsb = new Chirp(false, false, usbLink);
000016  203c              MOVS     r0,#0x3c
000018  f7fffffe          BL       _Znwj ; operator new(unsigned)
00001c  4605              MOV      r5,r0
00001e  4633              MOV      r3,r6
000020  2200              MOVS     r2,#0
000022  4611              MOV      r1,r2
000024  f7fffffe          BL       _ZN5ChirpC1EbbP4Link ; Chirp::Chirp(bool, bool, Link*)
000028  4605              MOV      r5,r0
00002a  4801              LDR      r0,|L3.48|
00002c  6005              STR      r5,[r0,#0]  ; g_chirpUsb
;;;225    }
00002e  bd70              POP      {r4-r6,pc}
;;;226    
                          ENDP

                  |L3.48|
                          DCD      g_chirpUsb

                          AREA ||i._Z7ADCInitv||, CODE, READONLY, ALIGN=2

                  _Z7ADCInitv PROC ; ADCInit()
;;;28     
;;;29     void ADCInit()
000000  b510              PUSH     {r4,lr}
;;;30     {
;;;31     	ADC_Init(LPC_ADC0, 200000, 10);
000002  220a              MOVS     r2,#0xa
000004  4904              LDR      r1,|L4.24|
000006  4805              LDR      r0,|L4.28|
000008  f7fffffe          BL       ADC_Init
;;;32     	ADC_IntConfig(LPC_ADC0,ADC_ADINTEN1,DISABLE);
00000c  2200              MOVS     r2,#0
00000e  2101              MOVS     r1,#1
000010  4802              LDR      r0,|L4.28|
000012  f7fffffe          BL       ADC_IntConfig
;;;33     }
000016  bd10              POP      {r4,pc}
;;;34     
                          ENDP

                  |L4.24|
                          DCD      0x00030d40
                  |L4.28|
                          DCD      0x400e3000

                          AREA ||i._Z7SCTInitv||, CODE, READONLY, ALIGN=2

                  _Z7SCTInitv PROC ; SCTInit()
;;;34     
;;;35     void SCTInit()
000000  f04f4080          MOV      r0,#0x40000000
;;;36     {
;;;37     	// RC servo
;;;38     	LPC_SCT->CTRL_L |= 1<<2; // set halt 
000004  8880              LDRH     r0,[r0,#4]
000006  f0400004          ORR      r0,r0,#4
00000a  f04f4180          MOV      r1,#0x40000000
00000e  8088              STRH     r0,[r1,#4]
;;;39     	LPC_SCT->CTRL_L &= ~(255<<5); // reset prescaler
000010  4608              MOV      r0,r1
000012  8880              LDRH     r0,[r0,#4]
000014  f42050ff          BIC      r0,r0,#0x1fe0
000018  8088              STRH     r0,[r1,#4]
;;;40     	LPC_SCT->CTRL_L |= 203<<5; // prescale (create a 1 MHz clock)
00001a  4608              MOV      r0,r1
00001c  8880              LDRH     r0,[r0,#4]
00001e  f44050cb          ORR      r0,r0,#0x1960
000022  8088              STRH     r0,[r1,#4]
;;;41     	LPC_SCT->LIMIT_L = 1<<0; // event 0 resets counter
000024  2001              MOVS     r0,#1
000026  8108              STRH     r0,[r1,#8]
;;;42     
;;;43       	LPC_SCT->OUTPUT = 0x0;
000028  2000              MOVS     r0,#0
00002a  6508              STR      r0,[r1,#0x50]
;;;44     	LPC_SCT->CONFIG &= ~0x01; // set UNITY=0, default clk source, bus clock
00002c  4608              MOV      r0,r1
00002e  6800              LDR      r0,[r0,#0]
000030  f0200001          BIC      r0,r0,#1
000034  6008              STR      r0,[r1,#0]
;;;45     
;;;46     	LPC_SCT->MATCH[0].L = 20000; // 4000;
000036  f6446020          MOV      r0,#0x4e20
00003a  4931              LDR      r1,|L5.256|
00003c  8008              STRH     r0,[r1,#0]
;;;47     	LPC_SCT->MATCHREL[0].L = 20000; // 4000;
00003e  0641              LSLS     r1,r0,#25
000040  f8a10200          STRH     r0,[r1,#0x200]
;;;48     	LPC_SCT->EVENT[0].CTRL = 0 | 1<<12;
000044  1489              ASRS     r1,r1,#18
000046  482f              LDR      r0,|L5.260|
000048  6001              STR      r1,[r0,#0]
;;;49     	LPC_SCT->EVENT[1].CTRL = 1 | 1<<12;
00004a  1c49              ADDS     r1,r1,#1
00004c  482d              LDR      r0,|L5.260|
00004e  3008              ADDS     r0,r0,#8
000050  6001              STR      r1,[r0,#0]
;;;50     	LPC_SCT->EVENT[0].STATE = 1<<0; // event 0 is enabled in state 0
000052  2001              MOVS     r0,#1
000054  492b              LDR      r1,|L5.260|
000056  1f09              SUBS     r1,r1,#4
000058  6008              STR      r0,[r1,#0]
;;;51     	LPC_SCT->EVENT[1].STATE = 1<<0; // event 1 is enabled in state 0
00005a  2101              MOVS     r1,#1
00005c  0780              LSLS     r0,r0,#30
00005e  f8c01308          STR      r1,[r0,#0x308]
;;;52     
;;;53     	LPC_SCT->EVENT[2].CTRL = 2 | 1<<12;
000062  f2410102          MOV      r1,#0x1002
000066  f8c01314          STR      r1,[r0,#0x314]
;;;54     	LPC_SCT->EVENT[2].STATE = 1<<0; // event 2 is enabled in state 0
00006a  2101              MOVS     r1,#1
00006c  f8c01310          STR      r1,[r0,#0x310]
;;;55     
;;;56     	// RGB led
;;;57     	LPC_SCT->CTRL_H |= 1<<2; // set halt 
000070  88c0              LDRH     r0,[r0,#6]
000072  f0400104          ORR      r1,r0,#4
000076  f04f4080          MOV      r0,#0x40000000
00007a  80c1              STRH     r1,[r0,#6]
;;;58     	LPC_SCT->CTRL_H &= ~(255<<5); // reset prescaler
00007c  88c0              LDRH     r0,[r0,#6]
00007e  f42051ff          BIC      r1,r0,#0x1fe0
000082  f04f4080          MOV      r0,#0x40000000
000086  80c1              STRH     r1,[r0,#6]
;;;59     	LPC_SCT->CTRL_H |= 9<<5; // prescale (create a 1 MHz clock)
000088  88c0              LDRH     r0,[r0,#6]
00008a  f4407190          ORR      r1,r0,#0x120
00008e  f04f4080          MOV      r0,#0x40000000
000092  80c1              STRH     r1,[r0,#6]
;;;60     	LPC_SCT->LIMIT_H = 1<<3; // event 3 resets counter
000094  2008              MOVS     r0,#8
000096  06c1              LSLS     r1,r0,#27
000098  8148              STRH     r0,[r1,#0xa]
;;;61     
;;;62     	LPC_SCT->MATCH[0].H = 0xffff;
00009a  f64f71ff          MOV      r1,#0xffff
00009e  06c0              LSLS     r0,r0,#27
0000a0  f8a01102          STRH     r1,[r0,#0x102]
;;;63     	LPC_SCT->MATCHREL[0].H = 0xffff;
0000a4  f8a01202          STRH     r1,[r0,#0x202]
;;;64     	LPC_SCT->EVENT[3].CTRL = 0 | 1<<4 | 1<<12;
0000a8  f2410110          MOV      r1,#0x1010
0000ac  f8c0131c          STR      r1,[r0,#0x31c]
;;;65     	LPC_SCT->EVENT[3].STATE = 1<<0; // event 3 is enabled in state 0
0000b0  2101              MOVS     r1,#1
0000b2  f8c01318          STR      r1,[r0,#0x318]
;;;66     
;;;67     	// red
;;;68     	LPC_SCT->EVENT[4].CTRL = 1 | 1<<4 | 1<<12;
0000b6  f2410111          MOV      r1,#0x1011
0000ba  f8c01324          STR      r1,[r0,#0x324]
;;;69     	LPC_SCT->EVENT[4].STATE = 1<<0; // event 4 is enabled in state 0
0000be  2101              MOVS     r1,#1
0000c0  f8c01320          STR      r1,[r0,#0x320]
;;;70     
;;;71     	// green
;;;72     	LPC_SCT->EVENT[5].CTRL = 2 | 1<<4 | 1<<12;
0000c4  f2410112          MOV      r1,#0x1012
0000c8  f8c0132c          STR      r1,[r0,#0x32c]
;;;73     	LPC_SCT->EVENT[5].STATE = 1<<0; // event 5 is enabled in state 0
0000cc  2101              MOVS     r1,#1
0000ce  f8c01328          STR      r1,[r0,#0x328]
;;;74     
;;;75     	// blue
;;;76     	LPC_SCT->EVENT[6].CTRL = 3 | 1<<4 | 1<<12;
0000d2  f2410113          MOV      r1,#0x1013
0000d6  f8c01334          STR      r1,[r0,#0x334]
;;;77     	LPC_SCT->EVENT[6].STATE = 1<<0; // event 6 is enabled in state 0
0000da  2101              MOVS     r1,#1
0000dc  4809              LDR      r0,|L5.260|
0000de  302c              ADDS     r0,r0,#0x2c
0000e0  6001              STR      r1,[r0,#0]
;;;78     
;;;79     	// start SCT timers
;;;80     	LPC_SCT->CTRL_L &= ~(1<<2);
0000e2  0788              LSLS     r0,r1,#30
0000e4  8880              LDRH     r0,[r0,#4]
0000e6  f0200004          BIC      r0,r0,#4
0000ea  0789              LSLS     r1,r1,#30
0000ec  8088              STRH     r0,[r1,#4]
;;;81     	LPC_SCT->CTRL_H &= ~(1<<2); 
0000ee  4608              MOV      r0,r1
0000f0  88c0              LDRH     r0,[r0,#6]
0000f2  f0200104          BIC      r1,r0,#4
0000f6  f04f4080          MOV      r0,#0x40000000
0000fa  80c1              STRH     r1,[r0,#6]
;;;82     }
0000fc  4770              BX       lr
;;;83     
                          ENDP

0000fe  0000              DCW      0x0000
                  |L5.256|
                          DCD      0x40000100
                  |L5.260|
                          DCD      0x40000304

                          AREA ||i._Z7cprintfPKcz||, CODE, READONLY, ALIGN=2

                  _Z7cprintfPKcz PROC ; cprintf(const char*, ...)
;;;226    
;;;227    void cprintf(const char *format, ...)
000000  b40f              PUSH     {r0-r3}
;;;228    {
000002  b500              PUSH     {lr}
000004  b0a3              SUB      sp,sp,#0x8c
;;;229        char  buf[128];
;;;230        va_list args;
;;;231        va_start(args, format);
000006  a825              ADD      r0,sp,#0x94
000008  9002              STR      r0,[sp,#8]
;;;232        vsprintf((char *)buf, (char const *)format, args);
00000a  a803              ADD      r0,sp,#0xc
00000c  9a02              LDR      r2,[sp,#8]
00000e  9924              LDR      r1,[sp,#0x90]
000010  f7fffffe          BL       __c89vsprintf
;;;233        va_end(args);
000014  2000              MOVS     r0,#0
000016  9002              STR      r0,[sp,#8]
;;;234    
;;;235    	CRP_SEND_XDATA(g_chirpUsb, HSTRING(buf));
000018  ab03              ADD      r3,sp,#0xc
00001a  22e1              MOVS     r2,#0xe1
00001c  2118              MOVS     r1,#0x18
00001e  9000              STR      r0,[sp,#0]
000020  4803              LDR      r0,|L6.48|
000022  6800              LDR      r0,[r0,#0]  ; g_chirpUsb
000024  f7fffffe          BL       _ZN5Chirp8assembleEhz ; Chirp::assemble(unsigned char, ...)
;;;236    }
000028  b023              ADD      sp,sp,#0x8c
00002a  f85dfb14          LDR      pc,[sp],#0x14
;;;237    
                          ENDP

00002e  0000              DCW      0x0000
                  |L6.48|
                          DCD      g_chirpUsb

                          AREA ||i._Z8GPIOInitv||, CODE, READONLY, ALIGN=2

                  _Z8GPIOInitv PROC ; GPIOInit()
;;;101    
;;;102    void GPIOInit(void)
000000  2100              MOVS     r1,#0
;;;103    {
;;;104    	// button, SPI_SSEL
;;;105    	LPC_GPIO_PORT->MASK[5] = 0;
000002  4806              LDR      r0,|L7.28|
000004  6141              STR      r1,[r0,#0x14]
;;;106    	LPC_GPIO_PORT->PIN[5] = 0x20; // negate SPI_SS
000006  2120              MOVS     r1,#0x20
000008  4804              LDR      r0,|L7.28|
00000a  3080              ADDS     r0,r0,#0x80
00000c  6141              STR      r1,[r0,#0x14]
;;;107    
;;;108    	// deal with P4_1, GPIO2[1]
;;;109    	LPC_GPIO_PORT->MASK[2] = 0;
00000e  2100              MOVS     r1,#0
000010  4802              LDR      r0,|L7.28|
000012  6081              STR      r1,[r0,#8]
;;;110    	LPC_GPIO_PORT->DIR[2] = 0;
000014  4801              LDR      r0,|L7.28|
000016  3880              SUBS     r0,r0,#0x80
000018  6081              STR      r1,[r0,#8]
;;;111    }
00001a  4770              BX       lr
;;;112    
                          ENDP

                  |L7.28|
                          DCD      0x400f6080

                          AREA ||i._Z8periodicv||, CODE, READONLY, ALIGN=2

                  _Z8periodicv PROC ; periodic()
;;;168    
;;;169    void periodic()
000000  b510              PUSH     {r4,lr}
;;;170    {
;;;171    	// check to see if guard data still there
;;;172    	if (STACK_GUARD!=STACK_GUARD_WORD)
000002  480d              LDR      r0,|L8.56|
000004  6800              LDR      r0,[r0,#0]  ; __Vectors
000006  f5a05080          SUB      r0,r0,#0x1000
00000a  f8b00a00          LDRH     r0,[r0,#0xa00]
00000e  f64a31cd          MOV      r1,#0xabcd
000012  4288              CMP      r0,r1
000014  d004              BEQ      |L8.32|
;;;173    		showError(1, 0xffff00, "stack corruption\n");
000016  a209              ADR      r2,|L8.60|
000018  490d              LDR      r1,|L8.80|
00001a  2001              MOVS     r0,#1
00001c  f7fffffe          BL       showError
                  |L8.32|
;;;174    
;;;175    	while(g_chirpUsb->service());
000020  bf00              NOP      
                  |L8.34|
000022  2101              MOVS     r1,#1
000024  480b              LDR      r0,|L8.84|
000026  6800              LDR      r0,[r0,#0]  ; g_chirpUsb
000028  f7fffffe          BL       _ZN5Chirp7serviceEb ; Chirp::service(bool)
00002c  2800              CMP      r0,#0
00002e  d1f8              BNE      |L8.34|
;;;176    	handleAWB();
000030  f7fffffe          BL       _Z9handleAWBv ; handleAWB()
;;;177    }
000034  bd10              POP      {r4,pc}
;;;178    
                          ENDP

000036  0000              DCW      0x0000
                  |L8.56|
                          DCD      __Vectors
                  |L8.60|
00003c  73746163          DCB      "stack corruption\n",0
000040  6b20636f
000044  72727570
000048  74696f6e
00004c  0a00    
00004e  00                DCB      0
00004f  00                DCB      0
                  |L8.80|
                          DCD      0x00ffff00
                  |L8.84|
                          DCD      g_chirpUsb

                          AREA ||i._Z8pixyInitjPKhj||, CODE, READONLY, ALIGN=2

                  _Z8pixyInitjPKhj PROC ; pixyInit(unsigned, const unsigned char*, unsigned)
;;;178    
;;;179    void pixyInit(uint32_t slaveRomStart, const unsigned char slaveImage[], uint32_t imageSize)
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;180    {
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4691              MOV      r9,r2
;;;181    	// write stack guard word
;;;182     	STACK_GUARD = STACK_GUARD_WORD;
00000a  f64a31cd          MOV      r1,#0xabcd
00000e  4834              LDR      r0,|L9.224|
000010  6800              LDR      r0,[r0,#0]  ; __Vectors
000012  f5a05080          SUB      r0,r0,#0x1000
000016  f8a01a00          STRH     r1,[r0,#0xa00]
;;;183    
;;;184    	commonInit();
00001a  f7fffffe          BL       _Z10commonInitv ; commonInit()
;;;185    
;;;186    	IPC_haltSlave();
00001e  f7fffffe          BL       IPC_haltSlave
;;;187    
;;;188    	// clear RC servo registers to prevent and glitches upon initialization
;;;189    	rcs_enable(0, 0);
000022  2000              MOVS     r0,#0
000024  9001              STR      r0,[sp,#4]
000026  4669              MOV      r1,sp
000028  9000              STR      r0,[sp,#0]
00002a  a801              ADD      r0,sp,#4
00002c  f7fffffe          BL       _Z10rcs_enableRKhS0_ ; rcs_enable(const unsigned char&, const unsigned char&)
;;;190    	rcs_enable(1, 0);
000030  2001              MOVS     r0,#1
000032  9000              STR      r0,[sp,#0]
000034  2000              MOVS     r0,#0
000036  a901              ADD      r1,sp,#4
000038  9001              STR      r0,[sp,#4]
00003a  4668              MOV      r0,sp
00003c  f7fffffe          BL       _Z10rcs_enableRKhS0_ ; rcs_enable(const unsigned char&, const unsigned char&)
;;;191    
;;;192    	ADCInit();
000040  f7fffffe          BL       _Z7ADCInitv ; ADCInit()
;;;193       	SCTInit();
000044  f7fffffe          BL       _Z7SCTInitv ; SCTInit()
;;;194    	CameraInit();
000048  f7fffffe          BL       _Z10CameraInitv ; CameraInit()
;;;195    
;;;196    	// start slave
;;;197    	if (slaveRomStart && slaveImage && imageSize)
00004c  b167              CBZ      r7,|L9.104|
00004e  f1b80f00          CMP      r8,#0
000052  d009              BEQ      |L9.104|
000054  f1b90f00          CMP      r9,#0
000058  d006              BEQ      |L9.104|
;;;198    	{
;;;199    		IPC_downloadSlaveImage(slaveRomStart, slaveImage, imageSize);
00005a  464a              MOV      r2,r9
00005c  4641              MOV      r1,r8
00005e  4638              MOV      r0,r7
000060  f7fffffe          BL       IPC_downloadSlaveImage
;;;200    		IPC_startSlave();
000064  f7fffffe          BL       IPC_startSlave
                  |L9.104|
;;;201    	}
;;;202    
;;;203    	// initialize chirp objects
;;;204    	USBLink *usbLink = new USBLink;
000068  2010              MOVS     r0,#0x10
00006a  f7fffffe          BL       _Znwj ; operator new(unsigned)
00006e  4682              MOV      r10,r0
000070  f7fffffe          BL       _ZN7USBLinkC1Ev ; USBLink::USBLink()
000074  4682              MOV      r10,r0
000076  4655              MOV      r5,r10
;;;205    	g_chirpUsb = new Chirp(false, false, usbLink);
000078  203c              MOVS     r0,#0x3c
00007a  f7fffffe          BL       _Znwj ; operator new(unsigned)
00007e  4604              MOV      r4,r0
000080  462b              MOV      r3,r5
000082  2200              MOVS     r2,#0
000084  4611              MOV      r1,r2
000086  f7fffffe          BL       _ZN5ChirpC1EbbP4Link ; Chirp::Chirp(bool, bool, Link*)
00008a  4604              MOV      r4,r0
00008c  4815              LDR      r0,|L9.228|
00008e  6004              STR      r4,[r0,#0]  ; g_chirpUsb
;;;206    	g_chirpUsb->setSendTimeout(3000); // set a high timeout because the host can sometimes go AWOL for a second or two....
000090  f64031b8          MOV      r1,#0xbb8
000094  6800              LDR      r0,[r0,#0]  ; g_chirpUsb
000096  f7fffffe          BL       _ZN5Chirp14setSendTimeoutEj ; Chirp::setSendTimeout(unsigned)
;;;207    	SMLink *smLink = new SMLink;
00009a  2010              MOVS     r0,#0x10
00009c  f7fffffe          BL       _Znwj ; operator new(unsigned)
0000a0  4683              MOV      r11,r0
0000a2  f7fffffe          BL       _ZN6SMLinkC1Ev ; SMLink::SMLink()
0000a6  4683              MOV      r11,r0
0000a8  465e              MOV      r6,r11
;;;208      	g_chirpM0 = new Chirp(false, true, smLink);
0000aa  203c              MOVS     r0,#0x3c
0000ac  f7fffffe          BL       _Znwj ; operator new(unsigned)
0000b0  4604              MOV      r4,r0
0000b2  4633              MOV      r3,r6
0000b4  2201              MOVS     r2,#1
0000b6  2100              MOVS     r1,#0
0000b8  f7fffffe          BL       _ZN5ChirpC1EbbP4Link ; Chirp::Chirp(bool, bool, Link*)
0000bc  4604              MOV      r4,r0
0000be  480a              LDR      r0,|L9.232|
0000c0  6004              STR      r4,[r0,#0]  ; g_chirpM0
;;;209    
;;;210    	// initialize devices/modules
;;;211    	led_init();
0000c2  f7fffffe          BL       _Z8led_initv ; led_init()
;;;212    	prm_init(g_chirpUsb);
0000c6  4807              LDR      r0,|L9.228|
0000c8  6800              LDR      r0,[r0,#0]  ; g_chirpUsb
0000ca  f7fffffe          BL       _Z8prm_initP5Chirp ; prm_init(Chirp*)
;;;213    	pwr_init();
0000ce  f7fffffe          BL       _Z8pwr_initv ; pwr_init()
;;;214    	cam_init();
0000d2  f7fffffe          BL       _Z8cam_initv ; cam_init()
;;;215    	rcs_init();
0000d6  f7fffffe          BL       _Z8rcs_initv ; rcs_init()
;;;216    	//cc_init();
;;;217    }
0000da  e8bd9ffc          POP      {r2-r12,pc}
;;;218    
                          ENDP

0000de  0000              DCW      0x0000
                  |L9.224|
                          DCD      __Vectors
                  |L9.228|
                          DCD      g_chirpUsb
                  |L9.232|
                          DCD      g_chirpM0

                          AREA ||i._Z9handleAWBv||, CODE, READONLY, ALIGN=2

                  _Z9handleAWBv PROC ; handleAWB()
;;;139    
;;;140    void handleAWB()
000000  b508              PUSH     {r3,lr}
;;;141    {
;;;142    	static uint32_t timer;
;;;143    	static uint8_t state = 0;
;;;144    	uint8_t awbp=0;
000002  2000              MOVS     r0,#0
000004  9000              STR      r0,[sp,#0]
;;;145    
;;;146    	if (state==2)
000006  4806              LDR      r0,|L10.32|
000008  7800              LDRB     r0,[r0,#0]  ; state
00000a  2802              CMP      r0,#2
00000c  d100              BNE      |L10.16|
                  |L10.14|
;;;147    		return;
;;;148    
;;;149    	prm_get("Auto White Balance on power-up", &awbp, END);
;;;150    	if (/*!awbp*/ 1) // Disableing auto white balance
;;;151    		return; // exit if auto white balance on power-up is disabled
;;;152    
;;;153    	else if (state==0)
;;;154    	{
;;;155    		setTimer(&timer);
;;;156    		cam_setAWB(1);
;;;157    		state = 1;
;;;158    	}
;;;159    	else if (state==1)
;;;160    	{
;;;161    		if (getTimer(timer)>AWB_TIMEOUT)
;;;162    		{
;;;163    			cam_setAWB(0);
;;;164    		 	state = 2; // end state machine (only run once)
;;;165    		}
;;;166    	}
;;;167    }
00000e  bd08              POP      {r3,pc}
                  |L10.16|
000010  2200              MOVS     r2,#0                 ;149
000012  4669              MOV      r1,sp                 ;149
000014  a003              ADR      r0,|L10.36|
000016  f7fffffe          BL       _Z7prm_getPKcz ; prm_get(const char*, ...)
00001a  bf00              NOP                            ;151
00001c  e7f7              B        |L10.14|
;;;168    
                          ENDP

00001e  0000              DCW      0x0000
                  |L10.32|
                          DCD      state
                  |L10.36|
000024  4175746f          DCB      "Auto White Balance on power-up",0
000028  20576869
00002c  74652042
000030  616c616e
000034  6365206f
000038  6e20706f
00003c  7765722d
000040  757000  
000043  00                DCB      0

                          AREA ||i._Z9timerInitv||, CODE, READONLY, ALIGN=2

                  _Z9timerInitv PROC ; timerInit()
;;;112    
;;;113    void timerInit(void)
000000  2000              MOVS     r0,#0
;;;114    {
;;;115    	// set timer so we count clock cycles
;;;116    	LPC_TIMER1->IR = 0;
000002  4906              LDR      r1,|L11.28|
000004  6008              STR      r0,[r1,#0]
;;;117     	LPC_TIMER1->TCR = 1;
000006  2001              MOVS     r0,#1
000008  6048              STR      r0,[r1,#4]
;;;118    	LPC_TIMER1->PR = 0;
00000a  2000              MOVS     r0,#0
00000c  60c8              STR      r0,[r1,#0xc]
;;;119    
;;;120    	// microsecond timer
;;;121    	LPC_TIMER2->IR = 0;
00000e  4904              LDR      r1,|L11.32|
000010  6008              STR      r0,[r1,#0]
;;;122     	LPC_TIMER2->TCR = 1;
000012  2001              MOVS     r0,#1
000014  6048              STR      r0,[r1,#4]
;;;123    	LPC_TIMER2->PR = CLKFREQ_US-1;
000016  20cb              MOVS     r0,#0xcb
000018  60c8              STR      r0,[r1,#0xc]
;;;124    }
00001a  4770              BX       lr
;;;125    
                          ENDP

                  |L11.28|
                          DCD      0x40085000
                  |L11.32|
                          DCD      0x400c3000

                          AREA ||.ARM.exidx||, LINKORDER=||i._Z7ADCInitv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||i._Z7ADCInitv||
                          DCD      0x00000001

                          AREA ||area_number.13||, LINKORDER=||i._Z7SCTInitv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.13||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._Z7SCTInitv||
                          DCD      0x00000001

                          AREA ||area_number.14||, LINKORDER=||i._Z10CameraInitv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.14||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._Z10CameraInitv||
                          DCD      0x00000001

                          AREA ||area_number.15||, LINKORDER=||i._Z8GPIOInitv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.15||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._Z8GPIOInitv||
                          DCD      0x00000001

                          AREA ||area_number.16||, LINKORDER=||i._Z9timerInitv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.16||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._Z9timerInitv||
                          DCD      0x00000001

                          AREA ||area_number.17||, LINKORDER=||i._Z10commonInitv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.17||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._Z10commonInitv||
                          DCD      0x00000001

                          AREA ||area_number.18||, LINKORDER=||i._Z9handleAWBv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.18||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._Z9handleAWBv||
                          DCD      0x00000001

                          AREA ||area_number.19||, LINKORDER=||i._Z8periodicv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.19||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._Z8periodicv||
                          DCD      0x00000001

                          AREA ||area_number.20||, LINKORDER=||i._Z8pixyInitjPKhj||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.20||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._Z8pixyInitjPKhj||
                          DCD      0x00000001

                          AREA ||area_number.21||, LINKORDER=||i._Z14pixySimpleInitv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.21||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._Z14pixySimpleInitv||
                          DCD      0x00000001

                          AREA ||area_number.22||, LINKORDER=||i._Z7cprintfPKcz||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.22||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._Z7cprintfPKcz||
                          DCD      0x00000001

                          AREA ||.data||, DATA, ALIGN=2

                  g_chirpUsb
                          DCD      0x00000000
                  g_chirpM0
                          DCD      0x00000000
                  timer
                          DCD      0x00000000
                  state
00000c  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "pixy_init.cpp"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___13_pixy_init_cpp_9168d7b9___Z7__REV16j|
#line 130 ".\\core_cmInstr.h"
|__asm___13_pixy_init_cpp_9168d7b9___Z7__REV16j| PROC
#line 131

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___13_pixy_init_cpp_9168d7b9___Z7__REVSHi|
#line 144
|__asm___13_pixy_init_cpp_9168d7b9___Z7__REVSHi| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
