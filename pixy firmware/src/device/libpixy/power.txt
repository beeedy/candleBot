; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--cpp --list --split_sections --debug -c --asm --interleave -o.\power.o --asm_dir=.\ --list_dir=.\ --depend=.\power.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I. -I..\..\common -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=514 -DCORE_M4 -DIPC_MASTER -DPIXY --omf_browse=.\power.crf power.cpp]
                          THUMB

                          AREA ||i._Z10pwr_getVinv||, CODE, READONLY, ALIGN=1

                  _Z10pwr_getVinv PROC ; pwr_getVin()
;;;53     
;;;54     uint32_t pwr_getVin()
000000  b510              PUSH     {r4,lr}
;;;55     {
;;;56      	uint32_t vin;
;;;57     	
;;;58     	vin = adc_get(VIN_ADCCHAN)*10560/1024 + 330;  // 10560 = 3.3*3.2*1000, 330 is diode drop 
000002  2004              MOVS     r0,#4
000004  f7fffffe          BL       adc_get
000008  f44f5125          MOV      r1,#0x2940
00000c  4348              MULS     r0,r1,r0
00000e  1149              ASRS     r1,r1,#5
000010  eb012490          ADD      r4,r1,r0,LSR #10
;;;59     	
;;;60     	return vin; 
000014  4620              MOV      r0,r4
;;;61     }
000016  bd10              POP      {r4,pc}
;;;62     
                          ENDP


                          AREA ||i._Z11pwr_getVbusv||, CODE, READONLY, ALIGN=1

                  _Z11pwr_getVbusv PROC ; pwr_getVbus()
;;;71     
;;;72     uint32_t pwr_getVbus()
000000  b510              PUSH     {r4,lr}
;;;73     {
;;;74     	uint32_t vbus;
;;;75     	
;;;76     	vbus = adc_get(VBUS_ADCCHAN)*5293/1024;  // 5293=3.3*1.604*1000 
000002  2005              MOVS     r0,#5
000004  f7fffffe          BL       adc_get
000008  f24141ad          MOV      r1,#0x14ad
00000c  4348              MULS     r0,r1,r0
00000e  0a84              LSRS     r4,r0,#10
;;;77     	
;;;78     	return vbus; 
000010  4620              MOV      r0,r4
;;;79     }
000012  bd10              POP      {r4,pc}
;;;80     
                          ENDP


                          AREA ||i._Z14pwr_USBpoweredv||, CODE, READONLY, ALIGN=2

                  _Z14pwr_USBpoweredv PROC ; pwr_USBpowered()
;;;80     
;;;81     uint32_t pwr_USBpowered()
000000  4804              LDR      r0,|L3.20|
;;;82     {
;;;83     	if (LPC_GPIO_PORT->PIN[5]&0x0100)
000002  6940              LDR      r0,[r0,#0x14]
000004  f4007080          AND      r0,r0,#0x100
000008  b108              CBZ      r0,|L3.14|
;;;84     		return 1;
00000a  2001              MOVS     r0,#1
                  |L3.12|
;;;85     	else
;;;86     		return 0;
;;;87     }
00000c  4770              BX       lr
                  |L3.14|
00000e  2000              MOVS     r0,#0                 ;86
000010  e7fc              B        |L3.12|
;;;88     
                          ENDP

000012  0000              DCW      0x0000
                  |L3.20|
                          DCD      0x400f6100

                          AREA ||i._Z8pwr_initv||, CODE, READONLY, ALIGN=2

                  _Z8pwr_initv PROC ; pwr_init()
;;;88     
;;;89     void pwr_init()
000000  b510              PUSH     {r4,lr}
;;;90     {
;;;91      	LPC_GPIO_PORT->DIR[5] |= 0x0100;	 
000002  480f              LDR      r0,|L4.64|
000004  6940              LDR      r0,[r0,#0x14]
000006  f4407180          ORR      r1,r0,#0x100
00000a  480d              LDR      r0,|L4.64|
00000c  6141              STR      r1,[r0,#0x14]
;;;92     
;;;93     	// choose USB power or vin
;;;94     	if (pwr_getVin()>6430) // 6430=5000+1100(ldo)+330(diode) 
00000e  f7fffffe          BL       _Z10pwr_getVinv ; pwr_getVin()
000012  f641111e          MOV      r1,#0x191e
000016  4288              CMP      r0,r1
000018  d906              BLS      |L4.40|
;;;95      		LPC_GPIO_PORT->PIN[5] &= ~0x0100;
00001a  480a              LDR      r0,|L4.68|
00001c  6940              LDR      r0,[r0,#0x14]
00001e  f4207180          BIC      r1,r0,#0x100
000022  4808              LDR      r0,|L4.68|
000024  6141              STR      r1,[r0,#0x14]
000026  e005              B        |L4.52|
                  |L4.40|
;;;96     	else // switch usb on
;;;97     		LPC_GPIO_PORT->PIN[5] |= 0x0100;
000028  4806              LDR      r0,|L4.68|
00002a  6940              LDR      r0,[r0,#0x14]
00002c  f4407180          ORR      r1,r0,#0x100
000030  4804              LDR      r0,|L4.68|
000032  6141              STR      r1,[r0,#0x14]
                  |L4.52|
;;;98     
;;;99        	g_chirpUsb->registerModule(g_module);
000034  4904              LDR      r1,|L4.72|
000036  4805              LDR      r0,|L4.76|
000038  6800              LDR      r0,[r0,#0]  ; g_chirpUsb
00003a  f7fffffe          BL       _ZN5Chirp14registerModuleEPK10ProcModule ; Chirp::registerModule(const ProcModule*)
;;;100    }
00003e  bd10              POP      {r4,pc}
                          ENDP

                  |L4.64|
                          DCD      0x400f6000
                  |L4.68|
                          DCD      0x400f6100
                  |L4.72|
                          DCD      g_module
                  |L4.76|
                          DCD      g_chirpUsb

                          AREA ||i._Z9pwr_get5vv||, CODE, READONLY, ALIGN=1

                  _Z9pwr_get5vv PROC ; pwr_get5v()
;;;62     
;;;63     uint32_t pwr_get5v()
000000  b510              PUSH     {r4,lr}
;;;64     {
;;;65     	uint32_t v5;
;;;66     	
;;;67     	v5 = adc_get(V5_ADCCHAN)*5293/1024;  // 5293=3.3*1.604*1000 
000002  2003              MOVS     r0,#3
000004  f7fffffe          BL       adc_get
000008  f24141ad          MOV      r1,#0x14ad
00000c  4348              MULS     r0,r1,r0
00000e  0a84              LSRS     r4,r0,#10
;;;68     	
;;;69     	return v5; 
000010  4620              MOV      r0,r4
;;;70     }
000012  bd10              POP      {r4,pc}
;;;71     
                          ENDP


                          AREA ||.ARM.exidx||, LINKORDER=||i._Z10pwr_getVinv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||i._Z10pwr_getVinv||
                          DCD      0x00000001

                          AREA ||area_number.7||, LINKORDER=||i._Z9pwr_get5vv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.7||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._Z9pwr_get5vv||
                          DCD      0x00000001

                          AREA ||area_number.8||, LINKORDER=||i._Z11pwr_getVbusv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.8||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._Z11pwr_getVbusv||
                          DCD      0x00000001

                          AREA ||area_number.9||, LINKORDER=||i._Z14pwr_USBpoweredv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.9||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._Z14pwr_USBpoweredv||
                          DCD      0x00000001

                          AREA ||area_number.10||, LINKORDER=||i._Z8pwr_initv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.10||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._Z8pwr_initv||
                          DCD      0x00000001

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  g_module
                          DCD      ||.conststring||
                          DCD      _Z10pwr_getVinv ; pwr_getVin()
000008  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000
000010  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      ||.conststring||+0xc
                          DCD      ||.conststring||+0x3c
                          DCD      _Z9pwr_get5vv ; pwr_get5v()
000020  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000
000028  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      ||.conststring||+0x48
                          DCD      ||.conststring||+0x70
                          DCD      _Z11pwr_getVbusv ; pwr_getVbus()
000038  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000
000040  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      ||.conststring||+0x7c
                          DCD      ||.conststring||+0xac
                          DCD      _Z14pwr_USBpoweredv ; pwr_USBpowered()
000050  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000
000058  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      ||.conststring||+0xbc
                          DCD      0x00000000
                          DCD      0x00000000
                          %        8
000070  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  7077725f          DCB      "pwr_getVin",0
000004  67657456
000008  696e00  
00000b  00                DCB      0
00000c  47657420          DCB      "Get Vin (JP1) voltage@r voltage in millivolts",0
000010  56696e20
000014  284a5031
000018  2920766f
00001c  6c746167
000020  65407220
000024  766f6c74
000028  61676520
00002c  696e206d
000030  696c6c69
000034  766f6c74
000038  7300    
00003a  00                DCB      0
00003b  00                DCB      0
00003c  7077725f          DCB      "pwr_get5V",0
000040  67657435
000044  5600    
000046  00                DCB      0
000047  00                DCB      0
000048  47657420          DCB      "Get 5V voltage@r voltage in millivolts",0
00004c  35562076
000050  6f6c7461
000054  67654072
000058  20766f6c
00005c  74616765
000060  20696e20
000064  6d696c6c
000068  69766f6c
00006c  747300  
00006f  00                DCB      0
000070  7077725f          DCB      "pwr_getVbus",0
000074  67657456
000078  62757300
00007c  47657420          DCB      "Get USB VBUS voltage@r voltage in millivolts",0
000080  55534220
000084  56425553
000088  20766f6c
00008c  74616765
000090  40722076
000094  6f6c7461
000098  67652069
00009c  6e206d69
0000a0  6c6c6976
0000a4  6f6c7473
0000a8  00      
0000a9  00                DCB      0
0000aa  00                DCB      0
0000ab  00                DCB      0
0000ac  7077725f          DCB      "pwr_USBpowered",0
0000b0  55534270
0000b4  6f776572
0000b8  656400  
0000bb  00                DCB      0
0000bc  44657465          DCB      "Determine if camera power is from USB host.@r 0 if powe"
0000c0  726d696e
0000c4  65206966
0000c8  2063616d
0000cc  65726120
0000d0  706f7765
0000d4  72206973
0000d8  2066726f
0000dc  6d205553
0000e0  4220686f
0000e4  73742e40
0000e8  72203020
0000ec  69662070
0000f0  6f7765  
0000f3  72206973          DCB      "r is from Vin (JP1), nonzero if power is from USB",0
0000f7  2066726f
0000fb  6d205669
0000ff  6e20284a
000103  5031292c
000107  206e6f6e
00010b  7a65726f
00010f  20696620
000113  706f7765
000117  72206973
00011b  2066726f
00011f  6d205553
000123  4200    

;*** Start embedded assembler ***

#line 1 "power.cpp"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___9_power_cpp_7fde69b7___Z7__REV16j|
#line 130 ".\\core_cmInstr.h"
|__asm___9_power_cpp_7fde69b7___Z7__REV16j| PROC
#line 131

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___9_power_cpp_7fde69b7___Z7__REVSHi|
#line 144
|__asm___9_power_cpp_7fde69b7___Z7__REVSHi| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
