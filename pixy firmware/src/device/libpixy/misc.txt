; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--cpp --list --split_sections --debug -c --asm --interleave -o.\misc.o --asm_dir=.\ --list_dir=.\ --depend=.\misc.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I. -I..\..\common -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=514 -DCORE_M4 -DIPC_MASTER -DPIXY --omf_browse=.\misc.crf misc.cpp]
                          THUMB

                          AREA ||i.adc_get||, CODE, READONLY, ALIGN=2

                  adc_get PROC
;;;62     
;;;63     uint32_t adc_get(uint32_t channel)
000000  b570              PUSH     {r4-r6,lr}
;;;64     {
000002  4604              MOV      r4,r0
;;;65     	uint32_t res;
;;;66     
;;;67     	ADC_ChannelCmd(LPC_ADC0, channel, ENABLE);
000004  b2e1              UXTB     r1,r4
000006  2201              MOVS     r2,#1
000008  480f              LDR      r0,|L1.72|
00000a  f7fffffe          BL       ADC_ChannelCmd
;;;68     	delayus(500);
00000e  f44f70fa          MOV      r0,#0x1f4
000012  f7fffffe          BL       delayus
;;;69     	ADC_StartCmd(LPC_ADC0, ADC_START_NOW);
000016  2101              MOVS     r1,#1
000018  480b              LDR      r0,|L1.72|
00001a  f7fffffe          BL       ADC_StartCmd
;;;70     	while (!(ADC_ChannelGetStatus(LPC_ADC0, channel, ADC_DATA_DONE)));
00001e  bf00              NOP      
                  |L1.32|
000020  b2e1              UXTB     r1,r4
000022  2201              MOVS     r2,#1
000024  4808              LDR      r0,|L1.72|
000026  f7fffffe          BL       ADC_ChannelGetStatus
00002a  2800              CMP      r0,#0
00002c  d0f8              BEQ      |L1.32|
;;;71     	res = ADC_ChannelGetData(LPC_ADC0, channel);
00002e  b2e1              UXTB     r1,r4
000030  4805              LDR      r0,|L1.72|
000032  f7fffffe          BL       ADC_ChannelGetData
000036  4605              MOV      r5,r0
;;;72     	ADC_ChannelCmd(LPC_ADC0, channel, DISABLE);
000038  b2e1              UXTB     r1,r4
00003a  2200              MOVS     r2,#0
00003c  4802              LDR      r0,|L1.72|
00003e  f7fffffe          BL       ADC_ChannelCmd
;;;73     
;;;74     	return res;
000042  4628              MOV      r0,r5
;;;75     }
000044  bd70              POP      {r4-r6,pc}
;;;76     
                          ENDP

000046  0000              DCW      0x0000
                  |L1.72|
                          DCD      0x400e3000

                          AREA ||i.button||, CODE, READONLY, ALIGN=2

                  button PROC
;;;44     
;;;45     uint32_t button(void)
000000  b510              PUSH     {r4,lr}
;;;46     {
;;;47     	static uint32_t bPrev = 0;
;;;48     	uint32_t b;
;;;49     
;;;50     	b = LPC_GPIO_PORT->PIN[5] & (1<<7);
000002  480a              LDR      r0,|L2.44|
000004  6940              LDR      r0,[r0,#0x14]
000006  f0000480          AND      r4,r0,#0x80
;;;51     
;;;52     	// debounce	
;;;53     	if (b!=bPrev)
00000a  4809              LDR      r0,|L2.48|
00000c  6800              LDR      r0,[r0,#0]  ; bPrev
00000e  4284              CMP      r4,r0
000010  d007              BEQ      |L2.34|
;;;54     	{
;;;55     		delayus(2000);
000012  f44f60fa          MOV      r0,#0x7d0
000016  f7fffffe          BL       delayus
;;;56     		b = LPC_GPIO_PORT->PIN[5] & (1<<7);
00001a  4804              LDR      r0,|L2.44|
00001c  6940              LDR      r0,[r0,#0x14]
00001e  f0000480          AND      r4,r0,#0x80
                  |L2.34|
;;;57     	}
;;;58     	
;;;59     	bPrev = b;		 
000022  4803              LDR      r0,|L2.48|
000024  6004              STR      r4,[r0,#0]  ; bPrev
;;;60     	return b;
000026  4620              MOV      r0,r4
;;;61     }
000028  bd10              POP      {r4,pc}
;;;62     
                          ENDP

00002a  0000              DCW      0x0000
                  |L2.44|
                          DCD      0x400f6100
                  |L2.48|
                          DCD      bPrev

                          AREA ||i.delayms||, CODE, READONLY, ALIGN=1

                  delayms PROC
;;;32     
;;;33     void delayms(uint32_t ms)
000000  b508              PUSH     {r3,lr}
;;;34     {
000002  4603              MOV      r3,r0
;;;35     	uint32_t timer;
;;;36     	
;;;37     	setTimer(&timer);
000004  4668              MOV      r0,sp
000006  f7fffffe          BL       setTimer
;;;38     
;;;39     	ms *= 1000;
00000a  f44f707a          MOV      r0,#0x3e8
00000e  4343              MULS     r3,r0,r3
;;;40     	
;;;41     	while(getTimer(timer)<ms);
000010  bf00              NOP      
                  |L3.18|
000012  9800              LDR      r0,[sp,#0]
000014  f7fffffe          BL       getTimer
000018  4298              CMP      r0,r3
00001a  d3fa              BCC      |L3.18|
;;;42     }
00001c  bd08              POP      {r3,pc}
;;;43     
                          ENDP


                          AREA ||i.delayus||, CODE, READONLY, ALIGN=1

                  delayus PROC
;;;22     // can be called before timer is set up
;;;23     void delayus(uint32_t us)
000000  b508              PUSH     {r3,lr}
;;;24     {
000002  4603              MOV      r3,r0
;;;25     	uint32_t timer;
;;;26     	
;;;27     	setTimer(&timer);
000004  4668              MOV      r0,sp
000006  f7fffffe          BL       setTimer
;;;28     	
;;;29     	while(getTimer(timer)<us);
00000a  bf00              NOP      
                  |L4.12|
00000c  9800              LDR      r0,[sp,#0]
00000e  f7fffffe          BL       getTimer
000012  4298              CMP      r0,r3
000014  d3fa              BCC      |L4.12|
;;;30     }
000016  bd08              POP      {r3,pc}
;;;31     
                          ENDP


                          AREA ||i.getTimer||, CODE, READONLY, ALIGN=2

                  getTimer PROC
;;;81     
;;;82     uint32_t getTimer(uint32_t timer)
000000  4601              MOV      r1,r0
;;;83     {
;;;84     	uint32_t result; 
;;;85     	result = LPC_TIMER2->TC-timer;	
000002  4a02              LDR      r2,|L5.12|
000004  6892              LDR      r2,[r2,#8]
000006  1a50              SUBS     r0,r2,r1
;;;86     
;;;87     	return result;
;;;88     }
000008  4770              BX       lr
;;;89     
                          ENDP

00000a  0000              DCW      0x0000
                  |L5.12|
                          DCD      0x400c3000

                          AREA ||i.setTimer||, CODE, READONLY, ALIGN=2

                  setTimer PROC
;;;76     
;;;77     void setTimer(uint32_t *timer)
000000  4901              LDR      r1,|L6.8|
;;;78     {
;;;79     	*timer = LPC_TIMER2->TC;
000002  6889              LDR      r1,[r1,#8]
000004  6001              STR      r1,[r0,#0]
;;;80     }
000006  4770              BX       lr
;;;81     
                          ENDP

                  |L6.8|
                          DCD      0x400c3000

                          AREA ||i.showError||, CODE, READONLY, ALIGN=2

                  showError PROC
;;;89     
;;;90     void showError(uint8_t num, uint32_t color, const char *message)
000000  b577              PUSH     {r0-r2,r4-r6,lr}
;;;91     {
000002  b083              SUB      sp,sp,#0xc
000004  4605              MOV      r5,r0
000006  4614              MOV      r4,r2
;;;92     	int i;
;;;93     
;;;94     	while(1)
000008  e01d              B        |L7.70|
                  |L7.10|
;;;95     	{
;;;96     		// flash signal number
;;;97     		for (i=0; i<num; i++)
00000a  2600              MOVS     r6,#0
00000c  e012              B        |L7.52|
                  |L7.14|
;;;98     		{
;;;99     			led_set(color);
00000e  a804              ADD      r0,sp,#0x10
000010  f7fffffe          BL       _Z7led_setRKj ; led_set(const unsigned&)
;;;100    			delayus(150000);
000014  480c              LDR      r0,|L7.72|
000016  f7fffffe          BL       delayus
;;;101    			led_setRGB(0, 0, 0);
00001a  2000              MOVS     r0,#0
00001c  9002              STR      r0,[sp,#8]
00001e  9001              STR      r0,[sp,#4]
000020  466a              MOV      r2,sp
000022  a901              ADD      r1,sp,#4
000024  9000              STR      r0,[sp,#0]
000026  a802              ADD      r0,sp,#8
000028  f7fffffe          BL       _Z10led_setRGBRKhS0_S0_ ; led_setRGB(const unsigned char&, const unsigned char&, const unsigned char&)
;;;102    			delayus(150000);
00002c  4806              LDR      r0,|L7.72|
00002e  f7fffffe          BL       delayus
000032  1c76              ADDS     r6,r6,#1              ;97
                  |L7.52|
000034  42ae              CMP      r6,r5                 ;97
000036  dbea              BLT      |L7.14|
;;;103    		}
;;;104    		delayus(500000);
000038  4804              LDR      r0,|L7.76|
00003a  f7fffffe          BL       delayus
;;;105    		// print message
;;;106    		if (message)
00003e  b114              CBZ      r4,|L7.70|
;;;107    			lpc_printf(message);
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       lpc_printf
                  |L7.70|
000046  e7e0              B        |L7.10|
;;;108    	}
;;;109     }
                          ENDP

                  |L7.72|
                          DCD      0x000249f0
                  |L7.76|
                          DCD      0x0007a120

                          AREA ||.ARM.exidx||, LINKORDER=||i.getTimer||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||i.getTimer||
                          DCD      0x00000001

                          AREA ||area_number.9||, LINKORDER=||i.setTimer||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.9||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.setTimer||
                          DCD      0x00000001

                          AREA ||area_number.10||, LINKORDER=||i.delayus||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.10||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.delayus||
                          DCD      0x00000001

                          AREA ||area_number.11||, LINKORDER=||i.delayms||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.11||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.delayms||
                          DCD      0x00000001

                          AREA ||area_number.12||, LINKORDER=||i.button||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.12||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.button||
                          DCD      0x00000001

                          AREA ||area_number.13||, LINKORDER=||i.adc_get||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.13||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.adc_get||
                          DCD      0x00000001

                          AREA ||area_number.14||, LINKORDER=||i.showError||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.14||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.showError||
                          DCD      0x00000001

                          AREA ||.data||, DATA, ALIGN=2

                  bPrev
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "misc.cpp"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___8_misc_cpp_delayus___Z7__REV16j|
#line 130 ".\\core_cmInstr.h"
|__asm___8_misc_cpp_delayus___Z7__REV16j| PROC
#line 131

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___8_misc_cpp_delayus___Z7__REVSHi|
#line 144
|__asm___8_misc_cpp_delayus___Z7__REVSHi| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
