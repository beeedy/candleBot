; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--cpp --list --debug -c --asm --interleave -o.\spifi\blob.o --asm_dir=.\ --list_dir=.\ --depend=.\spifi\blob.d --cpu=Cortex-M4 --apcs=interwork -O0 --diag_suppress=9931 -I. -I..\libpixy -I..\..\common -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=514 -DCORE_M4 -DIPC_MASTER -DPIXY --omf_browse=.\spifi\blob.crf ..\..\common\blob.cpp]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  _ZN5CBlob5ResetEv PROC ; CBlob::Reset()
;;;131    void 
;;;132    CBlob::Reset() 
000000  b570              PUSH     {r4-r6,lr}
;;;133    {
000002  4604              MOV      r4,r0
;;;134        // Clear blob data
;;;135        moments.Reset();
000004  bf00              NOP      
000006  2000              MOVS     r0,#0
000008  6220              STR      r0,[r4,#0x20]
00000a  bf00              NOP      
;;;136    
;;;137        // Empty bounds
;;;138        right = -1;
00000c  1e40              SUBS     r0,r0,#1
00000e  82a0              STRH     r0,[r4,#0x14]
;;;139        left = top = 0x7fff;
000010  0c40              LSRS     r0,r0,#17
000012  8260              STRH     r0,[r4,#0x12]
000014  8220              STRH     r0,[r4,#0x10]
;;;140        lastBottom.row = lastBottom.invalid_row;
000016  1181              ASRS     r1,r0,#6
000018  88a0              LDRH     r0,[r4,#4]
00001a  f36100cb          BFI      r0,r1,#3,#9
00001e  80a0              STRH     r0,[r4,#4]
;;;141        nextBottom.row = nextBottom.invalid_row;
000020  8960              LDRH     r0,[r4,#0xa]
000022  f36100cb          BFI      r0,r1,#3,#9
000026  8160              STRH     r0,[r4,#0xa]
;;;142    
;;;143        // Delete segments if any
;;;144        SLinkedSegment *tmp;
;;;145        while(firstSegment!=NULL) {
000028  e005              B        |L1.54|
                  |L1.42|
;;;146            tmp = firstSegment;
00002a  69a5              LDR      r5,[r4,#0x18]
;;;147            firstSegment = tmp->next;
00002c  68a8              LDR      r0,[r5,#8]
00002e  61a0              STR      r0,[r4,#0x18]
;;;148            delete tmp;
000030  4628              MOV      r0,r5
000032  f7fffffe          BL       _ZdlPv ; operator delete (void*)
                  |L1.54|
000036  69a0              LDR      r0,[r4,#0x18]         ;145
000038  2800              CMP      r0,#0                 ;145
00003a  d1f6              BNE      |L1.42|
;;;149        }
;;;150        lastSegmentPtr= &firstSegment;
00003c  f1040018          ADD      r0,r4,#0x18
000040  61e0              STR      r0,[r4,#0x1c]
;;;151    }
000042  bd70              POP      {r4-r6,pc}
;;;152    
                          ENDP

                  _ZN5CBlobC2Ev                  ; Alternate entry point ; CBlob::CBlob__sub_object()
                  _ZN5CBlobC1Ev PROC ; CBlob::CBlob()
;;;112    // CBlob
;;;113    CBlob::CBlob() 
;;;114    {
;;;115        DBG_BLOB(leakcheck++);
;;;116        // Setup pointers
;;;117        firstSegment= NULL;
;;;118        lastSegmentPtr= &firstSegment;
;;;119    
;;;120        // Reset blob data
;;;121        Reset();
;;;122    }
;;;123    
000044  b510              PUSH     {r4,lr}
000046  4604              MOV      r4,r0
000048  2000              MOVS     r0,#0
00004a  61a0              STR      r0,[r4,#0x18]
00004c  f1040018          ADD      r0,r4,#0x18
000050  61e0              STR      r0,[r4,#0x1c]
000052  4620              MOV      r0,r4
000054  f7fffffe          BL       _ZN5CBlob5ResetEv ; CBlob::Reset()
000058  4620              MOV      r0,r4
00005a  bd10              POP      {r4,pc}
                          ENDP

                  _ZN5CBlobD2Ev                  ; Alternate entry point ; CBlob::~CBlob__sub_object()
                  _ZN5CBlobD1Ev PROC ; CBlob::~CBlob()
;;;124    CBlob::~CBlob() 
;;;125    {
;;;126        DBG_BLOB(leakcheck--);
;;;127        // Free segments, if any
;;;128        Reset();
;;;129    }
;;;130    
00005c  b510              PUSH     {r4,lr}
00005e  4604              MOV      r4,r0
000060  4620              MOV      r0,r4
000062  f7fffffe          BL       _ZN5CBlob5ResetEv ; CBlob::Reset()
000066  4620              MOV      r0,r4
000068  bd10              POP      {r4,pc}
                          ENDP

                  _ZN5CBlob6NewRowEv PROC ; CBlob::NewRow()
;;;153    void 
;;;154    CBlob::NewRow() 
00006a  8941              LDRH     r1,[r0,#0xa]
;;;155    {
;;;156        if (nextBottom.row != nextBottom.invalid_row) {
00006c  f3c101c8          UBFX     r1,r1,#3,#9
000070  f24012ff          MOV      r2,#0x1ff
000074  4291              CMP      r1,r2
000076  d008              BEQ      |L1.138|
;;;157            lastBottom= nextBottom;
000078  f8d0100a          LDR      r1,[r0,#0xa]
00007c  6041              STR      r1,[r0,#4]
00007e  89c1              LDRH     r1,[r0,#0xe]
000080  8101              STRH     r1,[r0,#8]
;;;158            nextBottom.row= nextBottom.invalid_row;
000082  8941              LDRH     r1,[r0,#0xa]
000084  f36201cb          BFI      r1,r2,#3,#9
000088  8141              STRH     r1,[r0,#0xa]
                  |L1.138|
;;;159        }
;;;160    }
00008a  4770              BX       lr
;;;161    
                          ENDP

                  _ZN5CBlob17UpdateBoundingBoxEiii PROC ; CBlob::UpdateBoundingBox(int, int, int)
;;;233    void 
;;;234    CBlob::UpdateBoundingBox(int newLeft, int newTop, int newRight) 
00008c  b510              PUSH     {r4,lr}
;;;235    {
;;;236        if (newLeft  < left ) left = newLeft;
00008e  f9b04010          LDRSH    r4,[r0,#0x10]
000092  428c              CMP      r4,r1
000094  dd01              BLE      |L1.154|
000096  b20c              SXTH     r4,r1
000098  8204              STRH     r4,[r0,#0x10]
                  |L1.154|
;;;237        if (newTop   < top  ) top  = newTop;
00009a  f9b04012          LDRSH    r4,[r0,#0x12]
00009e  4294              CMP      r4,r2
0000a0  dd01              BLE      |L1.166|
0000a2  b214              SXTH     r4,r2
0000a4  8244              STRH     r4,[r0,#0x12]
                  |L1.166|
;;;238        if (newRight > right) right= newRight;
0000a6  f9b04014          LDRSH    r4,[r0,#0x14]
0000aa  429c              CMP      r4,r3
0000ac  da01              BGE      |L1.178|
0000ae  b21c              SXTH     r4,r3
0000b0  8284              STRH     r4,[r0,#0x14]
                  |L1.178|
;;;239    }
0000b2  bd10              POP      {r4,pc}
;;;240    
                          ENDP

                  _ZN5CBlob3AddERK8SSegment PROC ; CBlob::Add(const SSegment&)
;;;162    void 
;;;163    CBlob::Add(const SSegment &segment) 
0000b4  b5f8              PUSH     {r3-r7,lr}
;;;164    {
0000b6  4604              MOV      r4,r0
0000b8  460d              MOV      r5,r1
;;;165        // Enlarge bounding box if necessary
;;;166        UpdateBoundingBox(segment.startCol, segment.row, segment.endCol);
0000ba  88a8              LDRH     r0,[r5,#4]
0000bc  f3c00309          UBFX     r3,r0,#0,#10
0000c0  8828              LDRH     r0,[r5,#0]
0000c2  f3c002c8          UBFX     r2,r0,#3,#9
0000c6  8868              LDRH     r0,[r5,#2]
0000c8  f3c00109          UBFX     r1,r0,#0,#10
0000cc  4620              MOV      r0,r4
0000ce  f7fffffe          BL       _ZN5CBlob17UpdateBoundingBoxEiii ; CBlob::UpdateBoundingBox(int, int, int)
;;;167    
;;;168        // Update next attachment "surface" at bottom of blob
;;;169        if (nextBottom.row == nextBottom.invalid_row) {
0000d2  8960              LDRH     r0,[r4,#0xa]
0000d4  f3c000c8          UBFX     r0,r0,#3,#9
0000d8  f24011ff          MOV      r1,#0x1ff
0000dc  4288              CMP      r0,r1
0000de  d105              BNE      |L1.236|
;;;170            // New row.
;;;171            nextBottom= segment;
0000e0  6828              LDR      r0,[r5,#0]
0000e2  f8c4000a          STR      r0,[r4,#0xa]
0000e6  88a8              LDRH     r0,[r5,#4]
0000e8  81e0              STRH     r0,[r4,#0xe]
0000ea  e003              B        |L1.244|
                  |L1.236|
;;;172        } else {
;;;173            // Same row.  Add to right side of nextBottom.
;;;174            nextBottom.endCol= segment.endCol;
0000ec  88a8              LDRH     r0,[r5,#4]
0000ee  f3c00009          UBFX     r0,r0,#0,#10
0000f2  81e0              STRH     r0,[r4,#0xe]
                  |L1.244|
;;;175        }
;;;176        
;;;177        SMoments segmentMoments;
;;;178        segment.GetMoments(segmentMoments);
0000f4  bf00              NOP      
0000f6  886a              LDRH     r2,[r5,#2]
0000f8  f3c20209          UBFX     r2,r2,#0,#10
0000fc  1e50              SUBS     r0,r2,#1
0000fe  88aa              LDRH     r2,[r5,#4]
000100  f3c20109          UBFX     r1,r2,#0,#10
000104  1a0a              SUBS     r2,r1,r0
000106  9200              STR      r2,[sp,#0]
000108  bf00              NOP      
;;;179        moments.Add(segmentMoments);
00010a  4669              MOV      r1,sp
00010c  f1040020          ADD      r0,r4,#0x20
000110  f7fffffe          BL       _ZN8SMoments3AddERKS_ ; SMoments::Add(const SMoments&)
;;;180    
;;;181        if (testMoments) {
;;;182    #ifdef INCLUDE_STATS
;;;183            SMoments test;
;;;184            segment.GetMomentsTest(test);
;;;185            assert(test == segmentMoments);
;;;186    #endif
;;;187        }
;;;188        if (recordSegments) {
000114  48fe              LDR      r0,|L1.1296|
000116  7800              LDRB     r0,[r0,#0]  ; _ZN5CBlob14recordSegmentsE
000118  b1d8              CBZ      r0,|L1.338|
;;;189            // Add segment to the _end_ of the linked list
;;;190            *lastSegmentPtr= new (std::nothrow) SLinkedSegment(segment);
00011a  49fe              LDR      r1,|L1.1300|
00011c  200c              MOVS     r0,#0xc
00011e  f7fffffe          BL       _ZnwjRKSt9nothrow_t ; operator new(unsigned, const std::nothrow_t&)
000122  0006              MOVS     r6,r0
000124  d009              BEQ      |L1.314|
000126  4630              MOV      r0,r6
000128  6829              LDR      r1,[r5,#0]
00012a  6001              STR      r1,[r0,#0]
00012c  88a9              LDRH     r1,[r5,#4]
00012e  8081              STRH     r1,[r0,#4]
000130  2100              MOVS     r1,#0
000132  6081              STR      r1,[r0,#8]
000134  bf00              NOP      
000136  4606              MOV      r6,r0
000138  e000              B        |L1.316|
                  |L1.314|
00013a  2000              MOVS     r0,#0
                  |L1.316|
00013c  69e1              LDR      r1,[r4,#0x1c]
00013e  6008              STR      r0,[r1,#0]
;;;191            if (*lastSegmentPtr==NULL)
000140  69e0              LDR      r0,[r4,#0x1c]
000142  6800              LDR      r0,[r0,#0]
000144  b900              CBNZ     r0,|L1.328|
                  |L1.326|
;;;192                return;
;;;193            lastSegmentPtr= &((*lastSegmentPtr)->next);
;;;194        }
;;;195    }
000146  bdf8              POP      {r3-r7,pc}
                  |L1.328|
000148  69e0              LDR      r0,[r4,#0x1c]         ;193
00014a  6800              LDR      r0,[r0,#0]            ;193
00014c  3008              ADDS     r0,r0,#8              ;193
00014e  61e0              STR      r0,[r4,#0x1c]         ;193
000150  bf00              NOP                            ;194
                  |L1.338|
000152  bf00              NOP      
000154  e7f7              B        |L1.326|
;;;196    
                          ENDP

                  _ZN5CBlob10AssimilateERS_ PROC ; CBlob::Assimilate(CBlob&)
;;;209    void 
;;;210    CBlob::Assimilate(CBlob &futileResister) 
000156  b570              PUSH     {r4-r6,lr}
;;;211    {
000158  4605              MOV      r5,r0
00015a  460c              MOV      r4,r1
;;;212        moments.Add(futileResister.moments);
00015c  f1040120          ADD      r1,r4,#0x20
000160  f1050020          ADD      r0,r5,#0x20
000164  f7fffffe          BL       _ZN8SMoments3AddERKS_ ; SMoments::Add(const SMoments&)
;;;213        UpdateBoundingBox(futileResister.left,
000168  f9b43014          LDRSH    r3,[r4,#0x14]
00016c  f9b42012          LDRSH    r2,[r4,#0x12]
000170  f9b41010          LDRSH    r1,[r4,#0x10]
000174  4628              MOV      r0,r5
000176  f7fffffe          BL       _ZN5CBlob17UpdateBoundingBoxEiii ; CBlob::UpdateBoundingBox(int, int, int)
;;;214                          futileResister.top,
;;;215                          futileResister.right);
;;;216        // Update lastBottom
;;;217        if (futileResister.lastBottom.endCol > lastBottom.endCol) {
00017a  8920              LDRH     r0,[r4,#8]
00017c  f3c00109          UBFX     r1,r0,#0,#10
000180  8928              LDRH     r0,[r5,#8]
000182  f3c00009          UBFX     r0,r0,#0,#10
000186  4281              CMP      r1,r0
000188  dd03              BLE      |L1.402|
;;;218            lastBottom.endCol= futileResister.lastBottom.endCol;
00018a  8920              LDRH     r0,[r4,#8]
00018c  f3c00009          UBFX     r0,r0,#0,#10
000190  8128              STRH     r0,[r5,#8]
                  |L1.402|
;;;219        }
;;;220        
;;;221        if (recordSegments) {
000192  48df              LDR      r0,|L1.1296|
000194  7800              LDRB     r0,[r0,#0]  ; _ZN5CBlob14recordSegmentsE
000196  b148              CBZ      r0,|L1.428|
;;;222            // Take segments from futileResister, append on end
;;;223            *lastSegmentPtr= futileResister.firstSegment;
000198  69a0              LDR      r0,[r4,#0x18]
00019a  69e9              LDR      r1,[r5,#0x1c]
00019c  6008              STR      r0,[r1,#0]
;;;224            lastSegmentPtr= futileResister.lastSegmentPtr;
00019e  69e0              LDR      r0,[r4,#0x1c]
0001a0  61e8              STR      r0,[r5,#0x1c]
;;;225            futileResister.firstSegment= NULL;
0001a2  2000              MOVS     r0,#0
0001a4  61a0              STR      r0,[r4,#0x18]
;;;226            futileResister.lastSegmentPtr= &futileResister.firstSegment;
0001a6  f1040018          ADD      r0,r4,#0x18
0001aa  61e0              STR      r0,[r4,#0x1c]
                  |L1.428|
;;;227            // Futile resister is left with no segments
;;;228        }
;;;229    }
0001ac  bd70              POP      {r4-r6,pc}
;;;230    
                          ENDP

                  _ZN14CBlobAssemblerC2Ev                  ; Alternate entry point ; CBlobAssembler::CBlobAssembler__sub_object()
                  _ZN14CBlobAssemblerC1Ev PROC ; CBlobAssembler::CBlobAssembler()
;;;243    
;;;244    CBlobAssembler::CBlobAssembler() 
;;;245    {
;;;246        activeBlobs= currentBlob= finishedBlobs= NULL;
;;;247        previousBlobPtr= &activeBlobs;
;;;248        currentRow=-1;
;;;249        maxRowDelta=1;
;;;250        m_blobCount=0;
;;;251    }
;;;252    
0001ae  2100              MOVS     r1,#0
0001b0  6101              STR      r1,[r0,#0x10]
0001b2  6081              STR      r1,[r0,#8]
0001b4  6041              STR      r1,[r0,#4]
0001b6  1d01              ADDS     r1,r0,#4
0001b8  60c1              STR      r1,[r0,#0xc]
0001ba  f04f31ff          MOV      r1,#0xffffffff
0001be  8001              STRH     r1,[r0,#0]
0001c0  2101              MOVS     r1,#1
0001c2  8281              STRH     r1,[r0,#0x14]
0001c4  2100              MOVS     r1,#0
0001c6  6181              STR      r1,[r0,#0x18]
0001c8  4770              BX       lr
                          ENDP

                  _ZN14CBlobAssembler5ResetEv PROC ; CBlobAssembler::Reset()
;;;466    
;;;467    void CBlobAssembler::Reset() {
0001ca  b570              PUSH     {r4-r6,lr}
0001cc  4604              MOV      r4,r0
;;;468        assert(!activeBlobs);
0001ce  6860              LDR      r0,[r4,#4]
0001d0  b900              CBNZ     r0,|L1.468|
0001d2  e005              B        |L1.480|
                  |L1.468|
0001d4  f44f72ea          MOV      r2,#0x1d4
0001d8  a1cf              ADR      r1,|L1.1304|
0001da  a0d5              ADR      r0,|L1.1328|
0001dc  f7fffffe          BL       __aeabi_assert
                  |L1.480|
;;;469        currentBlob= NULL;
0001e0  2000              MOVS     r0,#0
0001e2  60a0              STR      r0,[r4,#8]
;;;470        currentRow=-1;
0001e4  1e40              SUBS     r0,r0,#1
0001e6  8020              STRH     r0,[r4,#0]
;;;471        m_blobCount=0;
0001e8  2000              MOVS     r0,#0
0001ea  61a0              STR      r0,[r4,#0x18]
;;;472        while (finishedBlobs) {
0001ec  e00b              B        |L1.518|
                  |L1.494|
;;;473            CBlob *tmp= finishedBlobs->next;
0001ee  6920              LDR      r0,[r4,#0x10]
0001f0  6805              LDR      r5,[r0,#0]
;;;474            delete finishedBlobs;
0001f2  6920              LDR      r0,[r4,#0x10]
0001f4  b128              CBZ      r0,|L1.514|
0001f6  6920              LDR      r0,[r4,#0x10]
0001f8  f7fffffe          BL       _ZN5CBlobD1Ev ; CBlob::~CBlob()
0001fc  4606              MOV      r6,r0
0001fe  f7fffffe          BL       _ZdlPv ; operator delete (void*)
                  |L1.514|
;;;475            finishedBlobs= tmp;
000202  6125              STR      r5,[r4,#0x10]
;;;476        }
000204  bf00              NOP      
                  |L1.518|
000206  6920              LDR      r0,[r4,#0x10]
000208  2800              CMP      r0,#0
00020a  d1f0              BNE      |L1.494|
;;;477        DBG_BLOB(printf("after CBlobAssember::Reset, leakcheck=%d\n", CBlob::leakcheck));
;;;478    }
00020c  bd70              POP      {r4-r6,pc}
;;;479    
                          ENDP

                  _ZN14CBlobAssembler8EndFrameEv PROC ; CBlobAssembler::EndFrame()
;;;336    // Moves all active blobs to finished list
;;;337    void CBlobAssembler::EndFrame() {
00020e  b510              PUSH     {r4,lr}
000210  4603              MOV      r3,r0
;;;338        while (activeBlobs) {
000212  e00b              B        |L1.556|
                  |L1.532|
;;;339            activeBlobs->NewRow();
000214  6858              LDR      r0,[r3,#4]
000216  f7fffffe          BL       _ZN5CBlob6NewRowEv ; CBlob::NewRow()
;;;340            CBlob *tmp= activeBlobs->next;
00021a  6858              LDR      r0,[r3,#4]
00021c  6804              LDR      r4,[r0,#0]
;;;341            activeBlobs->next= finishedBlobs;
00021e  6859              LDR      r1,[r3,#4]
000220  6918              LDR      r0,[r3,#0x10]
000222  6008              STR      r0,[r1,#0]
;;;342            finishedBlobs= activeBlobs;
000224  6858              LDR      r0,[r3,#4]
000226  6118              STR      r0,[r3,#0x10]
;;;343            activeBlobs= tmp;
000228  605c              STR      r4,[r3,#4]
;;;344        }
00022a  bf00              NOP      
                  |L1.556|
00022c  6858              LDR      r0,[r3,#4]
00022e  2800              CMP      r0,#0
000230  d1f0              BNE      |L1.532|
;;;345    }
000232  bd10              POP      {r4,pc}
;;;346    
                          ENDP

                  _ZN14CBlobAssemblerD2Ev                  ; Alternate entry point ; CBlobAssembler::~CBlobAssembler__sub_object()
                  _ZN14CBlobAssemblerD1Ev PROC ; CBlobAssembler::~CBlobAssembler()
;;;252    
;;;253    CBlobAssembler::~CBlobAssembler() 
;;;254    {
;;;255        // Flush any active blobs into finished blobs
;;;256        EndFrame();
;;;257        // Free any finished blobs
;;;258        Reset();
;;;259    }
;;;260    
000234  b510              PUSH     {r4,lr}
000236  4604              MOV      r4,r0
000238  4620              MOV      r0,r4
00023a  f7fffffe          BL       _ZN14CBlobAssembler8EndFrameEv ; CBlobAssembler::EndFrame()
00023e  4620              MOV      r0,r4
000240  f7fffffe          BL       _ZN14CBlobAssembler5ResetEv ; CBlobAssembler::Reset()
000244  4620              MOV      r0,r4
000246  bd10              POP      {r4,pc}
                          ENDP

                  _ZN14CBlobAssembler10BlobNewRowEPP5CBlob PROC ; CBlobAssembler::BlobNewRow(CBlob**)
;;;504    void 
;;;505    CBlobAssembler::BlobNewRow(CBlob **ptr) 
000248  e92d41ff          PUSH     {r0-r8,lr}
;;;506    {
00024c  4605              MOV      r5,r0
00024e  460e              MOV      r6,r1
;;;507        short left, top, right, bottom;
;;;508    
;;;509        while (*ptr) {
000250  e031              B        |L1.694|
                  |L1.594|
;;;510            CBlob *blob= *ptr;
000252  6834              LDR      r4,[r6,#0]
;;;511            blob->NewRow();
000254  4620              MOV      r0,r4
000256  f7fffffe          BL       _ZN5CBlob6NewRowEv ; CBlob::NewRow()
;;;512            if (currentRow - blob->lastBottom.row > maxRowDelta) {
00025a  f9b50000          LDRSH    r0,[r5,#0]
00025e  88a1              LDRH     r1,[r4,#4]
000260  f3c101c8          UBFX     r1,r1,#3,#9
000264  1a40              SUBS     r0,r0,r1
000266  f9b51014          LDRSH    r1,[r5,#0x14]
00026a  4288              CMP      r0,r1
00026c  dd20              BLE      |L1.688|
;;;513                // Too many rows have elapsed.  Move it to the finished list
;;;514                *ptr= blob->next; // cut out of current list
00026e  6820              LDR      r0,[r4,#0]
000270  6030              STR      r0,[r6,#0]
;;;515                // check to see if it meets height and area constraints
;;;516                blob->getBBox(left, top, right, bottom);
000272  4668              MOV      r0,sp
000274  8a21              LDRH     r1,[r4,#0x10]
000276  9103              STR      r1,[sp,#0xc]
000278  8a61              LDRH     r1,[r4,#0x12]
00027a  9102              STR      r1,[sp,#8]
00027c  8aa1              LDRH     r1,[r4,#0x14]
00027e  9101              STR      r1,[sp,#4]
000280  88a1              LDRH     r1,[r4,#4]
000282  f3c101c8          UBFX     r1,r1,#3,#9
000286  8001              STRH     r1,[r0,#0]
000288  bf00              NOP      
;;;517                if (bottom-top>1) //&& blob->GetArea()>=MIN_COLOR_CODE_AREA)
00028a  f9bd0000          LDRSH    r0,[sp,#0]
00028e  f9bd1008          LDRSH    r1,[sp,#8]
000292  1a40              SUBS     r0,r0,r1
000294  2801              CMP      r0,#1
000296  dd03              BLE      |L1.672|
;;;518                {
;;;519                    // add to finished blobs
;;;520                    blob->next= finishedBlobs;
000298  6928              LDR      r0,[r5,#0x10]
00029a  6020              STR      r0,[r4,#0]
;;;521                    finishedBlobs= blob;
00029c  612c              STR      r4,[r5,#0x10]
00029e  e009              B        |L1.692|
                  |L1.672|
;;;522                }
;;;523                else
;;;524                    delete blob;
0002a0  b144              CBZ      r4,|L1.692|
0002a2  4620              MOV      r0,r4
0002a4  f7fffffe          BL       _ZN5CBlobD1Ev ; CBlob::~CBlob()
0002a8  4607              MOV      r7,r0
0002aa  f7fffffe          BL       _ZdlPv ; operator delete (void*)
0002ae  e001              B        |L1.692|
                  |L1.688|
;;;525            } else {
;;;526                // Blob is valid
;;;527                return;
;;;528            }
;;;529        }
;;;530    }
0002b0  e8bd81ff          POP      {r0-r8,pc}
                  |L1.692|
0002b4  bf00              NOP                            ;529
                  |L1.694|
0002b6  6830              LDR      r0,[r6,#0]            ;509
0002b8  2800              CMP      r0,#0                 ;509
0002ba  d1ca              BNE      |L1.594|
0002bc  bf00              NOP      
0002be  e7f7              B        |L1.688|
;;;531    
                          ENDP

                  _ZN14CBlobAssembler14AdvanceCurrentEv PROC ; CBlobAssembler::AdvanceCurrent()
;;;542    void 
;;;543    CBlobAssembler::AdvanceCurrent() 
0002c0  b510              PUSH     {r4,lr}
;;;544    {
0002c2  4604              MOV      r4,r0
;;;545        previousBlobPtr= &(currentBlob->next);
0002c4  68a0              LDR      r0,[r4,#8]
0002c6  60e0              STR      r0,[r4,#0xc]
;;;546        currentBlob= *previousBlobPtr;
0002c8  68e0              LDR      r0,[r4,#0xc]
0002ca  6800              LDR      r0,[r0,#0]
0002cc  60a0              STR      r0,[r4,#8]
;;;547        if (currentBlob) BlobNewRow(&currentBlob->next);
0002ce  68a0              LDR      r0,[r4,#8]
0002d0  b118              CBZ      r0,|L1.730|
0002d2  4620              MOV      r0,r4
0002d4  68a1              LDR      r1,[r4,#8]
0002d6  f7fffffe          BL       _ZN14CBlobAssembler10BlobNewRowEPP5CBlob ; CBlobAssembler::BlobNewRow(CBlob**)
                  |L1.730|
;;;548    }
0002da  bd10              POP      {r4,pc}
;;;549    
                          ENDP

                  _ZN14CBlobAssembler13RewindCurrentEv PROC ; CBlobAssembler::RewindCurrent()
;;;532    void 
;;;533    CBlobAssembler::RewindCurrent() 
0002dc  b510              PUSH     {r4,lr}
;;;534    {
0002de  4604              MOV      r4,r0
;;;535        BlobNewRow(&activeBlobs);
0002e0  1d21              ADDS     r1,r4,#4
0002e2  4620              MOV      r0,r4
0002e4  f7fffffe          BL       _ZN14CBlobAssembler10BlobNewRowEPP5CBlob ; CBlobAssembler::BlobNewRow(CBlob**)
;;;536        previousBlobPtr= &activeBlobs;
0002e8  1d20              ADDS     r0,r4,#4
0002ea  60e0              STR      r0,[r4,#0xc]
;;;537        currentBlob= *previousBlobPtr;
0002ec  68e0              LDR      r0,[r4,#0xc]
0002ee  6800              LDR      r0,[r0,#0]
0002f0  60a0              STR      r0,[r4,#8]
;;;538    
;;;539        if (currentBlob) BlobNewRow(&currentBlob->next);
0002f2  68a0              LDR      r0,[r4,#8]
0002f4  b118              CBZ      r0,|L1.766|
0002f6  4620              MOV      r0,r4
0002f8  68a1              LDR      r1,[r4,#8]
0002fa  f7fffffe          BL       _ZN14CBlobAssembler10BlobNewRowEPP5CBlob ; CBlobAssembler::BlobNewRow(CBlob**)
                  |L1.766|
;;;540    }
0002fe  bd10              POP      {r4,pc}
;;;541    
                          ENDP

                  _ZN14CBlobAssembler3AddERK8SSegment PROC ; CBlobAssembler::Add(const SSegment&)
;;;261    // Call once for each segment in the color channel
;;;262    int CBlobAssembler::Add(const SSegment &segment) {
000300  e92d47f0          PUSH     {r4-r10,lr}
000304  4604              MOV      r4,r0
000306  460d              MOV      r5,r1
;;;263        if (segment.row != currentRow) {
000308  8828              LDRH     r0,[r5,#0]
00030a  f3c000c8          UBFX     r0,r0,#3,#9
00030e  f9b41000          LDRSH    r1,[r4,#0]
000312  4288              CMP      r0,r1
000314  d006              BEQ      |L1.804|
;;;264            // Start new row
;;;265            currentRow= segment.row;
000316  8828              LDRH     r0,[r5,#0]
000318  f3c000c8          UBFX     r0,r0,#3,#9
00031c  8020              STRH     r0,[r4,#0]
;;;266            RewindCurrent();
00031e  4620              MOV      r0,r4
000320  f7fffffe          BL       _ZN14CBlobAssembler13RewindCurrentEv ; CBlobAssembler::RewindCurrent()
                  |L1.804|
;;;267        }
;;;268        
;;;269        // Try to link this to a previous blob
;;;270        while (currentBlob) {
000324  e040              B        |L1.936|
                  |L1.806|
;;;271            if (segment.startCol > currentBlob->lastBottom.endCol) {
000326  8868              LDRH     r0,[r5,#2]
000328  f3c00109          UBFX     r1,r0,#0,#10
00032c  68a0              LDR      r0,[r4,#8]
00032e  8900              LDRH     r0,[r0,#8]
000330  f3c00009          UBFX     r0,r0,#0,#10
000334  4281              CMP      r1,r0
000336  dd03              BLE      |L1.832|
;;;272                // Doesn't connect.  Keep searching more blobs to the right.
;;;273                AdvanceCurrent();
000338  4620              MOV      r0,r4
00033a  f7fffffe          BL       _ZN14CBlobAssembler14AdvanceCurrentEv ; CBlobAssembler::AdvanceCurrent()
00033e  e033              B        |L1.936|
                  |L1.832|
;;;274            } else {
;;;275                if (segment.endCol < currentBlob->lastBottom.startCol) {
000340  88a8              LDRH     r0,[r5,#4]
000342  f3c00109          UBFX     r1,r0,#0,#10
000346  68a0              LDR      r0,[r4,#8]
000348  88c0              LDRH     r0,[r0,#6]
00034a  f3c00009          UBFX     r0,r0,#0,#10
00034e  4281              CMP      r1,r0
000350  da00              BGE      |L1.852|
;;;276                    // Doesn't connect to any blob.  Stop searching.
;;;277                    break;
000352  e02c              B        |L1.942|
                  |L1.852|
;;;278                } else {
;;;279                    // Found a blob to connect to
;;;280                    currentBlob->Add(segment);
000354  4629              MOV      r1,r5
000356  68a0              LDR      r0,[r4,#8]
000358  f7fffffe          BL       _ZN5CBlob3AddERK8SSegment ; CBlob::Add(const SSegment&)
;;;281                    // Check to see if we attach to multiple blobs
;;;282                    while(currentBlob->next &&
00035c  e014              B        |L1.904|
                  |L1.862|
;;;283                          segment.endCol >= currentBlob->next->lastBottom.startCol) {
;;;284                        // Can merge the current blob with the next one,
;;;285                        // assimilate the next one and delete it.
;;;286    
;;;287                        // Uncomment this for verbose output for testing
;;;288                        // cout << "Merging blobs:" << endl
;;;289                        //     << " curr: bottom=" << currentBlob->bottom
;;;290                        //     << ", " << currentBlob->lastBottom.startCol
;;;291                        //     << " to " << currentBlob->lastBottom.endCol
;;;292                        //     << ", area " << currentBlob->moments.area << endl
;;;293                        //     << " next: bottom=" << currentBlob->next->bottom
;;;294                        //     << ", " << currentBlob->next->lastBottom.startCol
;;;295                        //     << " to " << currentBlob->next->lastBottom.endCol
;;;296                        //     << ", area " << currentBlob->next->moments.area << endl;
;;;297    
;;;298                        CBlob *futileResister = currentBlob->next;
00035e  68a0              LDR      r0,[r4,#8]
000360  6807              LDR      r7,[r0,#0]
;;;299                        // Cut it out of the list
;;;300                        currentBlob->next = futileResister->next;
000362  6838              LDR      r0,[r7,#0]
000364  68a1              LDR      r1,[r4,#8]
000366  6008              STR      r0,[r1,#0]
;;;301                        // Assimilate it's segments and moments
;;;302                        currentBlob->Assimilate(*(futileResister));
000368  4639              MOV      r1,r7
00036a  68a0              LDR      r0,[r4,#8]
00036c  f7fffffe          BL       _ZN5CBlob10AssimilateERS_ ; CBlob::Assimilate(CBlob&)
;;;303    
;;;304                        // Uncomment this for verbose output for testing
;;;305                        // cout << " NEW curr: bottom=" << currentBlob->bottom
;;;306                        //     << ", " << currentBlob->lastBottom.startCol
;;;307                        //     << " to " << currentBlob->lastBottom.endCol
;;;308                        //     << ", area " << currentBlob->moments.area << endl;
;;;309    
;;;310                        // Delete it
;;;311                        delete futileResister;
000370  b12f              CBZ      r7,|L1.894|
000372  4638              MOV      r0,r7
000374  f7fffffe          BL       _ZN5CBlobD1Ev ; CBlob::~CBlob()
000378  4681              MOV      r9,r0
00037a  f7fffffe          BL       _ZdlPv ; operator delete (void*)
                  |L1.894|
;;;312    
;;;313                        BlobNewRow(&currentBlob->next);
00037e  4620              MOV      r0,r4
000380  68a1              LDR      r1,[r4,#8]
000382  f7fffffe          BL       _ZN14CBlobAssembler10BlobNewRowEPP5CBlob ; CBlobAssembler::BlobNewRow(CBlob**)
;;;314                    }
000386  bf00              NOP      
                  |L1.904|
000388  68a0              LDR      r0,[r4,#8]            ;282
00038a  6800              LDR      r0,[r0,#0]            ;282
00038c  b148              CBZ      r0,|L1.930|
00038e  88a8              LDRH     r0,[r5,#4]            ;283
000390  f3c00109          UBFX     r1,r0,#0,#10          ;283
000394  68a0              LDR      r0,[r4,#8]            ;283
000396  6800              LDR      r0,[r0,#0]            ;283
000398  88c0              LDRH     r0,[r0,#6]            ;283
00039a  f3c00009          UBFX     r0,r0,#0,#10          ;283
00039e  4281              CMP      r1,r0                 ;283
0003a0  dadd              BGE      |L1.862|
                  |L1.930|
;;;315                    return 0;
0003a2  2000              MOVS     r0,#0
                  |L1.932|
;;;316                }
;;;317            }
;;;318        }
;;;319        
;;;320        // Could not attach to previous blob, insert new one before currentBlob
;;;321        CBlob *newBlob= new (std::nothrow) CBlob();
;;;322        if (newBlob==NULL)
;;;323        {
;;;324            DBG("blobs %d\nheap full", m_blobCount);
;;;325            return -1;
;;;326        }
;;;327        m_blobCount++;
;;;328        newBlob->next= currentBlob;
;;;329        *previousBlobPtr= newBlob;
;;;330        previousBlobPtr= &newBlob->next;
;;;331        newBlob->Add(segment);
;;;332        return 0;
;;;333    }
0003a4  e8bd87f0          POP      {r4-r10,pc}
                  |L1.936|
0003a8  68a0              LDR      r0,[r4,#8]            ;315
0003aa  2800              CMP      r0,#0                 ;315
0003ac  d1bb              BNE      |L1.806|
                  |L1.942|
0003ae  bf00              NOP                            ;277
0003b0  4958              LDR      r1,|L1.1300|
0003b2  2024              MOVS     r0,#0x24              ;321
0003b4  f7fffffe          BL       _ZnwjRKSt9nothrow_t ; operator new(unsigned, const std::nothrow_t&)
0003b8  ea5f0800          MOVS     r8,r0                 ;321
0003bc  d004              BEQ      |L1.968|
0003be  4640              MOV      r0,r8                 ;321
0003c0  f7fffffe          BL       _ZN5CBlobC1Ev ; CBlob::CBlob()
0003c4  4680              MOV      r8,r0                 ;321
0003c6  e000              B        |L1.970|
                  |L1.968|
0003c8  2000              MOVS     r0,#0                 ;321
                  |L1.970|
0003ca  4606              MOV      r6,r0                 ;321
0003cc  b94e              CBNZ     r6,|L1.994|
0003ce  485c              LDR      r0,|L1.1344|
0003d0  7800              LDRB     r0,[r0,#0]            ;324  ; g_debug
0003d2  b118              CBZ      r0,|L1.988|
0003d4  a05b              ADR      r0,|L1.1348|
0003d6  69a1              LDR      r1,[r4,#0x18]         ;324
0003d8  f7fffffe          BL       _Z7cprintfPKcz ; cprintf(const char*, ...)
                  |L1.988|
0003dc  f04f30ff          MOV      r0,#0xffffffff        ;325
0003e0  e7e0              B        |L1.932|
                  |L1.994|
0003e2  69a0              LDR      r0,[r4,#0x18]         ;327
0003e4  1c40              ADDS     r0,r0,#1              ;327
0003e6  61a0              STR      r0,[r4,#0x18]         ;327
0003e8  68a0              LDR      r0,[r4,#8]            ;328
0003ea  6030              STR      r0,[r6,#0]            ;328
0003ec  68e0              LDR      r0,[r4,#0xc]          ;329
0003ee  6006              STR      r6,[r0,#0]            ;329
0003f0  60e6              STR      r6,[r4,#0xc]          ;330
0003f2  4629              MOV      r1,r5                 ;331
0003f4  4630              MOV      r0,r6                 ;331
0003f6  f7fffffe          BL       _ZN5CBlob3AddERK8SSegment ; CBlob::Add(const SSegment&)
0003fa  2000              MOVS     r0,#0                 ;332
0003fc  e7d2              B        |L1.932|
;;;334    
                          ENDP

                  _ZN14CBlobAssembler10ListLengthEPK5CBlob PROC ; CBlobAssembler::ListLength(const CBlob*)
;;;346    
;;;347    int CBlobAssembler::ListLength(const CBlob *b) {
0003fe  4602              MOV      r2,r0
;;;348        int len= 0;
000400  2000              MOVS     r0,#0
;;;349        while (b) {
000402  e001              B        |L1.1032|
                  |L1.1028|
;;;350            len++;
000404  1c40              ADDS     r0,r0,#1
;;;351            b=b->next;
000406  6809              LDR      r1,[r1,#0]
                  |L1.1032|
000408  2900              CMP      r1,#0                 ;349
00040a  d1fb              BNE      |L1.1028|
;;;352        }
;;;353        return len;
;;;354    }
00040c  4770              BX       lr
;;;355    
                          ENDP

                  _ZN14CBlobAssembler9SplitListEP5CBlobRS1_S2_ PROC ; CBlobAssembler::SplitList(CBlob*, CBlob*&, CBlob*&)
;;;357    // Split a list of blobs into two halves
;;;358    void CBlobAssembler::SplitList(CBlob *all,
00040e  b570              PUSH     {r4-r6,lr}
;;;359                                   CBlob *&firstHalf, CBlob *&secondHalf) {
000410  4605              MOV      r5,r0
000412  4614              MOV      r4,r2
;;;360        firstHalf= secondHalf= all;
000414  6019              STR      r1,[r3,#0]
000416  6021              STR      r1,[r4,#0]
;;;361        CBlob *ptr= all, **nextptr= &secondHalf;
000418  4608              MOV      r0,r1
00041a  461a              MOV      r2,r3
;;;362        while (1) {
00041c  e008              B        |L1.1072|
                  |L1.1054|
;;;363            if (!ptr->next) break;
00041e  6806              LDR      r6,[r0,#0]
000420  b906              CBNZ     r6,|L1.1060|
000422  e006              B        |L1.1074|
                  |L1.1060|
;;;364            ptr= ptr->next;
000424  6800              LDR      r0,[r0,#0]
;;;365            nextptr= &(*nextptr)->next;
000426  6812              LDR      r2,[r2,#0]
;;;366            if (!ptr->next) break;
000428  6806              LDR      r6,[r0,#0]
00042a  b906              CBNZ     r6,|L1.1070|
00042c  e001              B        |L1.1074|
                  |L1.1070|
;;;367            ptr= ptr->next;
00042e  6800              LDR      r0,[r0,#0]
                  |L1.1072|
000430  e7f5              B        |L1.1054|
                  |L1.1074|
000432  bf00              NOP                            ;363
;;;368        }
;;;369        secondHalf= *nextptr;
000434  6816              LDR      r6,[r2,#0]
000436  601e              STR      r6,[r3,#0]
;;;370        *nextptr= NULL;
000438  2600              MOVS     r6,#0
00043a  6016              STR      r6,[r2,#0]
;;;371    }
00043c  bd70              POP      {r4-r6,pc}
;;;372    
                          ENDP

                  _ZN14CBlobAssembler10MergeListsERP5CBlobS2_RPS1_i PROC ; CBlobAssembler::MergeLists(CBlob*&, CBlob*&, CBlob**&, int)
;;;373    // Merge maxelts elements from old1 and old2 into newptr
;;;374    void CBlobAssembler::MergeLists(CBlob *&old1, CBlob *&old2,
00043e  b5f0              PUSH     {r4-r7,lr}
;;;375                                    CBlob **&newptr, int maxelts) {
000440  4606              MOV      r6,r0
000442  9d05              LDR      r5,[sp,#0x14]
;;;376        int n1= maxelts, n2= maxelts;
000444  462c              MOV      r4,r5
000446  4628              MOV      r0,r5
;;;377        while (1) {
000448  e038              B        |L1.1212|
                  |L1.1098|
;;;378            if (n1 && old1) {
00044a  b334              CBZ      r4,|L1.1178|
00044c  680f              LDR      r7,[r1,#0]
00044e  b327              CBZ      r7,|L1.1178|
;;;379                if (n2 && old2 && old2->moments.area > old1->moments.area) {
000450  b1b0              CBZ      r0,|L1.1152|
000452  6817              LDR      r7,[r2,#0]
000454  b1a7              CBZ      r7,|L1.1152|
000456  6817              LDR      r7,[r2,#0]
000458  6a3f              LDR      r7,[r7,#0x20]
00045a  f8d1c000          LDR      r12,[r1,#0]
00045e  f8dcc020          LDR      r12,[r12,#0x20]
000462  4567              CMP      r7,r12
000464  dd0c              BLE      |L1.1152|
;;;380                    // Choose old2
;;;381                    *newptr= old2;
000466  6817              LDR      r7,[r2,#0]
000468  f8d3c000          LDR      r12,[r3,#0]
00046c  f8cc7000          STR      r7,[r12,#0]
;;;382                    newptr= &(*newptr)->next;
000470  681f              LDR      r7,[r3,#0]
000472  683f              LDR      r7,[r7,#0]
000474  601f              STR      r7,[r3,#0]
;;;383                    old2= *newptr;
000476  681f              LDR      r7,[r3,#0]
000478  683f              LDR      r7,[r7,#0]
00047a  6017              STR      r7,[r2,#0]
;;;384                    --n2;
00047c  1e40              SUBS     r0,r0,#1
00047e  e01d              B        |L1.1212|
                  |L1.1152|
;;;385                } else {
;;;386                    // Choose old1
;;;387                    *newptr= old1;
000480  680f              LDR      r7,[r1,#0]
000482  f8d3c000          LDR      r12,[r3,#0]
000486  f8cc7000          STR      r7,[r12,#0]
;;;388                    newptr= &(*newptr)->next;
00048a  681f              LDR      r7,[r3,#0]
00048c  683f              LDR      r7,[r7,#0]
00048e  601f              STR      r7,[r3,#0]
;;;389                    old1= *newptr;
000490  681f              LDR      r7,[r3,#0]
000492  683f              LDR      r7,[r7,#0]
000494  600f              STR      r7,[r1,#0]
;;;390                    --n1;
000496  1e64              SUBS     r4,r4,#1
000498  e010              B        |L1.1212|
                  |L1.1178|
;;;391                }
;;;392            }
;;;393            else if (n2 && old2) {
00049a  b170              CBZ      r0,|L1.1210|
00049c  6817              LDR      r7,[r2,#0]
00049e  b167              CBZ      r7,|L1.1210|
;;;394                // Choose old2
;;;395                *newptr= old2;
0004a0  6817              LDR      r7,[r2,#0]
0004a2  f8d3c000          LDR      r12,[r3,#0]
0004a6  f8cc7000          STR      r7,[r12,#0]
;;;396                newptr= &(*newptr)->next;
0004aa  681f              LDR      r7,[r3,#0]
0004ac  683f              LDR      r7,[r7,#0]
0004ae  601f              STR      r7,[r3,#0]
;;;397                old2= *newptr;
0004b0  681f              LDR      r7,[r3,#0]
0004b2  683f              LDR      r7,[r7,#0]
0004b4  6017              STR      r7,[r2,#0]
;;;398                --n2;
0004b6  1e40              SUBS     r0,r0,#1
0004b8  e000              B        |L1.1212|
                  |L1.1210|
;;;399            } else {
;;;400                // Done
;;;401                return;
;;;402            }
;;;403        }
;;;404    }
0004ba  bdf0              POP      {r4-r7,pc}
                  |L1.1212|
0004bc  e7c5              B        |L1.1098|
;;;405    
                          ENDP

                  _ZN14CBlobAssembler12SortFinishedEv PROC ; CBlobAssembler::SortFinished()
;;;414    // merge sort (time n log n)
;;;415    void CBlobAssembler::SortFinished() {
0004be  b530              PUSH     {r4,r5,lr}
0004c0  b087              SUB      sp,sp,#0x1c
0004c2  4604              MOV      r4,r0
;;;416        // Divide finishedBlobs into two lists
;;;417        CBlob *old1, *old2;
;;;418    
;;;419        if(finishedBlobs == NULL) {
0004c4  6920              LDR      r0,[r4,#0x10]
0004c6  b908              CBNZ     r0,|L1.1228|
                  |L1.1224|
;;;420            return;
;;;421        }
;;;422    
;;;423        DBG_BLOB(int initial_len= ListLength(finishedBlobs));
;;;424        DBG_BLOB(printf("BSort: Start 0x%x, len=%d\n", finishedBlobs,
;;;425                   initial_len));
;;;426        SplitList(finishedBlobs, old1, old2);
;;;427    
;;;428        // First merge lists of length 1 into sorted lists of length 2
;;;429        // Next, merge sorted lists of length 2 into sorted lists of length 4
;;;430        // And so on.  Terminate when only one merge is performed, which
;;;431        // means we're completely sorted.
;;;432        
;;;433        for (int blocksize= 1; old2; blocksize <<= 1) {
;;;434            CBlob *new1=NULL, *new2=NULL, **newptr1= &new1, **newptr2= &new2;
;;;435            while (old1 || old2) {
;;;436                DBG_BLOB(printf("BSort: o1 0x%x, o2 0x%x, bs=%d\n",
;;;437                           old1, old2, blocksize));
;;;438                DBG_BLOB(printf("       n1 0x%x, n2 0x%x\n",
;;;439                           new1, new2));
;;;440                MergeLists(old1, old2, newptr1, blocksize);
;;;441                MergeLists(old1, old2, newptr2, blocksize);
;;;442            }
;;;443            *newptr1= *newptr2= NULL; // Terminate lists
;;;444            old1= new1;
;;;445            old2= new2;
;;;446        }
;;;447        finishedBlobs= old1;
;;;448        DBG_BLOB(AssertFinishedSorted());
;;;449        DBG_BLOB(int final_len= ListLength(finishedBlobs));
;;;450        DBG_BLOB(printf("BSort: DONE  0x%x, len=%d\n", finishedBlobs,
;;;451                   ListLength(finishedBlobs)));
;;;452        DBG_BLOB(if (final_len != initial_len) len_error());
;;;453    }
0004c8  b007              ADD      sp,sp,#0x1c
0004ca  bd30              POP      {r4,r5,pc}
                  |L1.1228|
0004cc  ab05              ADD      r3,sp,#0x14           ;426
0004ce  aa06              ADD      r2,sp,#0x18           ;426
0004d0  4620              MOV      r0,r4                 ;426
0004d2  6921              LDR      r1,[r4,#0x10]         ;426
0004d4  f7fffffe          BL       _ZN14CBlobAssembler9SplitListEP5CBlobRS1_S2_ ; CBlobAssembler::SplitList(CBlob*, CBlob*&, CBlob*&)
0004d8  2501              MOVS     r5,#1                 ;433
0004da  e049              B        |L1.1392|
                  |L1.1244|
0004dc  2000              MOVS     r0,#0                 ;434
0004de  9004              STR      r0,[sp,#0x10]         ;434
0004e0  9003              STR      r0,[sp,#0xc]          ;434
0004e2  a804              ADD      r0,sp,#0x10           ;434
0004e4  9002              STR      r0,[sp,#8]            ;434
0004e6  a803              ADD      r0,sp,#0xc            ;434
0004e8  9001              STR      r0,[sp,#4]            ;434
0004ea  e00d              B        |L1.1288|
                  |L1.1260|
0004ec  ab02              ADD      r3,sp,#8              ;440
0004ee  aa05              ADD      r2,sp,#0x14           ;440
0004f0  a906              ADD      r1,sp,#0x18           ;440
0004f2  4620              MOV      r0,r4                 ;440
0004f4  9500              STR      r5,[sp,#0]            ;440
0004f6  f7fffffe          BL       _ZN14CBlobAssembler10MergeListsERP5CBlobS2_RPS1_i ; CBlobAssembler::MergeLists(CBlob*&, CBlob*&, CBlob**&, int)
0004fa  ab01              ADD      r3,sp,#4              ;441
0004fc  aa05              ADD      r2,sp,#0x14           ;441
0004fe  a906              ADD      r1,sp,#0x18           ;441
000500  4620              MOV      r0,r4                 ;441
000502  9500              STR      r5,[sp,#0]            ;441
000504  f7fffffe          BL       _ZN14CBlobAssembler10MergeListsERP5CBlobS2_RPS1_i ; CBlobAssembler::MergeLists(CBlob*&, CBlob*&, CBlob**&, int)
                  |L1.1288|
000508  9806              LDR      r0,[sp,#0x18]         ;435
00050a  2800              CMP      r0,#0                 ;435
00050c  d1ee              BNE      |L1.1260|
00050e  e023              B        |L1.1368|
                  |L1.1296|
                          DCD      _ZN5CBlob14recordSegmentsE ; CBlob::recordSegments
                  |L1.1300|
                          DCD      _ZSt7nothrow ; std::nothrow
                  |L1.1304|
000518  2e2e5c2e          DCB      "..\\..\\common\\blob.cpp",0
00051c  2e5c636f
000520  6d6d6f6e
000524  5c626c6f
000528  622e6370
00052c  7000    
00052e  00                DCB      0
00052f  00                DCB      0
                  |L1.1328|
000530  21616374          DCB      "!activeBlobs",0
000534  69766542
000538  6c6f6273
00053c  00      
00053d  00                DCB      0
00053e  00                DCB      0
00053f  00                DCB      0
                  |L1.1344|
                          DCD      g_debug
                  |L1.1348|
000544  626c6f62          DCB      "blobs %d\nheap full",0
000548  73202564
00054c  0a686561
000550  70206675
000554  6c6c00  
000557  00                DCB      0
                  |L1.1368|
000558  9805              LDR      r0,[sp,#0x14]         ;435
00055a  2800              CMP      r0,#0                 ;435
00055c  d1c6              BNE      |L1.1260|
00055e  9901              LDR      r1,[sp,#4]            ;443
000560  6008              STR      r0,[r1,#0]            ;443
000562  9902              LDR      r1,[sp,#8]            ;443
000564  6008              STR      r0,[r1,#0]            ;443
000566  9804              LDR      r0,[sp,#0x10]         ;444
000568  9006              STR      r0,[sp,#0x18]         ;444
00056a  9803              LDR      r0,[sp,#0xc]          ;445
00056c  9005              STR      r0,[sp,#0x14]         ;445
00056e  006d              LSLS     r5,r5,#1              ;433
                  |L1.1392|
000570  9805              LDR      r0,[sp,#0x14]         ;433
000572  2800              CMP      r0,#0                 ;433
000574  d1b2              BNE      |L1.1244|
000576  9806              LDR      r0,[sp,#0x18]         ;447
000578  6120              STR      r0,[r4,#0x10]         ;447
00057a  bf00              NOP      
00057c  e7a4              B        |L1.1224|
;;;454    
                          ENDP

                  _ZN14CBlobAssembler20AssertFinishedSortedEv PROC ; CBlobAssembler::AssertFinishedSorted()
;;;455    // Assert that finishedBlobs is in fact sorted.  For testing only.
;;;456    void CBlobAssembler::AssertFinishedSorted() {
00057e  b570              PUSH     {r4-r6,lr}
000580  4606              MOV      r6,r0
;;;457        if (!finishedBlobs) return;
000582  6930              LDR      r0,[r6,#0x10]
000584  b900              CBNZ     r0,|L1.1416|
                  |L1.1414|
;;;458        CBlob *i= finishedBlobs;
;;;459        CBlob *j= i->next;
;;;460        while (j) {
;;;461            assert(i->moments.area >= j->moments.area);
;;;462            i= j;
;;;463            j= i->next;
;;;464        }
;;;465    }
000586  bd70              POP      {r4-r6,pc}
                  |L1.1416|
000588  6935              LDR      r5,[r6,#0x10]         ;458
00058a  682c              LDR      r4,[r5,#0]            ;459
00058c  e00d              B        |L1.1450|
                  |L1.1422|
00058e  6a28              LDR      r0,[r5,#0x20]         ;461
000590  6a21              LDR      r1,[r4,#0x20]         ;461
000592  4288              CMP      r0,r1                 ;461
000594  db00              BLT      |L1.1432|
000596  e006              B        |L1.1446|
                  |L1.1432|
000598  f24012cd          MOV      r2,#0x1cd             ;461
00059c  f2af0188          ADR      r1,|L1.1304|
0005a0  a004              ADR      r0,|L1.1460|
0005a2  f7fffffe          BL       __aeabi_assert
                  |L1.1446|
0005a6  4625              MOV      r5,r4                 ;462
0005a8  682c              LDR      r4,[r5,#0]            ;463
                  |L1.1450|
0005aa  2c00              CMP      r4,#0                 ;460
0005ac  d1ef              BNE      |L1.1422|
0005ae  bf00              NOP      
0005b0  e7e9              B        |L1.1414|
;;;466    
                          ENDP

0005b2  0000              DCW      0x0000
                  |L1.1460|
0005b4  692d3e6d          DCB      "i->moments.area >= j->moments.area",0
0005b8  6f6d656e
0005bc  74732e61
0005c0  72656120
0005c4  3e3d206a
0005c8  2d3e6d6f
0005cc  6d656e74
0005d0  732e6172
0005d4  656100  
0005d7  00                DCB      0

                          AREA ||.ARM.exidx||, LINKORDER=||.text||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||.text||
                          DCD      0x00000001

                          AREA ||.data||, DATA, ALIGN=2

                  _ZN8SMoments11computeAxesE ; SMoments::computeAxes
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  _ZN5CBlob9leakcheckE ; CBlob::leakcheck
                          DCD      0x00000000
                  _ZN5CBlob14recordSegmentsE ; CBlob::recordSegments
000008  00                DCB      0x00
                  _ZN5CBlob11testMomentsE ; CBlob::testMoments
000009  00                DCB      0x00

                          AREA ||i._ZN8SMoments3AddERKS_||, COMGROUP=_ZN8SMoments3AddERKS_, CODE, READONLY, ALIGN=1

                  _ZN8SMoments3AddERKS_ PROC ; SMoments::Add(const SMoments&)
;;;100    #endif
;;;101        void Add(const SMoments &moments) {
000000  6802              LDR      r2,[r0,#0]
;;;102            area += moments.area;
000002  680b              LDR      r3,[r1,#0]
000004  441a              ADD      r2,r2,r3
000006  6002              STR      r2,[r0,#0]
;;;103    #ifdef INCLUDE_STATS
;;;104            sumX += moments.sumX;
;;;105            sumY += moments.sumY;
;;;106            if (computeAxes) {
;;;107                sumXX += moments.sumXX;
;;;108                sumYY += moments.sumYY;
;;;109                sumXY += moments.sumXY;
;;;110            }
;;;111    #endif
;;;112        }
000008  4770              BX       lr
;;;113    #ifdef INCLUDE_STATS
                          ENDP


                          AREA ||area_number.16||, COMGROUP=_ZN8SMoments3AddERKS_, LINKORDER=||i._ZN8SMoments3AddERKS_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.16||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN8SMoments3AddERKS_||
                          DCD      0x00000001

;*** Start embedded assembler ***

#line 1 "..\\..\\common\\blob.cpp"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___8_blob_cpp_421c5bba___Z7__REV16j|
#line 130 "..\\libpixy\\core_cmInstr.h"
|__asm___8_blob_cpp_421c5bba___Z7__REV16j| PROC
#line 131

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___8_blob_cpp_421c5bba___Z7__REVSHi|
#line 144
|__asm___8_blob_cpp_421c5bba___Z7__REVSHi| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
