; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--cpp --list --debug -c --asm --interleave -o.\spifi\uart.o --asm_dir=.\ --list_dir=.\ --depend=.\spifi\uart.d --cpu=Cortex-M4 --apcs=interwork -O0 --diag_suppress=9931 -I. -I..\libpixy -I..\..\common -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=514 -DCORE_M4 -DIPC_MASTER -DPIXY --omf_browse=.\spifi\uart.crf ..\libpixy\uart.cpp]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  _ZN4Uart10irqHandlerEv PROC ; Uart::irqHandler()
;;;30     
;;;31     void Uart::irqHandler()
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;32     {
000004  4604              MOV      r4,r0
;;;33     	uint32_t status;
;;;34     	uint8_t i, c;
;;;35     	volatile uint32_t v;
;;;36     
;;;37     	m_flag = false;
000006  2000              MOVS     r0,#0
000008  f8840034          STRB     r0,[r4,#0x34]
;;;38     
;;;39     	/* Determine the interrupt source */
;;;40     	status = m_uart->IIR & UART_IIR_INTID_MASK;
00000c  6860              LDR      r0,[r4,#4]
00000e  6880              LDR      r0,[r0,#8]
000010  f000060e          AND      r6,r0,#0xe
;;;41     
;;;42     	if (status==UART_IIR_INTID_RDA) { /* Receive Data Available */
000014  2e04              CMP      r6,#4
000016  d123              BNE      |L1.96|
;;;43     		UART_DATA_AVAILABLE = m_uart->RBR&UART_RBR_MASKBIT;
000018  6860              LDR      r0,[r4,#4]
00001a  6800              LDR      r0,[r0,#0]
00001c  49ac              LDR      r1,|L1.720|
00001e  7008              STRB     r0,[r1,#0]
;;;44     		m_rq.write(m_uart->RBR&UART_RBR_MASKBIT);
000020  f1040508          ADD      r5,r4,#8
000024  6860              LDR      r0,[r4,#4]
000026  6800              LDR      r0,[r0,#0]
000028  f00008ff          AND      r8,r0,#0xff
00002c  bf00              NOP      
00002e  4628              MOV      r0,r5
000030  f7fffffe          BL       _ZN8ReceiveQIhE10receiveLenEv ; ReceiveQ<unsigned char>::receiveLen()
000034  6829              LDR      r1,[r5,#0]
000036  1a08              SUBS     r0,r1,r0
000038  2800              CMP      r0,#0
00003a  dc00              BGT      |L1.62|
00003c  e00f              B        |L1.94|
                  |L1.62|
00003e  68e9              LDR      r1,[r5,#0xc]
000040  1c48              ADDS     r0,r1,#1
000042  60e8              STR      r0,[r5,#0xc]
000044  6868              LDR      r0,[r5,#4]
000046  f8008001          STRB     r8,[r0,r1]
00004a  6928              LDR      r0,[r5,#0x10]
00004c  1c40              ADDS     r0,r0,#1
00004e  6128              STR      r0,[r5,#0x10]
000050  6829              LDR      r1,[r5,#0]
000052  68e8              LDR      r0,[r5,#0xc]
000054  4288              CMP      r0,r1
000056  d101              BNE      |L1.92|
000058  2000              MOVS     r0,#0
00005a  60e8              STR      r0,[r5,#0xc]
                  |L1.92|
00005c  bf00              NOP      
                  |L1.94|
00005e  e02d              B        |L1.188|
                  |L1.96|
;;;45     	}
;;;46     	else if (status==UART_IIR_INTID_CTI)
000060  2e0c              CMP      r6,#0xc
000062  d103              BNE      |L1.108|
;;;47     		v = m_uart->RBR; // toss...
000064  6860              LDR      r0,[r4,#4]
000066  6800              LDR      r0,[r0,#0]
000068  9000              STR      r0,[sp,#0]
00006a  e027              B        |L1.188|
                  |L1.108|
;;;48     	else if (status==UART_IIR_INTID_THRE) // Transmit Holding Empty
00006c  2e02              CMP      r6,#2
00006e  d125              BNE      |L1.188|
;;;49     	{
;;;50     		for (i=0; i<UART_TX_FIFO_SIZE; i++) // fill transmit FIFO
000070  2700              MOVS     r7,#0
000072  e021              B        |L1.184|
                  |L1.116|
;;;51     		{
;;;52     			if (m_tq.read(&c))
000074  bf00              NOP      
000076  6ae0              LDR      r0,[r4,#0x2c]
000078  b950              CBNZ     r0,|L1.144|
00007a  6b22              LDR      r2,[r4,#0x30]
00007c  e9d41008          LDRD     r1,r0,[r4,#0x20]
000080  4790              BLX      r2
000082  62e0              STR      r0,[r4,#0x2c]
000084  6ae0              LDR      r0,[r4,#0x2c]
000086  b908              CBNZ     r0,|L1.140|
000088  2000              MOVS     r0,#0
00008a  e00b              B        |L1.164|
                  |L1.140|
00008c  2000              MOVS     r0,#0
00008e  62a0              STR      r0,[r4,#0x28]
                  |L1.144|
000090  6aa1              LDR      r1,[r4,#0x28]
000092  1c48              ADDS     r0,r1,#1
000094  62a0              STR      r0,[r4,#0x28]
000096  6a60              LDR      r0,[r4,#0x24]
000098  5c40              LDRB     r0,[r0,r1]
00009a  9001              STR      r0,[sp,#4]
00009c  6ae0              LDR      r0,[r4,#0x2c]
00009e  1e40              SUBS     r0,r0,#1
0000a0  62e0              STR      r0,[r4,#0x2c]
0000a2  2001              MOVS     r0,#1
                  |L1.164|
0000a4  b130              CBZ      r0,|L1.180|
;;;53     			{
;;;54     				m_flag = true;
0000a6  2001              MOVS     r0,#1
0000a8  f8840034          STRB     r0,[r4,#0x34]
;;;55     				m_uart->THR = c;
0000ac  f89d0004          LDRB     r0,[sp,#4]
0000b0  6861              LDR      r1,[r4,#4]
0000b2  6008              STR      r0,[r1,#0]
                  |L1.180|
0000b4  1c78              ADDS     r0,r7,#1              ;50
0000b6  b2c7              UXTB     r7,r0                 ;50
                  |L1.184|
0000b8  2f10              CMP      r7,#0x10              ;50
0000ba  dbdb              BLT      |L1.116|
                  |L1.188|
;;;56     			}
;;;57     		}
;;;58     	}
;;;59     }
0000bc  e8bd81fc          POP      {r2-r8,pc}
;;;60     
                          ENDP

                  UART0_IRQHandler PROC
;;;25     
;;;26     void UART0_IRQHandler(void)
0000c0  b510              PUSH     {r4,lr}
;;;27     {
;;;28     	g_uart0->irqHandler();
0000c2  4884              LDR      r0,|L1.724|
0000c4  6800              LDR      r0,[r0,#0]  ; g_uart0
0000c6  f7fffffe          BL       _ZN4Uart10irqHandlerEv ; Uart::irqHandler()
;;;29     }
0000ca  bd10              POP      {r4,pc}
;;;30     
                          ENDP

                  _ZN4UartC2EP15LPC_USARTn_TypePFjPhjE                  ; Alternate entry point ; Uart::Uart__sub_object(LPC_USARTn_Type*, unsigned(*)(unsigned char*, unsigned))
                  _ZN4UartC1EP15LPC_USARTn_TypePFjPhjE PROC ; Uart::Uart(LPC_USARTn_Type*, unsigned(*)(unsigned char*, unsigned))
;;;109    
;;;110    Uart::Uart(LPC_USARTn_Type *uart,  SerialCallback callback) : m_rq(UART_RECEIVE_BUF_SIZE), m_tq(UART_TRANSMIT_BUF_SIZE, callback)
;;;111    {
;;;112    	UART_FIFO_CFG_Type ufifo;
;;;113    	UART_CFG_Type ucfg;
;;;114    
;;;115    	m_uart = uart;
;;;116    	m_flag = false;
;;;117    	 	
;;;118    	// regular config			 
;;;119    	ucfg.Baud_rate = UART_DEFAULT_BAUDRATE;
;;;120    	ucfg.Databits = UART_DATABIT_8;
;;;121    	ucfg.Parity = UART_PARITY_NONE;
;;;122    	ucfg.Stopbits = UART_STOPBIT_1;
;;;123    	ucfg.Clock_Speed = CLKFREQ;
;;;124    
;;;125    	UART_Init(m_uart, &ucfg);
;;;126    
;;;127    	// config FIFOs
;;;128    	ufifo.FIFO_DMAMode = DISABLE;
;;;129    	ufifo.FIFO_Level = UART_FIFO_TRGLEV0;
;;;130    	ufifo.FIFO_ResetRxBuf = ENABLE;
;;;131    	ufifo.FIFO_ResetTxBuf = ENABLE;
;;;132    
;;;133    	UART_FIFOConfig(m_uart, &ufifo);
;;;134    	UART_TxCmd(m_uart, ENABLE);
;;;135    
;;;136    	// enable interrupts
;;;137    	UART_IntConfig(m_uart, UART_INTCFG_RBR, ENABLE);
;;;138    	UART_IntConfig(m_uart, UART_INTCFG_THRE, ENABLE);
;;;139    
;;;140        NVIC_SetPriority(USART0_IRQn, 0);
;;;141    }
;;;142    
0000cc  e92d41ff          PUSH     {r0-r8,lr}
0000d0  4604              MOV      r4,r0
0000d2  460f              MOV      r7,r1
0000d4  4616              MOV      r6,r2
0000d6  4980              LDR      r1,|L1.728|
0000d8  4880              LDR      r0,|L1.732|
0000da  6020              STR      r0,[r4,#0]
0000dc  f1040508          ADD      r5,r4,#8
0000e0  f04f0820          MOV      r8,#0x20
0000e4  f8c58000          STR      r8,[r5,#0]
0000e8  6828              LDR      r0,[r5,#0]
0000ea  f7fffffe          BL       _Znaj ; operator new[] (unsigned)
0000ee  6068              STR      r0,[r5,#4]
0000f0  2000              MOVS     r0,#0
0000f2  60a8              STR      r0,[r5,#8]
0000f4  60e8              STR      r0,[r5,#0xc]
0000f6  6128              STR      r0,[r5,#0x10]
0000f8  6168              STR      r0,[r5,#0x14]
0000fa  bf00              NOP      
0000fc  f1a50408          SUB      r4,r5,#8
000100  f1040520          ADD      r5,r4,#0x20
000104  f8c58000          STR      r8,[r5,#0]
000108  6828              LDR      r0,[r5,#0]
00010a  f7fffffe          BL       _Znaj ; operator new[] (unsigned)
00010e  6068              STR      r0,[r5,#4]
000110  2000              MOVS     r0,#0
000112  60a8              STR      r0,[r5,#8]
000114  60e8              STR      r0,[r5,#0xc]
000116  612e              STR      r6,[r5,#0x10]
000118  bf00              NOP      
00011a  f1a50420          SUB      r4,r5,#0x20
00011e  6067              STR      r7,[r4,#4]
000120  f8840034          STRB     r0,[r4,#0x34]
000124  f44f4096          MOV      r0,#0x4b00
000128  9000              STR      r0,[sp,#0]
00012a  2003              MOVS     r0,#3
00012c  f88d0005          STRB     r0,[sp,#5]
000130  2000              MOVS     r0,#0
000132  f88d0004          STRB     r0,[sp,#4]
000136  f88d0006          STRB     r0,[sp,#6]
00013a  4869              LDR      r0,|L1.736|
00013c  9002              STR      r0,[sp,#8]
00013e  4669              MOV      r1,sp
000140  6860              LDR      r0,[r4,#4]
000142  f7fffffe          BL       UART_Init
000146  2000              MOVS     r0,#0
000148  f88d000e          STRB     r0,[sp,#0xe]
00014c  f88d000f          STRB     r0,[sp,#0xf]
000150  2001              MOVS     r0,#1
000152  f88d000c          STRB     r0,[sp,#0xc]
000156  f88d000d          STRB     r0,[sp,#0xd]
00015a  a903              ADD      r1,sp,#0xc
00015c  6860              LDR      r0,[r4,#4]
00015e  f7fffffe          BL       UART_FIFOConfig
000162  2101              MOVS     r1,#1
000164  6860              LDR      r0,[r4,#4]
000166  f7fffffe          BL       UART_TxCmd
00016a  2201              MOVS     r2,#1
00016c  2100              MOVS     r1,#0
00016e  6860              LDR      r0,[r4,#4]
000170  f7fffffe          BL       UART_IntConfig
000174  2201              MOVS     r2,#1
000176  4611              MOV      r1,r2
000178  6860              LDR      r0,[r4,#4]
00017a  f7fffffe          BL       UART_IntConfig
00017e  2018              MOVS     r0,#0x18
000180  2100              MOVS     r1,#0
000182  2800              CMP      r0,#0
000184  da07              BGE      |L1.406|
000186  070a              LSLS     r2,r1,#28
000188  0e15              LSRS     r5,r2,#24
00018a  4a56              LDR      r2,|L1.740|
00018c  f000030f          AND      r3,r0,#0xf
000190  1f1b              SUBS     r3,r3,#4
000192  54d5              STRB     r5,[r2,r3]
000194  e003              B        |L1.414|
                  |L1.406|
000196  070a              LSLS     r2,r1,#28
000198  0e13              LSRS     r3,r2,#24
00019a  4a53              LDR      r2,|L1.744|
00019c  5413              STRB     r3,[r2,r0]
                  |L1.414|
00019e  bf00              NOP      
0001a0  4620              MOV      r0,r4
0001a2  b004              ADD      sp,sp,#0x10
0001a4  e8bd81f0          POP      {r4-r8,pc}
                          ENDP

                  _Z9uart_initPFjPhjE PROC ; uart_init(unsigned(*)(unsigned char*, unsigned))
;;;148    
;;;149    void uart_init(SerialCallback callback)
0001a8  b570              PUSH     {r4-r6,lr}
;;;150    {
0001aa  4604              MOV      r4,r0
;;;151    	g_uart0 = new Uart(LPC_USART0, callback);
0001ac  2038              MOVS     r0,#0x38
0001ae  f7fffffe          BL       _Znwj ; operator new(unsigned)
0001b2  4605              MOV      r5,r0
0001b4  4622              MOV      r2,r4
0001b6  494d              LDR      r1,|L1.748|
0001b8  f7fffffe          BL       _ZN4UartC1EP15LPC_USARTn_TypePFjPhjE ; Uart::Uart(LPC_USARTn_Type*, unsigned(*)(unsigned char*, unsigned))
0001bc  4605              MOV      r5,r0
0001be  4845              LDR      r0,|L1.724|
0001c0  6005              STR      r5,[r0,#0]  ; g_uart0
;;;152    }
0001c2  bd70              POP      {r4-r6,pc}
                          ENDP

                  _ZN4Uart4openEv PROC ; Uart::open()
;;;60     
;;;61     int Uart::open()
0001c4  b510              PUSH     {r4,lr}
;;;62     {
0001c6  4604              MOV      r4,r0
;;;63     	scu_pinmux(0x2, 0, (MD_PLN | MD_EZI | MD_ZI | MD_EHS), FUNC1); 	         // U0_TXD 
0001c8  2301              MOVS     r3,#1
0001ca  22f0              MOVS     r2,#0xf0
0001cc  2100              MOVS     r1,#0
0001ce  2002              MOVS     r0,#2
0001d0  f7fffffe          BL       scu_pinmux
;;;64     	scu_pinmux(0x2, 1, (MD_PLN | MD_EZI | MD_ZI | MD_EHS), FUNC1); 	         // U0_RXD
0001d4  2301              MOVS     r3,#1
0001d6  22f0              MOVS     r2,#0xf0
0001d8  4619              MOV      r1,r3
0001da  2002              MOVS     r0,#2
0001dc  f7fffffe          BL       scu_pinmux
;;;65      	scu_pinmux(0x1, 3, (MD_PLN | MD_EZI | MD_ZI | MD_EHS), FUNC0); 	         // turn SSP1_MISO into GPIO0[10]
0001e0  2300              MOVS     r3,#0
0001e2  22f0              MOVS     r2,#0xf0
0001e4  2103              MOVS     r1,#3
0001e6  2001              MOVS     r0,#1
0001e8  f7fffffe          BL       scu_pinmux
;;;66     	scu_pinmux(0x1, 4, (MD_PLN | MD_EZI | MD_ZI | MD_EHS), FUNC0); 	         // turn SSP1_MOSI into GPIO0[11]
0001ec  2300              MOVS     r3,#0
0001ee  22f0              MOVS     r2,#0xf0
0001f0  2104              MOVS     r1,#4
0001f2  2001              MOVS     r0,#1
0001f4  f7fffffe          BL       scu_pinmux
;;;67     
;;;68         NVIC_EnableIRQ(USART0_IRQn);
0001f8  2018              MOVS     r0,#0x18
0001fa  2101              MOVS     r1,#1
0001fc  4081              LSLS     r1,r1,r0
0001fe  0942              LSRS     r2,r0,#5
000200  0092              LSLS     r2,r2,#2
000202  f10222e0          ADD      r2,r2,#0xe000e000
000206  f8c21100          STR      r1,[r2,#0x100]
00020a  bf00              NOP      
;;;69     	return 0;
00020c  2000              MOVS     r0,#0
;;;70     }
00020e  bd10              POP      {r4,pc}
;;;71     
                          ENDP

                  _ZN4Uart5closeEv PROC ; Uart::close()
;;;72     int Uart::close()
000210  b510              PUSH     {r4,lr}
;;;73     {
000212  4604              MOV      r4,r0
;;;74     	scu_pinmux(0x2, 0, (MD_PLN | MD_EZI | MD_ZI | MD_EHS), FUNC4); 	         // U0_TXD 
000214  2304              MOVS     r3,#4
000216  22f0              MOVS     r2,#0xf0
000218  2100              MOVS     r1,#0
00021a  2002              MOVS     r0,#2
00021c  f7fffffe          BL       scu_pinmux
;;;75     	scu_pinmux(0x2, 1, (MD_PLN | MD_EZI | MD_ZI | MD_EHS), FUNC4); 	         // U0_RXD
000220  2304              MOVS     r3,#4
000222  22f0              MOVS     r2,#0xf0
000224  2101              MOVS     r1,#1
000226  2002              MOVS     r0,#2
000228  f7fffffe          BL       scu_pinmux
;;;76     
;;;77     	NVIC_DisableIRQ(USART0_IRQn);
00022c  2018              MOVS     r0,#0x18
00022e  2101              MOVS     r1,#1
000230  4081              LSLS     r1,r1,r0
000232  4a2f              LDR      r2,|L1.752|
000234  0943              LSRS     r3,r0,#5
000236  f8421023          STR      r1,[r2,r3,LSL #2]
00023a  bf00              NOP      
;;;78     	return 0;
00023c  2000              MOVS     r0,#0
;;;79     }
00023e  bd10              POP      {r4,pc}
;;;80     
                          ENDP

                  _ZN4Uart7receiveEPhj PROC ; Uart::receive(unsigned char*, unsigned)
;;;81     int Uart::receive(uint8_t *buf, uint32_t len)
000240  e92d47f0          PUSH     {r4-r10,lr}
;;;82     {
000244  4607              MOV      r7,r0
000246  460e              MOV      r6,r1
000248  4690              MOV      r8,r2
;;;83     	uint32_t i;
;;;84     
;;;85     	for (i=0; i<len; i++)
00024a  2500              MOVS     r5,#0
00024c  e01e              B        |L1.652|
                  |L1.590|
;;;86     	{
;;;87     		if (m_rq.read(buf+i)==0)
00024e  f1070408          ADD      r4,r7,#8
000252  eb060905          ADD      r9,r6,r5
000256  4620              MOV      r0,r4
000258  f7fffffe          BL       _ZN8ReceiveQIhE10receiveLenEv ; ReceiveQ<unsigned char>::receiveLen()
00025c  2800              CMP      r0,#0
00025e  dc01              BGT      |L1.612|
000260  2000              MOVS     r0,#0
000262  e010              B        |L1.646|
                  |L1.612|
000264  68a1              LDR      r1,[r4,#8]
000266  1c48              ADDS     r0,r1,#1
000268  60a0              STR      r0,[r4,#8]
00026a  6860              LDR      r0,[r4,#4]
00026c  5c40              LDRB     r0,[r0,r1]
00026e  f8890000          STRB     r0,[r9,#0]
000272  6960              LDR      r0,[r4,#0x14]
000274  1c40              ADDS     r0,r0,#1
000276  6160              STR      r0,[r4,#0x14]
000278  6821              LDR      r1,[r4,#0]
00027a  68a0              LDR      r0,[r4,#8]
00027c  4288              CMP      r0,r1
00027e  d101              BNE      |L1.644|
000280  2000              MOVS     r0,#0
000282  60a0              STR      r0,[r4,#8]
                  |L1.644|
000284  2001              MOVS     r0,#1
                  |L1.646|
000286  b900              CBNZ     r0,|L1.650|
;;;88     			break;
000288  e002              B        |L1.656|
                  |L1.650|
00028a  1c6d              ADDS     r5,r5,#1              ;85
                  |L1.652|
00028c  4545              CMP      r5,r8                 ;85
00028e  d3de              BCC      |L1.590|
                  |L1.656|
000290  bf00              NOP      
;;;89     	}
;;;90     
;;;91     	return i;
000292  4628              MOV      r0,r5
;;;92     }
000294  e8bd87f0          POP      {r4-r10,pc}
;;;93     
                          ENDP

                  _ZN4Uart10receiveLenEv PROC ; Uart::receiveLen()
;;;94     int Uart::receiveLen()
000298  b510              PUSH     {r4,lr}
;;;95     {	
00029a  4604              MOV      r4,r0
;;;96     	return m_rq.receiveLen();
00029c  f1040008          ADD      r0,r4,#8
0002a0  f7fffffe          BL       _ZN8ReceiveQIhE10receiveLenEv ; ReceiveQ<unsigned char>::receiveLen()
;;;97     }
0002a4  bd10              POP      {r4,pc}
;;;98     
                          ENDP

                  _ZN4Uart6updateEv PROC ; Uart::update()
;;;99     int Uart::update()
0002a6  4601              MOV      r1,r0
;;;100    {
;;;101    	if (m_flag==false)
0002a8  f8910034          LDRB     r0,[r1,#0x34]
0002ac  b920              CBNZ     r0,|L1.696|
;;;102    	{
;;;103    		m_uart->THR = 0; // send a 0 to get the transmit interrupt going again, send 16 bits		
0002ae  2000              MOVS     r0,#0
0002b0  684a              LDR      r2,[r1,#4]
0002b2  6010              STR      r0,[r2,#0]
;;;104    		m_uart->THR = 0; 		
0002b4  684a              LDR      r2,[r1,#4]
0002b6  6010              STR      r0,[r2,#0]
                  |L1.696|
;;;105    	}
;;;106    	return 0;
0002b8  2000              MOVS     r0,#0
;;;107    }
0002ba  4770              BX       lr
;;;108    
                          ENDP

                  _ZN4Uart11setBaudrateEj PROC ; Uart::setBaudrate(unsigned)
;;;142    
;;;143    int Uart::setBaudrate(uint32_t baudrate)
0002bc  b570              PUSH     {r4-r6,lr}
;;;144    {
0002be  4604              MOV      r4,r0
0002c0  460d              MOV      r5,r1
;;;145    	UART_setBaudRate(m_uart, baudrate, CLKFREQ);
0002c2  4a07              LDR      r2,|L1.736|
0002c4  4629              MOV      r1,r5
0002c6  6860              LDR      r0,[r4,#4]
0002c8  f7fffffe          BL       UART_setBaudRate
;;;146    	return 0;
0002cc  2000              MOVS     r0,#0
;;;147    }
0002ce  bd70              POP      {r4-r6,pc}
;;;148    
                          ENDP

                  |L1.720|
                          DCD      UART_DATA_AVAILABLE
                  |L1.724|
                          DCD      g_uart0
                  |L1.728|
                          DCD      _ZTV7Iserial+0x8 ; vtable for Iserial
                  |L1.732|
                          DCD      _ZTV4Uart+0x8 ; vtable for Uart
                  |L1.736|
                          DCD      0x0c28cb00
                  |L1.740|
                          DCD      0xe000ed18
                  |L1.744|
                          DCD      0xe000e400
                  |L1.748|
                          DCD      0x40081000
                  |L1.752|
                          DCD      0xe000e180

                          AREA ||.ARM.exidx||, LINKORDER=||.text||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||.text||
                          DCD      0x00000001

                          AREA ||.data||, DATA, ALIGN=2

                  g_uart0
                          DCD      0x00000000
                  UART_DATA_AVAILABLE
000004  00                DCB      0x00

                          AREA ||.constdata__ZTV4Uart||, COMGROUP=_ZTV4Uart, DATA, READONLY, ALIGN=2

                  _ZTV4Uart ; vtable for Uart
                          DCD      0x00000000
                          DCD      _ZTI4Uart ; typeinfo for Uart
                          DCD      _ZN4Uart4openEv ; Uart::open()
                          DCD      _ZN4Uart5closeEv ; Uart::close()
                          DCD      _ZN4Uart7receiveEPhj ; Uart::receive(unsigned char*, unsigned)
                          DCD      _ZN4Uart10receiveLenEv ; Uart::receiveLen()
                          DCD      _ZN4Uart6updateEv ; Uart::update()

                          AREA ||t._ZN8ReceiveQIhE10receiveLenEv||, COMGROUP=_ZN8ReceiveQIhE10receiveLenEv, CODE, READONLY, ALIGN=1

                  _ZN8ReceiveQIhE10receiveLenEv PROC ; ReceiveQ<unsigned char>::receiveLen()
;;;41     
;;;42     	inline int32_t receiveLen()
000000  4601              MOV      r1,r0
;;;43     	{
;;;44     		return m_produced - m_consumed;
000002  e9d10204          LDRD     r0,r2,[r1,#0x10]
000006  1a80              SUBS     r0,r0,r2
;;;45     	}
000008  4770              BX       lr
;;;46     
                          ENDP


                          AREA ||area_number.21||, COMGROUP=_ZN8ReceiveQIhE10receiveLenEv, LINKORDER=||t._ZN8ReceiveQIhE10receiveLenEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.21||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN8ReceiveQIhE10receiveLenEv||
                          DCD      0x00000001

                          AREA ||.constdata__ZTV7Iserial||, COMGROUP=_ZTV7Iserial, DATA, READONLY, ALIGN=2

                  _ZTV7Iserial ; vtable for Iserial
                          DCD      0x00000000
                          DCD      _ZTI7Iserial ; typeinfo for Iserial
                          DCD      _ZN7Iserial4openEv ; Iserial::open()
                          DCD      _ZN7Iserial5closeEv ; Iserial::close()
                          DCD      _ZN7Iserial7receiveEPhj ; Iserial::receive(unsigned char*, unsigned)
                          DCD      _ZN7Iserial10receiveLenEv ; Iserial::receiveLen()
                          DCD      _ZN7Iserial6updateEv ; Iserial::update()

                          AREA ||.constdata__ZTI4Uart||, COMGROUP=_ZTI4Uart, DATA, READONLY, ALIGN=2

                  _ZTI4Uart ; typeinfo for Uart
                          DCD      _ZTVN10__cxxabiv120__si_class_type_infoE+0x8 ; vtable for __cxxabiv1::__si_class_type_info
                          DCD      _ZTS4Uart ; typeinfo name for Uart
                          DCD      _ZTI7Iserial ; typeinfo for Iserial

                          AREA ||.constdata__ZTI7Iserial||, COMGROUP=_ZTI7Iserial, DATA, READONLY, ALIGN=2

                  _ZTI7Iserial ; typeinfo for Iserial
                          DCD      _ZTVN10__cxxabiv117__class_type_infoE+0x8 ; vtable for __cxxabiv1::__class_type_info
                          DCD      _ZTS7Iserial ; typeinfo name for Iserial

                          AREA ||.constdata__ZTS4Uart||, COMGROUP=_ZTS4Uart, DATA, READONLY, ALIGN=0

                  _ZTS4Uart ; typeinfo name for Uart
000000  34556172          DCB      0x34,0x55,0x61,0x72
000004  7400              DCB      0x74,0x00

                          AREA ||.constdata__ZTS7Iserial||, COMGROUP=_ZTS7Iserial, DATA, READONLY, ALIGN=0

                  _ZTS7Iserial ; typeinfo name for Iserial
000000  37497365          DCB      0x37,0x49,0x73,0x65
000004  7269616c          DCB      0x72,0x69,0x61,0x6c
000008  00                DCB      0x00

                          AREA ||i._ZN7Iserial4openEv||, COMGROUP=_ZN7Iserial4openEv, CODE, READONLY, ALIGN=1

                  _ZN7Iserial4openEv PROC ; Iserial::open()
;;;131    public:
;;;132    	virtual int open()
000000  4601              MOV      r1,r0
;;;133    	{
;;;134    		return 0;
000002  2000              MOVS     r0,#0
;;;135    	}
000004  4770              BX       lr
;;;136    	virtual int close()
                          ENDP


                          AREA ||area_number.39||, COMGROUP=_ZN7Iserial4openEv, LINKORDER=||i._ZN7Iserial4openEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.39||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN7Iserial4openEv||
                          DCD      0x00000001

                          AREA ||i._ZN7Iserial5closeEv||, COMGROUP=_ZN7Iserial5closeEv, CODE, READONLY, ALIGN=1

                  _ZN7Iserial5closeEv PROC ; Iserial::close()
;;;135    	}
;;;136    	virtual int close()
000000  4601              MOV      r1,r0
;;;137    	{
;;;138    		return 0;
000002  2000              MOVS     r0,#0
;;;139    	}
000004  4770              BX       lr
;;;140    	virtual int receive(uint8_t *buf, uint32_t len)
                          ENDP


                          AREA ||area_number.46||, COMGROUP=_ZN7Iserial5closeEv, LINKORDER=||i._ZN7Iserial5closeEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.46||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN7Iserial5closeEv||
                          DCD      0x00000001

                          AREA ||i._ZN7Iserial7receiveEPhj||, COMGROUP=_ZN7Iserial7receiveEPhj, CODE, READONLY, ALIGN=1

                  _ZN7Iserial7receiveEPhj PROC ; Iserial::receive(unsigned char*, unsigned)
;;;139    	}
;;;140    	virtual int receive(uint8_t *buf, uint32_t len)
000000  4603              MOV      r3,r0
;;;141    	{
;;;142    		return 0;
000002  2000              MOVS     r0,#0
;;;143    	}
000004  4770              BX       lr
;;;144    	virtual int receiveLen()
                          ENDP


                          AREA ||area_number.53||, COMGROUP=_ZN7Iserial7receiveEPhj, LINKORDER=||i._ZN7Iserial7receiveEPhj||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.53||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN7Iserial7receiveEPhj||
                          DCD      0x00000001

                          AREA ||i._ZN7Iserial10receiveLenEv||, COMGROUP=_ZN7Iserial10receiveLenEv, CODE, READONLY, ALIGN=1

                  _ZN7Iserial10receiveLenEv PROC ; Iserial::receiveLen()
;;;143    	}
;;;144    	virtual int receiveLen()
000000  4601              MOV      r1,r0
;;;145    	{
;;;146    		return 0;
000002  2000              MOVS     r0,#0
;;;147    	}
000004  4770              BX       lr
;;;148    	virtual int update()
                          ENDP


                          AREA ||area_number.60||, COMGROUP=_ZN7Iserial10receiveLenEv, LINKORDER=||i._ZN7Iserial10receiveLenEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.60||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN7Iserial10receiveLenEv||
                          DCD      0x00000001

                          AREA ||i._ZN7Iserial6updateEv||, COMGROUP=_ZN7Iserial6updateEv, CODE, READONLY, ALIGN=1

                  _ZN7Iserial6updateEv PROC ; Iserial::update()
;;;147    	}
;;;148    	virtual int update()
000000  4601              MOV      r1,r0
;;;149    	{
;;;150    		return 0;
000002  2000              MOVS     r0,#0
;;;151    	}
000004  4770              BX       lr
;;;152    };
                          ENDP


                          AREA ||area_number.67||, COMGROUP=_ZN7Iserial6updateEv, LINKORDER=||i._ZN7Iserial6updateEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.67||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN7Iserial6updateEv||
                          DCD      0x00000001

;*** Start embedded assembler ***

#line 1 "..\\libpixy\\uart.cpp"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___8_uart_cpp_bb43f66e___Z7__REV16j|
#line 130 "..\\libpixy\\core_cmInstr.h"
|__asm___8_uart_cpp_bb43f66e___Z7__REV16j| PROC
#line 131

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___8_uart_cpp_bb43f66e___Z7__REVSHi|
#line 144
|__asm___8_uart_cpp_bb43f66e___Z7__REVSHi| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
