; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--cpp --list --debug -c --asm --interleave -o.\spifi\i2c.o --asm_dir=.\ --list_dir=.\ --depend=.\spifi\i2c.d --cpu=Cortex-M4 --apcs=interwork -O0 --diag_suppress=9931 -I. -I..\libpixy -I..\..\common -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=514 -DCORE_M4 -DIPC_MASTER -DPIXY --omf_browse=.\spifi\i2c.crf ..\libpixy\i2c.cpp]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  _ZN3I2c12slaveHandlerEv PROC ; I2c::slaveHandler()
;;;28     
;;;29     void I2c::slaveHandler()
000000  b5f8              PUSH     {r3-r7,lr}
;;;30     {
000002  4604              MOV      r4,r0
;;;31     	uint8_t stat, c;
;;;32     
;;;33     	stat = m_i2c->STAT&I2C_STAT_CODE_BITMASK;
000004  68a0              LDR      r0,[r4,#8]
000006  6840              LDR      r0,[r0,#4]
000008  f00007f8          AND      r7,r0,#0xf8
;;;34     	switch (stat)
00000c  f0070007          AND      r0,r7,#7
000010  2800              CMP      r0,#0
000012  d172              BNE      |L1.250|
000014  10f8              ASRS     r0,r7,#3
000016  380c              SUBS     r0,r0,#0xc
000018  2814              CMP      r0,#0x14
00001a  d26e              BCS      |L1.250|
00001c  e8dff000          TBB      [pc,r0]
000020  11821282          DCB      0x11,0x82,0x12,0x82
000024  193e1a3f          DCB      0x19,0x3e,0x1a,0x3f
000028  40478248          DCB      0x40,0x47,0x82,0x48
00002c  7b7a8282          DCB      0x7b,0x7a,0x82,0x82
000030  8282820a          DCB      0x82,0x82,0x82,0x0a
;;;35     	{
;;;36     	// No status information 
;;;37     	case I2C_I2STAT_NO_INF:
;;;38     		m_i2c->CONSET = I2C_I2CONSET_AA;
000034  2004              MOVS     r0,#4
000036  68a1              LDR      r1,[r4,#8]
000038  6008              STR      r0,[r1,#0]
;;;39     		m_i2c->CONCLR = I2C_I2CONCLR_SIC;
00003a  2008              MOVS     r0,#8
00003c  68a1              LDR      r1,[r4,#8]
00003e  6188              STR      r0,[r1,#0x18]
;;;40     		break;
000040  e074              B        |L1.300|
;;;41     
;;;42     	// Reading phase 
;;;43     	// Own SLA+R has been received, ACK has been returned 
;;;44     	case I2C_I2STAT_S_RX_SLAW_ACK:
;;;45     	// General call address has been received, ACK has been returned 
;;;46     	case I2C_I2STAT_S_RX_GENCALL_ACK:
000042  bf00              NOP      
;;;47     		m_i2c->CONSET = I2C_I2CONSET_AA;
000044  2004              MOVS     r0,#4
000046  68a1              LDR      r1,[r4,#8]
000048  6008              STR      r0,[r1,#0]
;;;48     		m_i2c->CONCLR = I2C_I2CONCLR_SIC;
00004a  2008              MOVS     r0,#8
00004c  68a1              LDR      r1,[r4,#8]
00004e  6188              STR      r0,[r1,#0x18]
;;;49     		break;
000050  e06c              B        |L1.300|
;;;50     
;;;51     	// Previously addressed with own SLA
;;;52     	// DATA byte has been received
;;;53     	// ACK has been returned 
;;;54     	case I2C_I2STAT_S_RX_PRE_SLA_DAT_ACK:
;;;55     	// DATA has been received, ACK hasn been return 
;;;56     	case I2C_I2STAT_S_RX_PRE_GENCALL_DAT_ACK:
000052  bf00              NOP      
;;;57     		 // All data bytes that over-flow the specified receive
;;;58     		 // data length, just ignore them.
;;;59     		m_rq.write((uint8_t)m_i2c->DAT);
000054  f104050c          ADD      r5,r4,#0xc
000058  68a0              LDR      r0,[r4,#8]
00005a  6880              LDR      r0,[r0,#8]
00005c  b2c6              UXTB     r6,r0
00005e  bf00              NOP      
000060  4628              MOV      r0,r5
000062  f7fffffe          BL       _ZN8ReceiveQIhE10receiveLenEv ; ReceiveQ<unsigned char>::receiveLen()
000066  6829              LDR      r1,[r5,#0]
000068  1a08              SUBS     r0,r1,r0
00006a  2800              CMP      r0,#0
00006c  dc00              BGT      |L1.112|
00006e  e00e              B        |L1.142|
                  |L1.112|
000070  68e9              LDR      r1,[r5,#0xc]
000072  1c48              ADDS     r0,r1,#1
000074  60e8              STR      r0,[r5,#0xc]
000076  6868              LDR      r0,[r5,#4]
000078  5446              STRB     r6,[r0,r1]
00007a  6928              LDR      r0,[r5,#0x10]
00007c  1c40              ADDS     r0,r0,#1
00007e  6128              STR      r0,[r5,#0x10]
000080  6829              LDR      r1,[r5,#0]
000082  68e8              LDR      r0,[r5,#0xc]
000084  4288              CMP      r0,r1
000086  d101              BNE      |L1.140|
000088  2000              MOVS     r0,#0
00008a  60e8              STR      r0,[r5,#0xc]
                  |L1.140|
00008c  bf00              NOP      
                  |L1.142|
;;;60     		m_i2c->CONSET = I2C_I2CONSET_AA;
00008e  2004              MOVS     r0,#4
000090  68a1              LDR      r1,[r4,#8]
000092  6008              STR      r0,[r1,#0]
;;;61     		m_i2c->CONCLR = I2C_I2CONCLR_SIC;
000094  2008              MOVS     r0,#8
000096  68a1              LDR      r1,[r4,#8]
000098  6188              STR      r0,[r1,#0x18]
;;;62     		break;
00009a  e047              B        |L1.300|
;;;63     
;;;64     	// Previously addressed with own SLA
;;;65     	// DATA byte has been received
;;;66     	// NOT ACK has been returned 
;;;67     	case I2C_I2STAT_S_RX_PRE_SLA_DAT_NACK:
;;;68     	// DATA has been received, NOT ACK has been returned 
;;;69     	case I2C_I2STAT_S_RX_PRE_GENCALL_DAT_NACK:
00009c  bf00              NOP      
;;;70     	case I2C_I2STAT_S_RX_STA_STO_SLVREC_SLVTRX:
00009e  bf00              NOP      
;;;71     		m_i2c->CONSET = I2C_I2CONSET_AA;
0000a0  2004              MOVS     r0,#4
0000a2  68a1              LDR      r1,[r4,#8]
0000a4  6008              STR      r0,[r1,#0]
;;;72     		m_i2c->CONCLR = I2C_I2CONCLR_SIC;
0000a6  2008              MOVS     r0,#8
0000a8  68a1              LDR      r1,[r4,#8]
0000aa  6188              STR      r0,[r1,#0x18]
;;;73     		break;
0000ac  e03e              B        |L1.300|
;;;74     
;;;75     	// Writing phase
;;;76     	// Own SLA+R has been received, ACK has been returned 
;;;77     	case I2C_I2STAT_S_TX_SLAR_ACK:
;;;78     	// Data has been transmitted, ACK has been received 
;;;79     	case I2C_I2STAT_S_TX_DAT_ACK:
0000ae  bf00              NOP      
;;;80     		if (m_pad0) // m_pad0 is there so we make sure to send 0's in pairs so we don't get out of byte-sync
0000b0  7920              LDRB     r0,[r4,#4]
0000b2  b120              CBZ      r0,|L1.190|
;;;81     		{
;;;82     			m_i2c->DAT = 0;
0000b4  2000              MOVS     r0,#0
0000b6  68a1              LDR      r1,[r4,#8]
0000b8  6088              STR      r0,[r1,#8]
;;;83     			m_pad0 = false;
0000ba  7120              STRB     r0,[r4,#4]
0000bc  e023              B        |L1.262|
                  |L1.190|
;;;84     		}
;;;85     		else if (m_tq.read(&c))
0000be  bf00              NOP      
0000c0  6b20              LDR      r0,[r4,#0x30]
0000c2  b950              CBNZ     r0,|L1.218|
0000c4  6b62              LDR      r2,[r4,#0x34]
0000c6  e9d41009          LDRD     r1,r0,[r4,#0x24]
0000ca  4790              BLX      r2
0000cc  6320              STR      r0,[r4,#0x30]
0000ce  6b20              LDR      r0,[r4,#0x30]
0000d0  b908              CBNZ     r0,|L1.214|
0000d2  2000              MOVS     r0,#0
0000d4  e00b              B        |L1.238|
                  |L1.214|
0000d6  2000              MOVS     r0,#0
0000d8  62e0              STR      r0,[r4,#0x2c]
                  |L1.218|
0000da  6ae1              LDR      r1,[r4,#0x2c]
0000dc  1c48              ADDS     r0,r1,#1
0000de  62e0              STR      r0,[r4,#0x2c]
0000e0  6aa0              LDR      r0,[r4,#0x28]
0000e2  5c40              LDRB     r0,[r0,r1]
0000e4  9000              STR      r0,[sp,#0]
0000e6  6b20              LDR      r0,[r4,#0x30]
0000e8  1e40              SUBS     r0,r0,#1
0000ea  6320              STR      r0,[r4,#0x30]
0000ec  2001              MOVS     r0,#1
                  |L1.238|
0000ee  b128              CBZ      r0,|L1.252|
;;;86     			m_i2c->DAT = c;
0000f0  f89d0000          LDRB     r0,[sp,#0]
0000f4  68a1              LDR      r1,[r4,#8]
0000f6  6088              STR      r0,[r1,#8]
0000f8  e005              B        |L1.262|
                  |L1.250|
0000fa  e013              B        |L1.292|
                  |L1.252|
;;;87     		else 
;;;88     		{
;;;89     			m_i2c->DAT = 0;
0000fc  2000              MOVS     r0,#0
0000fe  68a1              LDR      r1,[r4,#8]
000100  6088              STR      r0,[r1,#8]
;;;90     			m_pad0 = true;
000102  2001              MOVS     r0,#1
000104  7120              STRB     r0,[r4,#4]
                  |L1.262|
;;;91     		}
;;;92     		m_i2c->CONSET = I2C_I2CONSET_AA;
000106  2004              MOVS     r0,#4
000108  68a1              LDR      r1,[r4,#8]
00010a  6008              STR      r0,[r1,#0]
;;;93     		m_i2c->CONCLR = I2C_I2CONCLR_SIC;
00010c  2008              MOVS     r0,#8
00010e  68a1              LDR      r1,[r4,#8]
000110  6188              STR      r0,[r1,#0x18]
;;;94     		break;
000112  e00b              B        |L1.300|
;;;95     
;;;96     	case I2C_I2STAT_S_TX_LAST_DAT_ACK:
;;;97     	case I2C_I2STAT_S_TX_DAT_NACK:
000114  bf00              NOP      
;;;98     		m_i2c->CONSET = I2C_I2CONSET_AA;
000116  2004              MOVS     r0,#4
000118  68a1              LDR      r1,[r4,#8]
00011a  6008              STR      r0,[r1,#0]
;;;99     		m_i2c->CONCLR = I2C_I2CONCLR_SIC;
00011c  2008              MOVS     r0,#8
00011e  68a1              LDR      r1,[r4,#8]
000120  6188              STR      r0,[r1,#0x18]
;;;100    		break;
000122  e003              B        |L1.300|
                  |L1.292|
;;;101    
;;;102    	// Other status must be captured
;;;103    	default:
;;;104    		m_i2c->CONCLR = I2C_I2CONCLR_AAC | I2C_I2CONCLR_SIC | I2C_I2CONCLR_STAC;
000124  202c              MOVS     r0,#0x2c
000126  68a1              LDR      r1,[r4,#8]
000128  6188              STR      r0,[r1,#0x18]
;;;105    		break;
00012a  bf00              NOP      
                  |L1.300|
00012c  bf00              NOP                            ;40
;;;106    	}
;;;107    }
00012e  bdf8              POP      {r3-r7,pc}
;;;108    
                          ENDP

                  I2C0_IRQHandler PROC
;;;23     
;;;24     void I2C0_IRQHandler(void)
000130  b510              PUSH     {r4,lr}
;;;25     {
;;;26     	g_i2c0->slaveHandler();
000132  4878              LDR      r0,|L1.788|
000134  6800              LDR      r0,[r0,#0]  ; g_i2c0
000136  f7fffffe          BL       _ZN3I2c12slaveHandlerEv ; I2c::slaveHandler()
;;;27     }
00013a  bd10              POP      {r4,pc}
;;;28     
                          ENDP

                  _ZN3I2c12setSlaveAddrEh PROC ; I2c::setSlaveAddr(unsigned char)
;;;180    
;;;181    int I2c::setSlaveAddr(uint8_t addr)
00013c  b538              PUSH     {r3-r5,lr}
;;;182    {
00013e  4604              MOV      r4,r0
000140  460d              MOV      r5,r1
;;;183    	I2C_OWNSLAVEADDR_CFG_Type slaveAddr;
;;;184    	slaveAddr.SlaveAddr_7bit = addr;
000142  f88d5001          STRB     r5,[sp,#1]
;;;185    	slaveAddr.SlaveAddrMaskValue = 0;
000146  2000              MOVS     r0,#0
000148  f88d0003          STRB     r0,[sp,#3]
;;;186    	slaveAddr.SlaveAddrChannel = 0;
00014c  f88d0000          STRB     r0,[sp,#0]
;;;187    	I2C_SetOwnSlaveAddr(m_i2c, &slaveAddr);
000150  4669              MOV      r1,sp
000152  68a0              LDR      r0,[r4,#8]
000154  f7fffffe          BL       I2C_SetOwnSlaveAddr
;;;188    
;;;189    	return 0;
000158  2000              MOVS     r0,#0
;;;190    }
00015a  bd38              POP      {r3-r5,pc}
;;;191    
                          ENDP

                  _ZN3I2cC2EP13LPC_I2Cn_TypehPFjPhjE                  ; Alternate entry point ; I2c::I2c__sub_object(LPC_I2Cn_Type*, unsigned char, unsigned(*)(unsigned char*, unsigned))
                  _ZN3I2cC1EP13LPC_I2Cn_TypehPFjPhjE PROC ; I2c::I2c(LPC_I2Cn_Type*, unsigned char, unsigned(*)(unsigned char*, unsigned))
;;;170    
;;;171    I2c::I2c(LPC_I2Cn_Type *i2c, uint8_t addr, SerialCallback callback) : m_rq(I2C_RECEIVE_BUF_SIZE), m_tq(I2C_TRANSMIT_BUF_SIZE, callback)
;;;172    {
;;;173    	m_i2c = i2c;
;;;174    	 
;;;175    	I2C_Init(m_i2c, 100000);
;;;176       	setSlaveAddr(addr);
;;;177    
;;;178    	NVIC_SetPriority(SSP1_IRQn, 0);	// high priority interrupt
;;;179    }
;;;180    
00015c  e92d47f0          PUSH     {r4-r10,lr}
000160  4605              MOV      r5,r0
000162  460f              MOV      r7,r1
000164  4690              MOV      r8,r2
000166  461e              MOV      r6,r3
000168  496b              LDR      r1,|L1.792|
00016a  486c              LDR      r0,|L1.796|
00016c  6028              STR      r0,[r5,#0]
00016e  f105040c          ADD      r4,r5,#0xc
000172  f04f0920          MOV      r9,#0x20
000176  f8c49000          STR      r9,[r4,#0]
00017a  6820              LDR      r0,[r4,#0]
00017c  f7fffffe          BL       _Znaj ; operator new[] (unsigned)
000180  6060              STR      r0,[r4,#4]
000182  2000              MOVS     r0,#0
000184  60a0              STR      r0,[r4,#8]
000186  60e0              STR      r0,[r4,#0xc]
000188  6120              STR      r0,[r4,#0x10]
00018a  6160              STR      r0,[r4,#0x14]
00018c  bf00              NOP      
00018e  f1a4050c          SUB      r5,r4,#0xc
000192  f1050424          ADD      r4,r5,#0x24
000196  f8c49000          STR      r9,[r4,#0]
00019a  6820              LDR      r0,[r4,#0]
00019c  f7fffffe          BL       _Znaj ; operator new[] (unsigned)
0001a0  6060              STR      r0,[r4,#4]
0001a2  2000              MOVS     r0,#0
0001a4  60a0              STR      r0,[r4,#8]
0001a6  60e0              STR      r0,[r4,#0xc]
0001a8  6126              STR      r6,[r4,#0x10]
0001aa  bf00              NOP      
0001ac  f1a40524          SUB      r5,r4,#0x24
0001b0  60af              STR      r7,[r5,#8]
0001b2  495b              LDR      r1,|L1.800|
0001b4  68a8              LDR      r0,[r5,#8]
0001b6  f7fffffe          BL       I2C_Init
0001ba  4641              MOV      r1,r8
0001bc  4628              MOV      r0,r5
0001be  f7fffffe          BL       _ZN3I2c12setSlaveAddrEh ; I2c::setSlaveAddr(unsigned char)
0001c2  2017              MOVS     r0,#0x17
0001c4  2100              MOVS     r1,#0
0001c6  2800              CMP      r0,#0
0001c8  da07              BGE      |L1.474|
0001ca  070a              LSLS     r2,r1,#28
0001cc  0e14              LSRS     r4,r2,#24
0001ce  4a55              LDR      r2,|L1.804|
0001d0  f000030f          AND      r3,r0,#0xf
0001d4  1f1b              SUBS     r3,r3,#4
0001d6  54d4              STRB     r4,[r2,r3]
0001d8  e003              B        |L1.482|
                  |L1.474|
0001da  070a              LSLS     r2,r1,#28
0001dc  0e13              LSRS     r3,r2,#24
0001de  4a52              LDR      r2,|L1.808|
0001e0  5413              STRB     r3,[r2,r0]
                  |L1.482|
0001e2  bf00              NOP      
0001e4  4628              MOV      r0,r5
0001e6  e8bd87f0          POP      {r4-r10,pc}
                          ENDP

                  _Z8i2c_initPFjPhjE PROC ; i2c_init(unsigned(*)(unsigned char*, unsigned))
;;;191    
;;;192    void i2c_init(SerialCallback callback)
0001ea  b570              PUSH     {r4-r6,lr}
;;;193    {
0001ec  4604              MOV      r4,r0
;;;194    	g_i2c0 = new I2c(LPC_I2C0, I2C_DEFAULT_SLAVE_ADDR, callback);
0001ee  2038              MOVS     r0,#0x38
0001f0  f7fffffe          BL       _Znwj ; operator new(unsigned)
0001f4  4605              MOV      r5,r0
0001f6  4623              MOV      r3,r4
0001f8  2254              MOVS     r2,#0x54
0001fa  494c              LDR      r1,|L1.812|
0001fc  f7fffffe          BL       _ZN3I2cC1EP13LPC_I2Cn_TypehPFjPhjE ; I2c::I2c(LPC_I2Cn_Type*, unsigned char, unsigned(*)(unsigned char*, unsigned))
000200  4605              MOV      r5,r0
000202  4844              LDR      r0,|L1.788|
000204  6005              STR      r5,[r0,#0]  ; g_i2c0
;;;195    }
000206  bd70              POP      {r4-r6,pc}
                          ENDP

                  _ZN3I2c10startSlaveEv PROC ; I2c::startSlave()
;;;164    
;;;165    void I2c::startSlave()
000208  2138              MOVS     r1,#0x38
;;;166    {
;;;167    	m_i2c->CONCLR = I2C_I2CONCLR_SIC | I2C_I2CONCLR_STOC | I2C_I2CONCLR_STAC;
00020a  6882              LDR      r2,[r0,#8]
00020c  6191              STR      r1,[r2,#0x18]
;;;168    	m_i2c->CONSET = I2C_I2CONSET_AA | I2C_I2CONSET_I2EN;
00020e  2144              MOVS     r1,#0x44
000210  6882              LDR      r2,[r0,#8]
000212  6011              STR      r1,[r2,#0]
;;;169    }
000214  4770              BX       lr
;;;170    
                          ENDP

                  _ZN3I2c4openEv PROC ; I2c::open()
;;;108    
;;;109    int I2c::open()
000216  b510              PUSH     {r4,lr}
;;;110    {
000218  4604              MOV      r4,r0
;;;111    	// make all pins on the I/O connector high impedance so we can just daisy chain the whole connector together
;;;112    	scu_pinmux(0x1, 3, (MD_PLN | MD_EZI | MD_ZI | MD_EHS), FUNC0); 
00021a  2300              MOVS     r3,#0
00021c  22f0              MOVS     r2,#0xf0
00021e  2103              MOVS     r1,#3
000220  2001              MOVS     r0,#1
000222  f7fffffe          BL       scu_pinmux
;;;113    	scu_pinmux(0x2, 1, (MD_PLN | MD_EZI | MD_ZI | MD_EHS), FUNC4); 	         
000226  2304              MOVS     r3,#4
000228  22f0              MOVS     r2,#0xf0
00022a  2101              MOVS     r1,#1
00022c  2002              MOVS     r0,#2
00022e  f7fffffe          BL       scu_pinmux
;;;114    	scu_pinmux(0x2, 1, (MD_PLN | MD_EZI | MD_ZI | MD_EHS), FUNC4); 	         
000232  2304              MOVS     r3,#4
000234  22f0              MOVS     r2,#0xf0
000236  2101              MOVS     r1,#1
000238  2002              MOVS     r0,#2
00023a  f7fffffe          BL       scu_pinmux
;;;115    	scu_pinmux(0x1, 4, (MD_PLN | MD_EZI | MD_ZI | MD_EHS), FUNC0); 	         
00023e  2300              MOVS     r3,#0
000240  22f0              MOVS     r2,#0xf0
000242  2104              MOVS     r1,#4
000244  2001              MOVS     r0,#1
000246  f7fffffe          BL       scu_pinmux
;;;116    	scu_pinmux(0x2, 0, (MD_PLN | MD_EZI | MD_ZI | MD_EHS), FUNC4); 	         
00024a  2304              MOVS     r3,#4
00024c  22f0              MOVS     r2,#0xf0
00024e  2100              MOVS     r1,#0
000250  2002              MOVS     r0,#2
000252  f7fffffe          BL       scu_pinmux
;;;117    	// turn off driver for SS signal so we can wire-or them together
;;;118    	LPC_SGPIO->GPIO_OENREG = 0;
000256  2000              MOVS     r0,#0
000258  4935              LDR      r1,|L1.816|
00025a  6008              STR      r0,[r1,#0]
;;;119    
;;;120     	m_pad0 = false;
00025c  7120              STRB     r0,[r4,#4]
;;;121    
;;;122    	NVIC_EnableIRQ(I2C0_IRQn);
00025e  2012              MOVS     r0,#0x12
000260  2101              MOVS     r1,#1
000262  4081              LSLS     r1,r1,r0
000264  0942              LSRS     r2,r0,#5
000266  0092              LSLS     r2,r2,#2
000268  f10222e0          ADD      r2,r2,#0xe000e000
00026c  f8c21100          STR      r1,[r2,#0x100]
000270  bf00              NOP      
;;;123    	startSlave(); 
000272  4620              MOV      r0,r4
000274  f7fffffe          BL       _ZN3I2c10startSlaveEv ; I2c::startSlave()
;;;124    
;;;125    
;;;126    	return 0;
000278  2000              MOVS     r0,#0
;;;127    }
00027a  bd10              POP      {r4,pc}
;;;128    
                          ENDP

                  _ZN3I2c5closeEv PROC ; I2c::close()
;;;129    int I2c::close()
00027c  b510              PUSH     {r4,lr}
;;;130    {
00027e  4601              MOV      r1,r0
;;;131    	NVIC_DisableIRQ(I2C0_IRQn);
000280  2012              MOVS     r0,#0x12
000282  2201              MOVS     r2,#1
000284  4082              LSLS     r2,r2,r0
000286  4b2b              LDR      r3,|L1.820|
000288  0944              LSRS     r4,r0,#5
00028a  f8432024          STR      r2,[r3,r4,LSL #2]
00028e  bf00              NOP      
;;;132    	return 0;
000290  2000              MOVS     r0,#0
;;;133    }
000292  bd10              POP      {r4,pc}
;;;134    
                          ENDP

                  _ZN3I2c7receiveEPhj PROC ; I2c::receive(unsigned char*, unsigned)
;;;135    int I2c::receive(uint8_t *buf, uint32_t len)
000294  e92d47f0          PUSH     {r4-r10,lr}
;;;136    {
000298  4607              MOV      r7,r0
00029a  460e              MOV      r6,r1
00029c  4690              MOV      r8,r2
;;;137    	uint32_t i;
;;;138    
;;;139    	for (i=0; i<len; i++)
00029e  2500              MOVS     r5,#0
0002a0  e01e              B        |L1.736|
                  |L1.674|
;;;140    	{
;;;141    		if (m_rq.read(buf+i)==0)
0002a2  f107040c          ADD      r4,r7,#0xc
0002a6  eb060905          ADD      r9,r6,r5
0002aa  4620              MOV      r0,r4
0002ac  f7fffffe          BL       _ZN8ReceiveQIhE10receiveLenEv ; ReceiveQ<unsigned char>::receiveLen()
0002b0  2800              CMP      r0,#0
0002b2  dc01              BGT      |L1.696|
0002b4  2000              MOVS     r0,#0
0002b6  e010              B        |L1.730|
                  |L1.696|
0002b8  68a1              LDR      r1,[r4,#8]
0002ba  1c48              ADDS     r0,r1,#1
0002bc  60a0              STR      r0,[r4,#8]
0002be  6860              LDR      r0,[r4,#4]
0002c0  5c40              LDRB     r0,[r0,r1]
0002c2  f8890000          STRB     r0,[r9,#0]
0002c6  6960              LDR      r0,[r4,#0x14]
0002c8  1c40              ADDS     r0,r0,#1
0002ca  6160              STR      r0,[r4,#0x14]
0002cc  6821              LDR      r1,[r4,#0]
0002ce  68a0              LDR      r0,[r4,#8]
0002d0  4288              CMP      r0,r1
0002d2  d101              BNE      |L1.728|
0002d4  2000              MOVS     r0,#0
0002d6  60a0              STR      r0,[r4,#8]
                  |L1.728|
0002d8  2001              MOVS     r0,#1
                  |L1.730|
0002da  b900              CBNZ     r0,|L1.734|
;;;142    			break;
0002dc  e002              B        |L1.740|
                  |L1.734|
0002de  1c6d              ADDS     r5,r5,#1              ;139
                  |L1.736|
0002e0  4545              CMP      r5,r8                 ;139
0002e2  d3de              BCC      |L1.674|
                  |L1.740|
0002e4  bf00              NOP      
;;;143    	}
;;;144    
;;;145    	return i;
0002e6  4628              MOV      r0,r5
;;;146    }
0002e8  e8bd87f0          POP      {r4-r10,pc}
;;;147    
                          ENDP

                  _ZN3I2c10receiveLenEv PROC ; I2c::receiveLen()
;;;148    int I2c::receiveLen()
0002ec  b510              PUSH     {r4,lr}
;;;149    {
0002ee  4604              MOV      r4,r0
;;;150    	return m_rq.receiveLen();
0002f0  f104000c          ADD      r0,r4,#0xc
0002f4  f7fffffe          BL       _ZN8ReceiveQIhE10receiveLenEv ; ReceiveQ<unsigned char>::receiveLen()
;;;151    }
0002f8  bd10              POP      {r4,pc}
;;;152    
                          ENDP

                  _ZN3I2c6updateEv PROC ; I2c::update()
;;;153    
;;;154    int I2c::update()
0002fa  b500              PUSH     {lr}
;;;155    {
0002fc  4603              MOV      r3,r0
;;;156    	// try to recover from out of sync condition between slave (us) and master
;;;157    	// happens when cable is unplugged/plugged
;;;158    	if ((m_i2c->CONSET&I2C_I2CONSET_AA)==0)
0002fe  6898              LDR      r0,[r3,#8]
000300  6800              LDR      r0,[r0,#0]
000302  f0000004          AND      r0,r0,#4
000306  b910              CBNZ     r0,|L1.782|
;;;159    		startSlave();
000308  4618              MOV      r0,r3
00030a  f7fffffe          BL       _ZN3I2c10startSlaveEv ; I2c::startSlave()
                  |L1.782|
;;;160    
;;;161    	return 0;
00030e  2000              MOVS     r0,#0
;;;162    }
000310  bd00              POP      {pc}
;;;163    
                          ENDP

000312  0000              DCW      0x0000
                  |L1.788|
                          DCD      g_i2c0
                  |L1.792|
                          DCD      _ZTV7Iserial+0x8 ; vtable for Iserial
                  |L1.796|
                          DCD      _ZTV3I2c+0x8 ; vtable for I2c
                  |L1.800|
                          DCD      0x000186a0
                  |L1.804|
                          DCD      0xe000ed18
                  |L1.808|
                          DCD      0xe000e400
                  |L1.812|
                          DCD      0x400a1000
                  |L1.816|
                          DCD      0x40101218
                  |L1.820|
                          DCD      0xe000e180

                          AREA ||.ARM.exidx||, LINKORDER=||.text||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||.text||
                          DCD      0x00000001

                          AREA ||.data||, DATA, ALIGN=2

                  g_i2c0
                          DCD      0x00000000

                          AREA ||.constdata__ZTV3I2c||, COMGROUP=_ZTV3I2c, DATA, READONLY, ALIGN=2

                  _ZTV3I2c ; vtable for I2c
                          DCD      0x00000000
                          DCD      _ZTI3I2c ; typeinfo for I2c
                          DCD      _ZN3I2c4openEv ; I2c::open()
                          DCD      _ZN3I2c5closeEv ; I2c::close()
                          DCD      _ZN3I2c7receiveEPhj ; I2c::receive(unsigned char*, unsigned)
                          DCD      _ZN3I2c10receiveLenEv ; I2c::receiveLen()
                          DCD      _ZN3I2c6updateEv ; I2c::update()

                          AREA ||t._ZN8ReceiveQIhE10receiveLenEv||, COMGROUP=_ZN8ReceiveQIhE10receiveLenEv, CODE, READONLY, ALIGN=1

                  _ZN8ReceiveQIhE10receiveLenEv PROC ; ReceiveQ<unsigned char>::receiveLen()
;;;41     
;;;42     	inline int32_t receiveLen()
000000  4601              MOV      r1,r0
;;;43     	{
;;;44     		return m_produced - m_consumed;
000002  e9d10204          LDRD     r0,r2,[r1,#0x10]
000006  1a80              SUBS     r0,r0,r2
;;;45     	}
000008  4770              BX       lr
;;;46     
                          ENDP


                          AREA ||area_number.21||, COMGROUP=_ZN8ReceiveQIhE10receiveLenEv, LINKORDER=||t._ZN8ReceiveQIhE10receiveLenEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.21||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN8ReceiveQIhE10receiveLenEv||
                          DCD      0x00000001

                          AREA ||.constdata__ZTV7Iserial||, COMGROUP=_ZTV7Iserial, DATA, READONLY, ALIGN=2

                  _ZTV7Iserial ; vtable for Iserial
                          DCD      0x00000000
                          DCD      _ZTI7Iserial ; typeinfo for Iserial
                          DCD      _ZN7Iserial4openEv ; Iserial::open()
                          DCD      _ZN7Iserial5closeEv ; Iserial::close()
                          DCD      _ZN7Iserial7receiveEPhj ; Iserial::receive(unsigned char*, unsigned)
                          DCD      _ZN7Iserial10receiveLenEv ; Iserial::receiveLen()
                          DCD      _ZN7Iserial6updateEv ; Iserial::update()

                          AREA ||.constdata__ZTI3I2c||, COMGROUP=_ZTI3I2c, DATA, READONLY, ALIGN=2

                  _ZTI3I2c ; typeinfo for I2c
                          DCD      _ZTVN10__cxxabiv120__si_class_type_infoE+0x8 ; vtable for __cxxabiv1::__si_class_type_info
                          DCD      _ZTS3I2c ; typeinfo name for I2c
                          DCD      _ZTI7Iserial ; typeinfo for Iserial

                          AREA ||.constdata__ZTI7Iserial||, COMGROUP=_ZTI7Iserial, DATA, READONLY, ALIGN=2

                  _ZTI7Iserial ; typeinfo for Iserial
                          DCD      _ZTVN10__cxxabiv117__class_type_infoE+0x8 ; vtable for __cxxabiv1::__class_type_info
                          DCD      _ZTS7Iserial ; typeinfo name for Iserial

                          AREA ||.constdata__ZTS3I2c||, COMGROUP=_ZTS3I2c, DATA, READONLY, ALIGN=0

                  _ZTS3I2c ; typeinfo name for I2c
000000  33493263          DCB      0x33,0x49,0x32,0x63
000004  00                DCB      0x00

                          AREA ||.constdata__ZTS7Iserial||, COMGROUP=_ZTS7Iserial, DATA, READONLY, ALIGN=0

                  _ZTS7Iserial ; typeinfo name for Iserial
000000  37497365          DCB      0x37,0x49,0x73,0x65
000004  7269616c          DCB      0x72,0x69,0x61,0x6c
000008  00                DCB      0x00

                          AREA ||i._ZN7Iserial4openEv||, COMGROUP=_ZN7Iserial4openEv, CODE, READONLY, ALIGN=1

                  _ZN7Iserial4openEv PROC ; Iserial::open()
;;;131    public:
;;;132    	virtual int open()
000000  4601              MOV      r1,r0
;;;133    	{
;;;134    		return 0;
000002  2000              MOVS     r0,#0
;;;135    	}
000004  4770              BX       lr
;;;136    	virtual int close()
                          ENDP


                          AREA ||area_number.39||, COMGROUP=_ZN7Iserial4openEv, LINKORDER=||i._ZN7Iserial4openEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.39||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN7Iserial4openEv||
                          DCD      0x00000001

                          AREA ||i._ZN7Iserial5closeEv||, COMGROUP=_ZN7Iserial5closeEv, CODE, READONLY, ALIGN=1

                  _ZN7Iserial5closeEv PROC ; Iserial::close()
;;;135    	}
;;;136    	virtual int close()
000000  4601              MOV      r1,r0
;;;137    	{
;;;138    		return 0;
000002  2000              MOVS     r0,#0
;;;139    	}
000004  4770              BX       lr
;;;140    	virtual int receive(uint8_t *buf, uint32_t len)
                          ENDP


                          AREA ||area_number.46||, COMGROUP=_ZN7Iserial5closeEv, LINKORDER=||i._ZN7Iserial5closeEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.46||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN7Iserial5closeEv||
                          DCD      0x00000001

                          AREA ||i._ZN7Iserial7receiveEPhj||, COMGROUP=_ZN7Iserial7receiveEPhj, CODE, READONLY, ALIGN=1

                  _ZN7Iserial7receiveEPhj PROC ; Iserial::receive(unsigned char*, unsigned)
;;;139    	}
;;;140    	virtual int receive(uint8_t *buf, uint32_t len)
000000  4603              MOV      r3,r0
;;;141    	{
;;;142    		return 0;
000002  2000              MOVS     r0,#0
;;;143    	}
000004  4770              BX       lr
;;;144    	virtual int receiveLen()
                          ENDP


                          AREA ||area_number.53||, COMGROUP=_ZN7Iserial7receiveEPhj, LINKORDER=||i._ZN7Iserial7receiveEPhj||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.53||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN7Iserial7receiveEPhj||
                          DCD      0x00000001

                          AREA ||i._ZN7Iserial10receiveLenEv||, COMGROUP=_ZN7Iserial10receiveLenEv, CODE, READONLY, ALIGN=1

                  _ZN7Iserial10receiveLenEv PROC ; Iserial::receiveLen()
;;;143    	}
;;;144    	virtual int receiveLen()
000000  4601              MOV      r1,r0
;;;145    	{
;;;146    		return 0;
000002  2000              MOVS     r0,#0
;;;147    	}
000004  4770              BX       lr
;;;148    	virtual int update()
                          ENDP


                          AREA ||area_number.60||, COMGROUP=_ZN7Iserial10receiveLenEv, LINKORDER=||i._ZN7Iserial10receiveLenEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.60||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN7Iserial10receiveLenEv||
                          DCD      0x00000001

                          AREA ||i._ZN7Iserial6updateEv||, COMGROUP=_ZN7Iserial6updateEv, CODE, READONLY, ALIGN=1

                  _ZN7Iserial6updateEv PROC ; Iserial::update()
;;;147    	}
;;;148    	virtual int update()
000000  4601              MOV      r1,r0
;;;149    	{
;;;150    		return 0;
000002  2000              MOVS     r0,#0
;;;151    	}
000004  4770              BX       lr
;;;152    };
                          ENDP


                          AREA ||area_number.67||, COMGROUP=_ZN7Iserial6updateEv, LINKORDER=||i._ZN7Iserial6updateEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.67||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN7Iserial6updateEv||
                          DCD      0x00000001

;*** Start embedded assembler ***

#line 1 "..\\libpixy\\i2c.cpp"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___7_i2c_cpp_b80b4882___Z7__REV16j|
#line 130 "..\\libpixy\\core_cmInstr.h"
|__asm___7_i2c_cpp_b80b4882___Z7__REV16j| PROC
#line 131

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___7_i2c_cpp_b80b4882___Z7__REVSHi|
#line 144
|__asm___7_i2c_cpp_b80b4882___Z7__REVSHi| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
